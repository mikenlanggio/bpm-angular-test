{"ast":null,"code":"import { assign } from 'min-dash';\nimport { is } from '../util/ModelUtil';\nimport { isLabelExternal, getExternalLabelBounds } from '../util/LabelUtil';\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\nimport { isExpanded } from '../util/DiUtil';\nimport { getLabel } from '../features/label-editing/LabelUtil';\nimport { elementToString } from './Util';\n/**\n * @param {ModdleElement} semantic\n * @param {ModdleElement} di\n * @param {Object} [attrs=null]\n *\n * @return {Object}\n */\n\nfunction elementData(semantic, di, attrs) {\n  return assign({\n    id: semantic.id,\n    type: semantic.$type,\n    businessObject: semantic,\n    di: di\n  }, attrs);\n}\n\nfunction getWaypoints(di, source, target) {\n  var waypoints = di.waypoint;\n\n  if (!waypoints || waypoints.length < 2) {\n    return [getMid(source), getMid(target)];\n  }\n\n  return waypoints.map(function (p) {\n    return {\n      x: p.x,\n      y: p.y\n    };\n  });\n}\n\nfunction notYetDrawn(translate, semantic, refSemantic, property) {\n  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {\n    element: elementToString(refSemantic),\n    referenced: elementToString(semantic),\n    property: property\n  }));\n}\n/**\n * An importer that adds bpmn elements to the canvas\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {ElementFactory} elementFactory\n * @param {ElementRegistry} elementRegistry\n * @param {Function} translate\n * @param {TextRenderer} textRenderer\n */\n\n\nexport default function BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, translate, textRenderer) {\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n  this._elementFactory = elementFactory;\n  this._elementRegistry = elementRegistry;\n  this._translate = translate;\n  this._textRenderer = textRenderer;\n}\nBpmnImporter.$inject = ['eventBus', 'canvas', 'elementFactory', 'elementRegistry', 'translate', 'textRenderer'];\n/**\n * Add bpmn element (semantic) to the canvas onto the\n * specified parent shape.\n */\n\nBpmnImporter.prototype.add = function (semantic, di, parentElement) {\n  var element,\n      translate = this._translate,\n      hidden;\n  var parentIndex; // ROOT ELEMENT\n  // handle the special case that we deal with a\n  // invisible root element (process, subprocess or collaboration)\n\n  if (is(di, 'bpmndi:BPMNPlane')) {\n    var attrs = is(semantic, 'bpmn:SubProcess') ? {\n      id: semantic.id + '_plane'\n    } : {}; // add a virtual element (not being drawn)\n\n    element = this._elementFactory.createRoot(elementData(semantic, di, attrs));\n\n    this._canvas.addRootElement(element);\n  } // SHAPE\n  else if (is(di, 'bpmndi:BPMNShape')) {\n    var collapsed = !isExpanded(semantic, di),\n        isFrame = isFrameElement(semantic);\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n    var bounds = di.bounds;\n    element = this._elementFactory.createShape(elementData(semantic, di, {\n      collapsed: collapsed,\n      hidden: hidden,\n      x: Math.round(bounds.x),\n      y: Math.round(bounds.y),\n      width: Math.round(bounds.width),\n      height: Math.round(bounds.height),\n      isFrame: isFrame\n    }));\n\n    if (is(semantic, 'bpmn:BoundaryEvent')) {\n      this._attachBoundary(semantic, element);\n    } // insert lanes behind other flow nodes (cf. #727)\n\n\n    if (is(semantic, 'bpmn:Lane')) {\n      parentIndex = 0;\n    }\n\n    if (is(semantic, 'bpmn:DataStoreReference')) {\n      // check whether data store is inside our outside of its semantic parent\n      if (!isPointInsideBBox(parentElement, getMid(bounds))) {\n        parentElement = this._canvas.findRoot(parentElement);\n      }\n    }\n\n    this._canvas.addShape(element, parentElement, parentIndex);\n  } // CONNECTION\n  else if (is(di, 'bpmndi:BPMNEdge')) {\n    var source = this._getSource(semantic),\n        target = this._getTarget(semantic);\n\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n    element = this._elementFactory.createConnection(elementData(semantic, di, {\n      hidden: hidden,\n      source: source,\n      target: target,\n      waypoints: getWaypoints(di, source, target)\n    }));\n\n    if (is(semantic, 'bpmn:DataAssociation')) {\n      // render always on top; this ensures DataAssociations\n      // are rendered correctly across different \"hacks\" people\n      // love to model such as cross participant / sub process\n      // associations\n      parentElement = this._canvas.findRoot(parentElement);\n    }\n\n    this._canvas.addConnection(element, parentElement, parentIndex);\n  } else {\n    throw new Error(translate('unknown di {di} for element {semantic}', {\n      di: elementToString(di),\n      semantic: elementToString(semantic)\n    }));\n  } // (optional) LABEL\n\n\n  if (isLabelExternal(semantic) && getLabel(element)) {\n    this.addLabel(semantic, di, element);\n  }\n\n  this._eventBus.fire('bpmnElement.added', {\n    element: element\n  });\n\n  return element;\n};\n/**\n * Attach the boundary element to the given host\n *\n * @param {ModdleElement} boundarySemantic\n * @param {djs.model.Base} boundaryElement\n */\n\n\nBpmnImporter.prototype._attachBoundary = function (boundarySemantic, boundaryElement) {\n  var translate = this._translate;\n  var hostSemantic = boundarySemantic.attachedToRef;\n\n  if (!hostSemantic) {\n    throw new Error(translate('missing {semantic}#attachedToRef', {\n      semantic: elementToString(boundarySemantic)\n    }));\n  }\n\n  var host = this._elementRegistry.get(hostSemantic.id),\n      attachers = host && host.attachers;\n\n  if (!host) {\n    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');\n  } // wire element.host <> host.attachers\n\n\n  boundaryElement.host = host;\n\n  if (!attachers) {\n    host.attachers = attachers = [];\n  }\n\n  if (attachers.indexOf(boundaryElement) === -1) {\n    attachers.push(boundaryElement);\n  }\n};\n/**\n * add label for an element\n */\n\n\nBpmnImporter.prototype.addLabel = function (semantic, di, element) {\n  var bounds, text, label;\n  bounds = getExternalLabelBounds(di, element);\n  text = getLabel(element);\n\n  if (text) {\n    // get corrected bounds from actual layouted text\n    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);\n  }\n\n  label = this._elementFactory.createLabel(elementData(semantic, di, {\n    id: semantic.id + '_label',\n    labelTarget: element,\n    type: 'label',\n    hidden: element.hidden || !getLabel(element),\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  }));\n  return this._canvas.addShape(label, element.parent);\n};\n/**\n * Return the drawn connection end based on the given side.\n *\n * @throws {Error} if the end is not yet drawn\n */\n\n\nBpmnImporter.prototype._getEnd = function (semantic, side) {\n  var element,\n      refSemantic,\n      type = semantic.$type,\n      translate = this._translate;\n  refSemantic = semantic[side + 'Ref']; // handle mysterious isMany DataAssociation#sourceRef\n\n  if (side === 'source' && type === 'bpmn:DataInputAssociation') {\n    refSemantic = refSemantic && refSemantic[0];\n  } // fix source / target for DataInputAssociation / DataOutputAssociation\n\n\n  if (side === 'source' && type === 'bpmn:DataOutputAssociation' || side === 'target' && type === 'bpmn:DataInputAssociation') {\n    refSemantic = semantic.$parent;\n  }\n\n  element = refSemantic && this._getElement(refSemantic);\n\n  if (element) {\n    return element;\n  }\n\n  if (refSemantic) {\n    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');\n  } else {\n    throw new Error(translate('{semantic}#{side} Ref not specified', {\n      semantic: elementToString(semantic),\n      side: side\n    }));\n  }\n};\n\nBpmnImporter.prototype._getSource = function (semantic) {\n  return this._getEnd(semantic, 'source');\n};\n\nBpmnImporter.prototype._getTarget = function (semantic) {\n  return this._getEnd(semantic, 'target');\n};\n\nBpmnImporter.prototype._getElement = function (semantic) {\n  return this._elementRegistry.get(semantic.id);\n}; // helpers ////////////////////\n\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n}\n\nfunction isFrameElement(semantic) {\n  return is(semantic, 'bpmn:Group');\n}","map":{"version":3,"names":["assign","is","isLabelExternal","getExternalLabelBounds","getMid","isExpanded","getLabel","elementToString","elementData","semantic","di","attrs","id","type","$type","businessObject","getWaypoints","source","target","waypoints","waypoint","length","map","p","x","y","notYetDrawn","translate","refSemantic","property","Error","element","referenced","BpmnImporter","eventBus","canvas","elementFactory","elementRegistry","textRenderer","_eventBus","_canvas","_elementFactory","_elementRegistry","_translate","_textRenderer","$inject","prototype","add","parentElement","hidden","parentIndex","createRoot","addRootElement","collapsed","isFrame","isFrameElement","bounds","createShape","Math","round","width","height","_attachBoundary","isPointInsideBBox","findRoot","addShape","_getSource","_getTarget","createConnection","addConnection","addLabel","fire","boundarySemantic","boundaryElement","hostSemantic","attachedToRef","host","get","attachers","indexOf","push","text","label","createLabel","labelTarget","parent","_getEnd","side","$parent","_getElement","bbox","point"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/import/BpmnImporter.js"],"sourcesContent":["import {\n  assign\n} from 'min-dash';\n\nimport { is } from '../util/ModelUtil';\n\nimport {\n  isLabelExternal,\n  getExternalLabelBounds\n} from '../util/LabelUtil';\n\nimport {\n  getMid\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  isExpanded\n} from '../util/DiUtil';\n\nimport {\n  getLabel\n} from '../features/label-editing/LabelUtil';\n\nimport {\n  elementToString\n} from './Util';\n\n\n/**\n * @param {ModdleElement} semantic\n * @param {ModdleElement} di\n * @param {Object} [attrs=null]\n *\n * @return {Object}\n */\nfunction elementData(semantic, di, attrs) {\n  return assign({\n    id: semantic.id,\n    type: semantic.$type,\n    businessObject: semantic,\n    di: di\n  }, attrs);\n}\n\nfunction getWaypoints(di, source, target) {\n\n  var waypoints = di.waypoint;\n\n  if (!waypoints || waypoints.length < 2) {\n    return [ getMid(source), getMid(target) ];\n  }\n\n  return waypoints.map(function(p) {\n    return { x: p.x, y: p.y };\n  });\n}\n\nfunction notYetDrawn(translate, semantic, refSemantic, property) {\n  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {\n    element: elementToString(refSemantic),\n    referenced: elementToString(semantic),\n    property: property\n  }));\n}\n\n\n/**\n * An importer that adds bpmn elements to the canvas\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {ElementFactory} elementFactory\n * @param {ElementRegistry} elementRegistry\n * @param {Function} translate\n * @param {TextRenderer} textRenderer\n */\nexport default function BpmnImporter(\n    eventBus, canvas, elementFactory,\n    elementRegistry, translate, textRenderer) {\n\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n  this._elementFactory = elementFactory;\n  this._elementRegistry = elementRegistry;\n  this._translate = translate;\n  this._textRenderer = textRenderer;\n}\n\nBpmnImporter.$inject = [\n  'eventBus',\n  'canvas',\n  'elementFactory',\n  'elementRegistry',\n  'translate',\n  'textRenderer'\n];\n\n\n/**\n * Add bpmn element (semantic) to the canvas onto the\n * specified parent shape.\n */\nBpmnImporter.prototype.add = function(semantic, di, parentElement) {\n  var element,\n      translate = this._translate,\n      hidden;\n\n  var parentIndex;\n\n  // ROOT ELEMENT\n  // handle the special case that we deal with a\n  // invisible root element (process, subprocess or collaboration)\n  if (is(di, 'bpmndi:BPMNPlane')) {\n\n    var attrs = is(semantic, 'bpmn:SubProcess')\n      ? { id: semantic.id + '_plane' }\n      : {};\n\n    // add a virtual element (not being drawn)\n    element = this._elementFactory.createRoot(elementData(semantic, di, attrs));\n\n    this._canvas.addRootElement(element);\n  }\n\n  // SHAPE\n  else if (is(di, 'bpmndi:BPMNShape')) {\n\n    var collapsed = !isExpanded(semantic, di),\n        isFrame = isFrameElement(semantic);\n\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n\n    var bounds = di.bounds;\n\n    element = this._elementFactory.createShape(elementData(semantic, di, {\n      collapsed: collapsed,\n      hidden: hidden,\n      x: Math.round(bounds.x),\n      y: Math.round(bounds.y),\n      width: Math.round(bounds.width),\n      height: Math.round(bounds.height),\n      isFrame: isFrame\n    }));\n\n    if (is(semantic, 'bpmn:BoundaryEvent')) {\n      this._attachBoundary(semantic, element);\n    }\n\n    // insert lanes behind other flow nodes (cf. #727)\n    if (is(semantic, 'bpmn:Lane')) {\n      parentIndex = 0;\n    }\n\n    if (is(semantic, 'bpmn:DataStoreReference')) {\n\n      // check whether data store is inside our outside of its semantic parent\n      if (!isPointInsideBBox(parentElement, getMid(bounds))) {\n        parentElement = this._canvas.findRoot(parentElement);\n      }\n    }\n\n    this._canvas.addShape(element, parentElement, parentIndex);\n  }\n\n  // CONNECTION\n  else if (is(di, 'bpmndi:BPMNEdge')) {\n\n    var source = this._getSource(semantic),\n        target = this._getTarget(semantic);\n\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n\n    element = this._elementFactory.createConnection(elementData(semantic, di, {\n      hidden: hidden,\n      source: source,\n      target: target,\n      waypoints: getWaypoints(di, source, target)\n    }));\n\n    if (is(semantic, 'bpmn:DataAssociation')) {\n\n      // render always on top; this ensures DataAssociations\n      // are rendered correctly across different \"hacks\" people\n      // love to model such as cross participant / sub process\n      // associations\n      parentElement = this._canvas.findRoot(parentElement);\n    }\n\n    this._canvas.addConnection(element, parentElement, parentIndex);\n  } else {\n    throw new Error(translate('unknown di {di} for element {semantic}', {\n      di: elementToString(di),\n      semantic: elementToString(semantic)\n    }));\n  }\n\n  // (optional) LABEL\n  if (isLabelExternal(semantic) && getLabel(element)) {\n    this.addLabel(semantic, di, element);\n  }\n\n\n  this._eventBus.fire('bpmnElement.added', { element: element });\n\n  return element;\n};\n\n\n/**\n * Attach the boundary element to the given host\n *\n * @param {ModdleElement} boundarySemantic\n * @param {djs.model.Base} boundaryElement\n */\nBpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {\n  var translate = this._translate;\n  var hostSemantic = boundarySemantic.attachedToRef;\n\n  if (!hostSemantic) {\n    throw new Error(translate('missing {semantic}#attachedToRef', {\n      semantic: elementToString(boundarySemantic)\n    }));\n  }\n\n  var host = this._elementRegistry.get(hostSemantic.id),\n      attachers = host && host.attachers;\n\n  if (!host) {\n    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');\n  }\n\n  // wire element.host <> host.attachers\n  boundaryElement.host = host;\n\n  if (!attachers) {\n    host.attachers = attachers = [];\n  }\n\n  if (attachers.indexOf(boundaryElement) === -1) {\n    attachers.push(boundaryElement);\n  }\n};\n\n\n/**\n * add label for an element\n */\nBpmnImporter.prototype.addLabel = function(semantic, di, element) {\n  var bounds,\n      text,\n      label;\n\n  bounds = getExternalLabelBounds(di, element);\n\n  text = getLabel(element);\n\n  if (text) {\n\n    // get corrected bounds from actual layouted text\n    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);\n  }\n\n  label = this._elementFactory.createLabel(elementData(semantic, di, {\n    id: semantic.id + '_label',\n    labelTarget: element,\n    type: 'label',\n    hidden: element.hidden || !getLabel(element),\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  }));\n\n  return this._canvas.addShape(label, element.parent);\n};\n\n/**\n * Return the drawn connection end based on the given side.\n *\n * @throws {Error} if the end is not yet drawn\n */\nBpmnImporter.prototype._getEnd = function(semantic, side) {\n\n  var element,\n      refSemantic,\n      type = semantic.$type,\n      translate = this._translate;\n\n  refSemantic = semantic[side + 'Ref'];\n\n  // handle mysterious isMany DataAssociation#sourceRef\n  if (side === 'source' && type === 'bpmn:DataInputAssociation') {\n    refSemantic = refSemantic && refSemantic[0];\n  }\n\n  // fix source / target for DataInputAssociation / DataOutputAssociation\n  if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||\n      side === 'target' && type === 'bpmn:DataInputAssociation') {\n\n    refSemantic = semantic.$parent;\n  }\n\n  element = refSemantic && this._getElement(refSemantic);\n\n  if (element) {\n    return element;\n  }\n\n  if (refSemantic) {\n    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');\n  } else {\n    throw new Error(translate('{semantic}#{side} Ref not specified', {\n      semantic: elementToString(semantic),\n      side: side\n    }));\n  }\n};\n\nBpmnImporter.prototype._getSource = function(semantic) {\n  return this._getEnd(semantic, 'source');\n};\n\nBpmnImporter.prototype._getTarget = function(semantic) {\n  return this._getEnd(semantic, 'target');\n};\n\n\nBpmnImporter.prototype._getElement = function(semantic) {\n  return this._elementRegistry.get(semantic.id);\n};\n\n\n// helpers ////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n\n  return x >= bbox.x &&\n    x <= bbox.x + bbox.width &&\n    y >= bbox.y &&\n    y <= bbox.y + bbox.height;\n}\n\nfunction isFrameElement(semantic) {\n  return is(semantic, 'bpmn:Group');\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}