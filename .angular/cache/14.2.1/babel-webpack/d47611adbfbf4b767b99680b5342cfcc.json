{"ast":null,"code":"import inherits from 'inherits-browser';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { add as collectionAdd, remove as collectionRemove } from 'diagram-js/lib/util/Collections';\nimport { find } from 'min-dash';\nimport { is } from '../../../util/ModelUtil';\nvar TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';\n/**\n * This behavior makes sure we always set a fake\n * DataInputAssociation#targetRef as demanded by the BPMN 2.0\n * XSD schema.\n *\n * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }\n * which is created on the fly and cleaned up afterwards if not needed\n * anymore.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n */\n\nexport default function DataInputAssociationBehavior(eventBus, bpmnFactory) {\n  CommandInterceptor.call(this, eventBus);\n  this.executed(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], ifDataInputAssociation(fixTargetRef));\n  this.reverted(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], ifDataInputAssociation(fixTargetRef));\n\n  function usesTargetRef(element, targetRef, removedConnection) {\n    var inputAssociations = element.get('dataInputAssociations');\n    return find(inputAssociations, function (association) {\n      return association !== removedConnection && association.targetRef === targetRef;\n    });\n  }\n\n  function getTargetRef(element, create) {\n    var properties = element.get('properties');\n    var targetRefProp = find(properties, function (p) {\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\n    });\n\n    if (!targetRefProp && create) {\n      targetRefProp = bpmnFactory.create('bpmn:Property', {\n        name: TARGET_REF_PLACEHOLDER_NAME\n      });\n      collectionAdd(properties, targetRefProp);\n    }\n\n    return targetRefProp;\n  }\n\n  function cleanupTargetRef(element, connection) {\n    var targetRefProp = getTargetRef(element);\n\n    if (!targetRefProp) {\n      return;\n    }\n\n    if (!usesTargetRef(element, targetRefProp, connection)) {\n      collectionRemove(element.get('properties'), targetRefProp);\n    }\n  }\n  /**\n   * Make sure targetRef is set to a valid property or\n   * `null` if the connection is detached.\n   *\n   * @param {Event} event\n   */\n\n\n  function fixTargetRef(event) {\n    var context = event.context,\n        connection = context.connection,\n        connectionBo = connection.businessObject,\n        target = connection.target,\n        targetBo = target && target.businessObject,\n        newTarget = context.newTarget,\n        newTargetBo = newTarget && newTarget.businessObject,\n        oldTarget = context.oldTarget || context.target,\n        oldTargetBo = oldTarget && oldTarget.businessObject;\n    var dataAssociation = connection.businessObject,\n        targetRefProp;\n\n    if (oldTargetBo && oldTargetBo !== targetBo) {\n      cleanupTargetRef(oldTargetBo, connectionBo);\n    }\n\n    if (newTargetBo && newTargetBo !== targetBo) {\n      cleanupTargetRef(newTargetBo, connectionBo);\n    }\n\n    if (targetBo) {\n      targetRefProp = getTargetRef(targetBo, true);\n      dataAssociation.targetRef = targetRefProp;\n    } else {\n      dataAssociation.targetRef = null;\n    }\n  }\n}\nDataInputAssociationBehavior.$inject = ['eventBus', 'bpmnFactory'];\ninherits(DataInputAssociationBehavior, CommandInterceptor);\n/**\n * Only call the given function when the event\n * touches a bpmn:DataInputAssociation.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nfunction ifDataInputAssociation(fn) {\n  return function (event) {\n    var context = event.context,\n        connection = context.connection;\n\n    if (is(connection, 'bpmn:DataInputAssociation')) {\n      return fn(event);\n    }\n  };\n}","map":{"version":3,"names":["inherits","CommandInterceptor","add","collectionAdd","remove","collectionRemove","find","is","TARGET_REF_PLACEHOLDER_NAME","DataInputAssociationBehavior","eventBus","bpmnFactory","call","executed","ifDataInputAssociation","fixTargetRef","reverted","usesTargetRef","element","targetRef","removedConnection","inputAssociations","get","association","getTargetRef","create","properties","targetRefProp","p","name","cleanupTargetRef","connection","event","context","connectionBo","businessObject","target","targetBo","newTarget","newTargetBo","oldTarget","oldTargetBo","dataAssociation","$inject","fn"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/features/modeling/behavior/DataInputAssociationBehavior.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport {\n  add as collectionAdd,\n  remove as collectionRemove\n} from 'diagram-js/lib/util/Collections';\n\nimport {\n  find\n} from 'min-dash';\n\nimport {\n  is\n} from '../../../util/ModelUtil';\n\nvar TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';\n\n\n/**\n * This behavior makes sure we always set a fake\n * DataInputAssociation#targetRef as demanded by the BPMN 2.0\n * XSD schema.\n *\n * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }\n * which is created on the fly and cleaned up afterwards if not needed\n * anymore.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n */\nexport default function DataInputAssociationBehavior(eventBus, bpmnFactory) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  this.executed([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnect'\n  ], ifDataInputAssociation(fixTargetRef));\n\n  this.reverted([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnect'\n  ], ifDataInputAssociation(fixTargetRef));\n\n\n  function usesTargetRef(element, targetRef, removedConnection) {\n\n    var inputAssociations = element.get('dataInputAssociations');\n\n    return find(inputAssociations, function(association) {\n      return association !== removedConnection &&\n             association.targetRef === targetRef;\n    });\n  }\n\n  function getTargetRef(element, create) {\n\n    var properties = element.get('properties');\n\n    var targetRefProp = find(properties, function(p) {\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\n    });\n\n    if (!targetRefProp && create) {\n      targetRefProp = bpmnFactory.create('bpmn:Property', {\n        name: TARGET_REF_PLACEHOLDER_NAME\n      });\n\n      collectionAdd(properties, targetRefProp);\n    }\n\n    return targetRefProp;\n  }\n\n  function cleanupTargetRef(element, connection) {\n\n    var targetRefProp = getTargetRef(element);\n\n    if (!targetRefProp) {\n      return;\n    }\n\n    if (!usesTargetRef(element, targetRefProp, connection)) {\n      collectionRemove(element.get('properties'), targetRefProp);\n    }\n  }\n\n  /**\n   * Make sure targetRef is set to a valid property or\n   * `null` if the connection is detached.\n   *\n   * @param {Event} event\n   */\n  function fixTargetRef(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        connectionBo = connection.businessObject,\n        target = connection.target,\n        targetBo = target && target.businessObject,\n        newTarget = context.newTarget,\n        newTargetBo = newTarget && newTarget.businessObject,\n        oldTarget = context.oldTarget || context.target,\n        oldTargetBo = oldTarget && oldTarget.businessObject;\n\n    var dataAssociation = connection.businessObject,\n        targetRefProp;\n\n    if (oldTargetBo && oldTargetBo !== targetBo) {\n      cleanupTargetRef(oldTargetBo, connectionBo);\n    }\n\n    if (newTargetBo && newTargetBo !== targetBo) {\n      cleanupTargetRef(newTargetBo, connectionBo);\n    }\n\n    if (targetBo) {\n      targetRefProp = getTargetRef(targetBo, true);\n      dataAssociation.targetRef = targetRefProp;\n    } else {\n      dataAssociation.targetRef = null;\n    }\n  }\n}\n\nDataInputAssociationBehavior.$inject = [\n  'eventBus',\n  'bpmnFactory'\n];\n\ninherits(DataInputAssociationBehavior, CommandInterceptor);\n\n\n/**\n * Only call the given function when the event\n * touches a bpmn:DataInputAssociation.\n *\n * @param {Function} fn\n * @return {Function}\n */\nfunction ifDataInputAssociation(fn) {\n\n  return function(event) {\n    var context = event.context,\n        connection = context.connection;\n\n    if (is(connection, 'bpmn:DataInputAssociation')) {\n      return fn(event);\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}