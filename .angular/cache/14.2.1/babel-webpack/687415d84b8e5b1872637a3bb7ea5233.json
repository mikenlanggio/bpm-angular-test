{"ast":null,"code":"var MARKER_OK = 'drop-ok',\n    MARKER_NOT_OK = 'drop-not-ok',\n    MARKER_ATTACH = 'attach-ok',\n    MARKER_NEW_PARENT = 'new-parent';\nimport { assign, filter, find, forEach, isArray, isNumber, map } from 'min-dash';\nimport { getBBox } from '../../util/Elements';\nvar PREFIX = 'create';\nvar HIGH_PRIORITY = 2000;\n/**\n * Create new elements through drag and drop.\n *\n * @param {Canvas} canvas\n * @param {Dragging} dragging\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\n\nexport default function Create(canvas, dragging, eventBus, modeling, rules) {\n  // rules //////////\n\n  /**\n   * Check wether elements can be created.\n   *\n   * @param {Array<djs.model.Base>} elements\n   * @param {djs.model.Base} target\n   * @param {Point} position\n   * @param {djs.model.Base} [source]\n   *\n   * @returns {boolean|null|Object}\n   */\n  function canCreate(elements, target, position, source, hints) {\n    if (!target) {\n      return false;\n    } // ignore child elements and external labels\n\n\n    elements = filter(elements, function (element) {\n      var labelTarget = element.labelTarget;\n      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);\n    });\n    var shape = find(elements, function (element) {\n      return !isConnection(element);\n    });\n    var attach = false,\n        connect = false,\n        create = false; // (1) attaching single shapes\n\n    if (isSingleShape(elements)) {\n      attach = rules.allowed('shape.attach', {\n        position: position,\n        shape: shape,\n        target: target\n      });\n    }\n\n    if (!attach) {\n      // (2) creating elements\n      if (isSingleShape(elements)) {\n        create = rules.allowed('shape.create', {\n          position: position,\n          shape: shape,\n          source: source,\n          target: target\n        });\n      } else {\n        create = rules.allowed('elements.create', {\n          elements: elements,\n          position: position,\n          target: target\n        });\n      }\n    }\n\n    var connectionTarget = hints.connectionTarget; // (3) appending single shapes\n\n    if (create || attach) {\n      if (shape && source) {\n        connect = rules.allowed('connection.create', {\n          source: connectionTarget === source ? shape : source,\n          target: connectionTarget === source ? source : shape,\n          hints: {\n            targetParent: target,\n            targetAttach: attach\n          }\n        });\n      }\n\n      return {\n        attach: attach,\n        connect: connect\n      };\n    } // ignore wether or not elements can be created\n\n\n    if (create === null || attach === null) {\n      return null;\n    }\n\n    return false;\n  }\n\n  function setMarker(element, marker) {\n    [MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT].forEach(function (m) {\n      if (m === marker) {\n        canvas.addMarker(element, m);\n      } else {\n        canvas.removeMarker(element, m);\n      }\n    });\n  } // event handling //////////\n\n\n  eventBus.on(['create.move', 'create.hover'], function (event) {\n    var context = event.context,\n        elements = context.elements,\n        hover = event.hover,\n        source = context.source,\n        hints = context.hints || {};\n\n    if (!hover) {\n      context.canExecute = false;\n      context.target = null;\n      return;\n    }\n\n    ensureConstraints(event);\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n    var canExecute = context.canExecute = hover && canCreate(elements, hover, position, source, hints);\n\n    if (hover && canExecute !== null) {\n      context.target = hover;\n\n      if (canExecute && canExecute.attach) {\n        setMarker(hover, MARKER_ATTACH);\n      } else {\n        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);\n      }\n    }\n  });\n  eventBus.on(['create.end', 'create.out', 'create.cleanup'], function (event) {\n    var hover = event.hover;\n\n    if (hover) {\n      setMarker(hover, null);\n    }\n  });\n  eventBus.on('create.end', function (event) {\n    var context = event.context,\n        source = context.source,\n        shape = context.shape,\n        elements = context.elements,\n        target = context.target,\n        canExecute = context.canExecute,\n        attach = canExecute && canExecute.attach,\n        connect = canExecute && canExecute.connect,\n        hints = context.hints || {};\n\n    if (canExecute === false || !target) {\n      return false;\n    }\n\n    ensureConstraints(event);\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n\n    if (connect) {\n      shape = modeling.appendShape(source, shape, position, target, {\n        attach: attach,\n        connection: connect === true ? {} : connect,\n        connectionTarget: hints.connectionTarget\n      });\n    } else {\n      elements = modeling.createElements(elements, position, target, assign({}, hints, {\n        attach: attach\n      })); // update shape\n\n      shape = find(elements, function (element) {\n        return !isConnection(element);\n      });\n    } // update elements and shape\n\n\n    assign(context, {\n      elements: elements,\n      shape: shape\n    });\n    assign(event, {\n      elements: elements,\n      shape: shape\n    });\n  });\n\n  function cancel() {\n    var context = dragging.context();\n\n    if (context && context.prefix === PREFIX) {\n      dragging.cancel();\n    }\n  } // cancel on <elements.changed> that is not result of <drag.end>\n\n\n  eventBus.on('create.init', function () {\n    eventBus.on('elements.changed', cancel);\n    eventBus.once(['create.cancel', 'create.end'], HIGH_PRIORITY, function () {\n      eventBus.off('elements.changed', cancel);\n    });\n  }); // API //////////\n\n  this.start = function (event, elements, context) {\n    if (!isArray(elements)) {\n      elements = [elements];\n    }\n\n    var shape = find(elements, function (element) {\n      return !isConnection(element);\n    });\n\n    if (!shape) {\n      // at least one shape is required\n      return;\n    }\n\n    context = assign({\n      elements: elements,\n      hints: {},\n      shape: shape\n    }, context || {}); // make sure each element has x and y\n\n    forEach(elements, function (element) {\n      if (!isNumber(element.x)) {\n        element.x = 0;\n      }\n\n      if (!isNumber(element.y)) {\n        element.y = 0;\n      }\n    });\n    var visibleElements = filter(elements, function (element) {\n      return !element.hidden;\n    });\n    var bbox = getBBox(visibleElements); // center elements around cursor\n\n    forEach(elements, function (element) {\n      if (isConnection(element)) {\n        element.waypoints = map(element.waypoints, function (waypoint) {\n          return {\n            x: waypoint.x - bbox.x - bbox.width / 2,\n            y: waypoint.y - bbox.y - bbox.height / 2\n          };\n        });\n      }\n\n      assign(element, {\n        x: element.x - bbox.x - bbox.width / 2,\n        y: element.y - bbox.y - bbox.height / 2\n      });\n    });\n    dragging.init(event, PREFIX, {\n      cursor: 'grabbing',\n      autoActivate: true,\n      data: {\n        shape: shape,\n        elements: elements,\n        context: context\n      }\n    });\n  };\n}\nCreate.$inject = ['canvas', 'dragging', 'eventBus', 'modeling', 'rules']; // helpers //////////\n\nfunction ensureConstraints(event) {\n  var context = event.context,\n      createConstraints = context.createConstraints;\n\n  if (!createConstraints) {\n    return;\n  }\n\n  if (createConstraints.left) {\n    event.x = Math.max(event.x, createConstraints.left);\n  }\n\n  if (createConstraints.right) {\n    event.x = Math.min(event.x, createConstraints.right);\n  }\n\n  if (createConstraints.top) {\n    event.y = Math.max(event.y, createConstraints.top);\n  }\n\n  if (createConstraints.bottom) {\n    event.y = Math.min(event.y, createConstraints.bottom);\n  }\n}\n\nfunction isConnection(element) {\n  return !!element.waypoints;\n}\n\nfunction isSingleShape(elements) {\n  return elements && elements.length === 1 && !isConnection(elements[0]);\n}\n\nfunction isLabel(element) {\n  return !!element.labelTarget;\n}","map":{"version":3,"names":["MARKER_OK","MARKER_NOT_OK","MARKER_ATTACH","MARKER_NEW_PARENT","assign","filter","find","forEach","isArray","isNumber","map","getBBox","PREFIX","HIGH_PRIORITY","Create","canvas","dragging","eventBus","modeling","rules","canCreate","elements","target","position","source","hints","element","labelTarget","parent","isLabel","indexOf","shape","isConnection","attach","connect","create","isSingleShape","allowed","connectionTarget","targetParent","targetAttach","setMarker","marker","m","addMarker","removeMarker","on","event","context","hover","canExecute","ensureConstraints","x","y","appendShape","connection","createElements","cancel","prefix","once","off","start","visibleElements","hidden","bbox","waypoints","waypoint","width","height","init","cursor","autoActivate","data","$inject","createConstraints","left","Math","max","right","min","top","bottom","length"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/create/Create.js"],"sourcesContent":["var MARKER_OK = 'drop-ok',\n    MARKER_NOT_OK = 'drop-not-ok',\n    MARKER_ATTACH = 'attach-ok',\n    MARKER_NEW_PARENT = 'new-parent';\n\nimport {\n  assign,\n  filter,\n  find,\n  forEach,\n  isArray,\n  isNumber,\n  map\n} from 'min-dash';\n\nimport { getBBox } from '../../util/Elements';\n\nvar PREFIX = 'create';\n\nvar HIGH_PRIORITY = 2000;\n\n\n/**\n * Create new elements through drag and drop.\n *\n * @param {Canvas} canvas\n * @param {Dragging} dragging\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function Create(\n    canvas,\n    dragging,\n    eventBus,\n    modeling,\n    rules\n) {\n\n  // rules //////////\n\n  /**\n   * Check wether elements can be created.\n   *\n   * @param {Array<djs.model.Base>} elements\n   * @param {djs.model.Base} target\n   * @param {Point} position\n   * @param {djs.model.Base} [source]\n   *\n   * @returns {boolean|null|Object}\n   */\n  function canCreate(elements, target, position, source, hints) {\n    if (!target) {\n      return false;\n    }\n\n    // ignore child elements and external labels\n    elements = filter(elements, function(element) {\n      var labelTarget = element.labelTarget;\n\n      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);\n    });\n\n    var shape = find(elements, function(element) {\n      return !isConnection(element);\n    });\n\n    var attach = false,\n        connect = false,\n        create = false;\n\n    // (1) attaching single shapes\n    if (isSingleShape(elements)) {\n      attach = rules.allowed('shape.attach', {\n        position: position,\n        shape: shape,\n        target: target\n      });\n    }\n\n    if (!attach) {\n\n      // (2) creating elements\n      if (isSingleShape(elements)) {\n        create = rules.allowed('shape.create', {\n          position: position,\n          shape: shape,\n          source: source,\n          target: target\n        });\n      } else {\n        create = rules.allowed('elements.create', {\n          elements: elements,\n          position: position,\n          target: target\n        });\n      }\n\n    }\n\n    var connectionTarget = hints.connectionTarget;\n\n    // (3) appending single shapes\n    if (create || attach) {\n      if (shape && source) {\n        connect = rules.allowed('connection.create', {\n          source: connectionTarget === source ? shape : source,\n          target: connectionTarget === source ? source : shape,\n          hints: {\n            targetParent: target,\n            targetAttach: attach\n          }\n        });\n      }\n\n      return {\n        attach: attach,\n        connect: connect\n      };\n    }\n\n    // ignore wether or not elements can be created\n    if (create === null || attach === null) {\n      return null;\n    }\n\n    return false;\n  }\n\n  function setMarker(element, marker) {\n    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {\n\n      if (m === marker) {\n        canvas.addMarker(element, m);\n      } else {\n        canvas.removeMarker(element, m);\n      }\n    });\n  }\n\n  // event handling //////////\n\n  eventBus.on([ 'create.move', 'create.hover' ], function(event) {\n    var context = event.context,\n        elements = context.elements,\n        hover = event.hover,\n        source = context.source,\n        hints = context.hints || {};\n\n    if (!hover) {\n      context.canExecute = false;\n      context.target = null;\n\n      return;\n    }\n\n    ensureConstraints(event);\n\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n\n    var canExecute = context.canExecute = hover && canCreate(elements, hover, position, source, hints);\n\n    if (hover && canExecute !== null) {\n      context.target = hover;\n\n      if (canExecute && canExecute.attach) {\n        setMarker(hover, MARKER_ATTACH);\n      } else {\n        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);\n      }\n    }\n  });\n\n  eventBus.on([ 'create.end', 'create.out', 'create.cleanup' ], function(event) {\n    var hover = event.hover;\n\n    if (hover) {\n      setMarker(hover, null);\n    }\n  });\n\n  eventBus.on('create.end', function(event) {\n    var context = event.context,\n        source = context.source,\n        shape = context.shape,\n        elements = context.elements,\n        target = context.target,\n        canExecute = context.canExecute,\n        attach = canExecute && canExecute.attach,\n        connect = canExecute && canExecute.connect,\n        hints = context.hints || {};\n\n    if (canExecute === false || !target) {\n      return false;\n    }\n\n    ensureConstraints(event);\n\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n\n    if (connect) {\n      shape = modeling.appendShape(source, shape, position, target, {\n        attach: attach,\n        connection: connect === true ? {} : connect,\n        connectionTarget: hints.connectionTarget\n      });\n    } else {\n      elements = modeling.createElements(elements, position, target, assign({}, hints, {\n        attach: attach\n      }));\n\n      // update shape\n      shape = find(elements, function(element) {\n        return !isConnection(element);\n      });\n    }\n\n    // update elements and shape\n    assign(context, {\n      elements: elements,\n      shape: shape\n    });\n\n    assign(event, {\n      elements: elements,\n      shape: shape\n    });\n  });\n\n  function cancel() {\n    var context = dragging.context();\n\n    if (context && context.prefix === PREFIX) {\n      dragging.cancel();\n    }\n  }\n\n  // cancel on <elements.changed> that is not result of <drag.end>\n  eventBus.on('create.init', function() {\n    eventBus.on('elements.changed', cancel);\n\n    eventBus.once([ 'create.cancel', 'create.end' ], HIGH_PRIORITY, function() {\n      eventBus.off('elements.changed', cancel);\n    });\n  });\n\n  // API //////////\n\n  this.start = function(event, elements, context) {\n    if (!isArray(elements)) {\n      elements = [ elements ];\n    }\n\n    var shape = find(elements, function(element) {\n      return !isConnection(element);\n    });\n\n    if (!shape) {\n\n      // at least one shape is required\n      return;\n    }\n\n    context = assign({\n      elements: elements,\n      hints: {},\n      shape: shape\n    }, context || {});\n\n    // make sure each element has x and y\n    forEach(elements, function(element) {\n      if (!isNumber(element.x)) {\n        element.x = 0;\n      }\n\n      if (!isNumber(element.y)) {\n        element.y = 0;\n      }\n    });\n\n    var visibleElements = filter(elements, function(element) {\n      return !element.hidden;\n    });\n\n    var bbox = getBBox(visibleElements);\n\n    // center elements around cursor\n    forEach(elements, function(element) {\n      if (isConnection(element)) {\n        element.waypoints = map(element.waypoints, function(waypoint) {\n          return {\n            x: waypoint.x - bbox.x - bbox.width / 2,\n            y: waypoint.y - bbox.y - bbox.height / 2\n          };\n        });\n      }\n\n      assign(element, {\n        x: element.x - bbox.x - bbox.width / 2,\n        y: element.y - bbox.y - bbox.height / 2\n      });\n    });\n\n    dragging.init(event, PREFIX, {\n      cursor: 'grabbing',\n      autoActivate: true,\n      data: {\n        shape: shape,\n        elements: elements,\n        context: context\n      }\n    });\n  };\n}\n\nCreate.$inject = [\n  'canvas',\n  'dragging',\n  'eventBus',\n  'modeling',\n  'rules'\n];\n\n// helpers //////////\n\nfunction ensureConstraints(event) {\n  var context = event.context,\n      createConstraints = context.createConstraints;\n\n  if (!createConstraints) {\n    return;\n  }\n\n  if (createConstraints.left) {\n    event.x = Math.max(event.x, createConstraints.left);\n  }\n\n  if (createConstraints.right) {\n    event.x = Math.min(event.x, createConstraints.right);\n  }\n\n  if (createConstraints.top) {\n    event.y = Math.max(event.y, createConstraints.top);\n  }\n\n  if (createConstraints.bottom) {\n    event.y = Math.min(event.y, createConstraints.bottom);\n  }\n}\n\nfunction isConnection(element) {\n  return !!element.waypoints;\n}\n\nfunction isSingleShape(elements) {\n  return elements && elements.length === 1 && !isConnection(elements[0]);\n}\n\nfunction isLabel(element) {\n  return !!element.labelTarget;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}