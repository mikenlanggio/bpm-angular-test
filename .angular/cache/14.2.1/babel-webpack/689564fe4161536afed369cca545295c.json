{"ast":null,"code":"import inherits from 'inherits-browser';\nimport { assign } from 'min-dash';\nimport BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';\nimport { repairConnection, withoutRedundantPoints } from 'diagram-js/lib/layout/ManhattanLayout';\nimport { getMid, getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { isExpanded } from '../../util/DiUtil';\nimport { is } from '../../util/ModelUtil';\nvar ATTACH_ORIENTATION_PADDING = -10,\n    BOUNDARY_TO_HOST_THRESHOLD = 40;\nvar oppositeOrientationMapping = {\n  'top': 'bottom',\n  'top-right': 'bottom-left',\n  'top-left': 'bottom-right',\n  'right': 'left',\n  'bottom': 'top',\n  'bottom-right': 'top-left',\n  'bottom-left': 'top-right',\n  'left': 'right'\n};\nvar orientationDirectionMapping = {\n  top: 't',\n  right: 'r',\n  bottom: 'b',\n  left: 'l'\n};\nexport default function BpmnLayouter() {}\ninherits(BpmnLayouter, BaseLayouter);\n\nBpmnLayouter.prototype.layoutConnection = function (connection, hints) {\n  if (!hints) {\n    hints = {};\n  }\n\n  var source = hints.source || connection.source,\n      target = hints.target || connection.target,\n      waypoints = hints.waypoints || connection.waypoints,\n      connectionStart = hints.connectionStart,\n      connectionEnd = hints.connectionEnd;\n  var manhattanOptions, updatedWaypoints;\n\n  if (!connectionStart) {\n    connectionStart = getConnectionDocking(waypoints && waypoints[0], source);\n  }\n\n  if (!connectionEnd) {\n    connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\n  } // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n\n  if (is(connection, 'bpmn:Association') || is(connection, 'bpmn:DataAssociation')) {\n    if (waypoints && !isCompensationAssociation(source, target)) {\n      return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);\n    }\n  }\n\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target);\n  } else if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(source, target)) {\n    // layout all connection between flow elements h:h, except for\n    // (1) outgoing of boundary events -> layout based on attach orientation and target orientation\n    // (2) incoming/outgoing of gateways -> v:h for outgoing, h:v for incoming\n    // (3) loops\n    if (source === target) {\n      manhattanOptions = {\n        preferredLayouts: getLoopPreferredLayout(source, connection)\n      };\n    } else if (is(source, 'bpmn:BoundaryEvent')) {\n      manhattanOptions = {\n        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd)\n      };\n    } else if (isExpandedSubProcess(source) || isExpandedSubProcess(target)) {\n      manhattanOptions = getSubProcessManhattanOptions(source);\n    } else if (is(source, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: ['v:h']\n      };\n    } else if (is(target, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: ['h:v']\n      };\n    } else {\n      manhattanOptions = {\n        preferredLayouts: ['h:h']\n      };\n    }\n  }\n\n  if (manhattanOptions) {\n    manhattanOptions = assign(manhattanOptions, hints);\n    updatedWaypoints = withoutRedundantPoints(repairConnection(source, target, connectionStart, connectionEnd, waypoints, manhattanOptions));\n  }\n\n  return updatedWaypoints || [connectionStart, connectionEnd];\n}; // helpers //////////\n\n\nfunction getAttachOrientation(attachedElement) {\n  var hostElement = attachedElement.host;\n  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);\n}\n\nfunction getMessageFlowManhattanOptions(source, target) {\n  return {\n    preferredLayouts: ['straight', 'v:v'],\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}\n\nfunction getMessageFlowPreserveDocking(source, target) {\n  // (1) docking element connected to participant has precedence\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  } // (2) docking element connected to expanded sub-process has precedence\n\n\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  } // (3) docking event has precedence\n\n\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n\n  return null;\n}\n\nfunction getSubProcessManhattanOptions(source) {\n  return {\n    preferredLayouts: ['straight', 'h:h'],\n    preserveDocking: getSubProcessPreserveDocking(source)\n  };\n}\n\nfunction getSubProcessPreserveDocking(source) {\n  return isExpandedSubProcess(source) ? 'target' : 'source';\n}\n\nfunction getConnectionDocking(point, shape) {\n  return point ? point.original || point : getMid(shape);\n}\n\nfunction isCompensationAssociation(source, target) {\n  return is(target, 'bpmn:Activity') && is(source, 'bpmn:BoundaryEvent') && target.businessObject.isForCompensation;\n}\n\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}\n\nfunction getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n  return matches && matches[0];\n}\n\nfunction getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n  return matches && matches[0];\n}\n\nfunction isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}\n\nfunction isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}\n\nfunction isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}\n\nfunction isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}\n\nfunction getLoopPreferredLayout(source, connection) {\n  var waypoints = connection.waypoints;\n  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);\n\n  if (orientation === 'top') {\n    return ['t:r'];\n  } else if (orientation === 'right') {\n    return ['r:b'];\n  } else if (orientation === 'left') {\n    return ['l:t'];\n  }\n\n  return ['b:l'];\n}\n\nfunction getBoundaryEventPreferredLayouts(source, target, end) {\n  var sourceMid = getMid(source),\n      targetMid = getMid(target),\n      attachOrientation = getAttachOrientation(source),\n      sourceLayout,\n      targetLayout;\n  var isLoop = isSame(source.host, target);\n  var attachedToSide = isAnyOrientation(attachOrientation, ['top', 'right', 'bottom', 'left']);\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  });\n\n  if (isLoop) {\n    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end);\n  } // source layout\n\n\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide); // target layout\n\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide);\n  return [sourceLayout + ':' + targetLayout];\n}\n\nfunction getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end) {\n  var orientation = attachedToSide ? attachOrientation : getVerticalOrientation(attachOrientation),\n      sourceLayout = orientationDirectionMapping[orientation],\n      targetLayout;\n\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      targetLayout = shouldConnectToSameSide('y', source, target, end) ? 'h' : 'b';\n    } else {\n      targetLayout = shouldConnectToSameSide('x', source, target, end) ? 'v' : 'l';\n    }\n  } else {\n    targetLayout = 'v';\n  }\n\n  return [sourceLayout + ':' + targetLayout];\n}\n\nfunction shouldConnectToSameSide(axis, source, target, end) {\n  var threshold = BOUNDARY_TO_HOST_THRESHOLD;\n  return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {\n    x: target.x + target.width,\n    y: target.y + target.height\n  }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));\n}\n\nfunction areCloseOnAxis(axis, a, b, threshold) {\n  return Math.abs(a[axis] - b[axis]) < threshold;\n}\n\nfunction getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[attachOrientation];\n  } // attached to either top-right, top-left, bottom-right or bottom-left corner\n  // same vertical or opposite horizontal orientation\n\n\n  if (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) || isOppositeOrientation(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {\n    return orientationDirectionMapping[getVerticalOrientation(attachOrientation)];\n  } // fallback\n\n\n  return orientationDirectionMapping[getHorizontalOrientation(attachOrientation)];\n}\n\nfunction getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      // orientation is right or left\n      // opposite horizontal orientation or same orientation\n      if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'h';\n      } // fallback\n\n\n      return 'v';\n    } else {\n      // orientation is top or bottom\n      // opposite vertical orientation or same orientation\n      if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'v';\n      } // fallback\n\n\n      return 'h';\n    }\n  } // attached to either top-right, top-left, bottom-right or bottom-left corner\n  // orientation is right, left\n  // or same vertical orientation but also right or left\n\n\n  if (isHorizontalOrientation(targetOrientation) || isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) && getHorizontalOrientation(targetOrientation)) {\n    return 'h';\n  } else {\n    return 'v';\n  }\n}","map":{"version":3,"names":["inherits","assign","BaseLayouter","repairConnection","withoutRedundantPoints","getMid","getOrientation","isExpanded","is","ATTACH_ORIENTATION_PADDING","BOUNDARY_TO_HOST_THRESHOLD","oppositeOrientationMapping","orientationDirectionMapping","top","right","bottom","left","BpmnLayouter","prototype","layoutConnection","connection","hints","source","target","waypoints","connectionStart","connectionEnd","manhattanOptions","updatedWaypoints","getConnectionDocking","length","isCompensationAssociation","concat","slice","getMessageFlowManhattanOptions","preferredLayouts","getLoopPreferredLayout","getBoundaryEventPreferredLayouts","isExpandedSubProcess","getSubProcessManhattanOptions","getAttachOrientation","attachedElement","hostElement","host","preserveDocking","getMessageFlowPreserveDocking","getSubProcessPreserveDocking","point","shape","original","businessObject","isForCompensation","element","isSame","a","b","isAnyOrientation","orientation","orientations","indexOf","getHorizontalOrientation","matches","exec","getVerticalOrientation","isOppositeOrientation","isOppositeHorizontalOrientation","horizontalOrientation","oppositeHorizontalOrientation","isOppositeVerticalOrientation","verticalOrientation","oppositeVerticalOrientation","isHorizontalOrientation","end","sourceMid","targetMid","attachOrientation","sourceLayout","targetLayout","isLoop","attachedToSide","targetOrientation","x","width","y","height","getBoundaryEventLoopLayout","getBoundaryEventSourceLayout","getBoundaryEventTargetLayout","shouldConnectToSameSide","axis","threshold","areCloseOnAxis","Math","abs"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport {\n  assign\n} from 'min-dash';\n\nimport BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';\n\nimport {\n  repairConnection,\n  withoutRedundantPoints\n} from 'diagram-js/lib/layout/ManhattanLayout';\n\nimport {\n  getMid,\n  getOrientation\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  isExpanded\n} from '../../util/DiUtil';\n\nimport { is } from '../../util/ModelUtil';\n\nvar ATTACH_ORIENTATION_PADDING = -10,\n    BOUNDARY_TO_HOST_THRESHOLD = 40;\n\nvar oppositeOrientationMapping = {\n  'top': 'bottom',\n  'top-right': 'bottom-left',\n  'top-left': 'bottom-right',\n  'right': 'left',\n  'bottom': 'top',\n  'bottom-right': 'top-left',\n  'bottom-left': 'top-right',\n  'left': 'right'\n};\n\nvar orientationDirectionMapping = {\n  top: 't',\n  right: 'r',\n  bottom: 'b',\n  left: 'l'\n};\n\n\nexport default function BpmnLayouter() {}\n\ninherits(BpmnLayouter, BaseLayouter);\n\n\nBpmnLayouter.prototype.layoutConnection = function(connection, hints) {\n  if (!hints) {\n    hints = {};\n  }\n\n  var source = hints.source || connection.source,\n      target = hints.target || connection.target,\n      waypoints = hints.waypoints || connection.waypoints,\n      connectionStart = hints.connectionStart,\n      connectionEnd = hints.connectionEnd;\n\n  var manhattanOptions,\n      updatedWaypoints;\n\n  if (!connectionStart) {\n    connectionStart = getConnectionDocking(waypoints && waypoints[ 0 ], source);\n  }\n\n  if (!connectionEnd) {\n    connectionEnd = getConnectionDocking(waypoints && waypoints[ waypoints.length - 1 ], target);\n  }\n\n  // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n  if (is(connection, 'bpmn:Association') ||\n      is(connection, 'bpmn:DataAssociation')) {\n\n    if (waypoints && !isCompensationAssociation(source, target)) {\n      return [].concat([ connectionStart ], waypoints.slice(1, -1), [ connectionEnd ]);\n    }\n  }\n\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target);\n  } else if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(source, target)) {\n\n    // layout all connection between flow elements h:h, except for\n    // (1) outgoing of boundary events -> layout based on attach orientation and target orientation\n    // (2) incoming/outgoing of gateways -> v:h for outgoing, h:v for incoming\n    // (3) loops\n    if (source === target) {\n      manhattanOptions = {\n        preferredLayouts: getLoopPreferredLayout(source, connection)\n      };\n    } else if (is(source, 'bpmn:BoundaryEvent')) {\n      manhattanOptions = {\n        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd)\n      };\n    } else if (isExpandedSubProcess(source) || isExpandedSubProcess(target)) {\n      manhattanOptions = getSubProcessManhattanOptions(source);\n    } else if (is(source, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'v:h' ]\n      };\n    } else if (is(target, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'h:v' ]\n      };\n    } else {\n      manhattanOptions = {\n        preferredLayouts: [ 'h:h' ]\n      };\n    }\n  }\n\n  if (manhattanOptions) {\n    manhattanOptions = assign(manhattanOptions, hints);\n\n    updatedWaypoints = withoutRedundantPoints(repairConnection(\n      source,\n      target,\n      connectionStart,\n      connectionEnd,\n      waypoints,\n      manhattanOptions\n    ));\n  }\n\n  return updatedWaypoints || [ connectionStart, connectionEnd ];\n};\n\n\n// helpers //////////\n\nfunction getAttachOrientation(attachedElement) {\n  var hostElement = attachedElement.host;\n\n  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);\n}\n\nfunction getMessageFlowManhattanOptions(source, target) {\n  return {\n    preferredLayouts: [ 'straight', 'v:v' ],\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}\n\nfunction getMessageFlowPreserveDocking(source, target) {\n\n  // (1) docking element connected to participant has precedence\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  }\n\n  // (2) docking element connected to expanded sub-process has precedence\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  }\n\n  // (3) docking event has precedence\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n\n  return null;\n}\n\nfunction getSubProcessManhattanOptions(source) {\n  return {\n    preferredLayouts: [ 'straight', 'h:h' ],\n    preserveDocking: getSubProcessPreserveDocking(source)\n  };\n}\n\nfunction getSubProcessPreserveDocking(source) {\n  return isExpandedSubProcess(source) ? 'target' : 'source';\n}\n\nfunction getConnectionDocking(point, shape) {\n  return point ? (point.original || point) : getMid(shape);\n}\n\nfunction isCompensationAssociation(source, target) {\n  return is(target, 'bpmn:Activity') &&\n    is(source, 'bpmn:BoundaryEvent') &&\n    target.businessObject.isForCompensation;\n}\n\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}\n\nfunction getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n\n  return matches && matches[0];\n}\n\nfunction getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n\n  return matches && matches[0];\n}\n\nfunction isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}\n\nfunction isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}\n\nfunction isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}\n\nfunction isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}\n\nfunction getLoopPreferredLayout(source, connection) {\n  var waypoints = connection.waypoints;\n\n  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);\n\n  if (orientation === 'top') {\n    return [ 't:r' ];\n  } else if (orientation === 'right') {\n    return [ 'r:b' ];\n  } else if (orientation === 'left') {\n    return [ 'l:t' ];\n  }\n\n  return [ 'b:l' ];\n}\n\nfunction getBoundaryEventPreferredLayouts(source, target, end) {\n  var sourceMid = getMid(source),\n      targetMid = getMid(target),\n      attachOrientation = getAttachOrientation(source),\n      sourceLayout,\n      targetLayout;\n\n  var isLoop = isSame(source.host, target);\n\n  var attachedToSide = isAnyOrientation(attachOrientation, [ 'top', 'right', 'bottom', 'left' ]);\n\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  });\n\n  if (isLoop) {\n    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end);\n  }\n\n  // source layout\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide);\n\n  // target layout\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide);\n\n  return [ sourceLayout + ':' + targetLayout ];\n}\n\nfunction getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end) {\n  var orientation = attachedToSide ? attachOrientation : getVerticalOrientation(attachOrientation),\n      sourceLayout = orientationDirectionMapping[ orientation ],\n      targetLayout;\n\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      targetLayout = shouldConnectToSameSide('y', source, target, end) ? 'h' : 'b';\n    } else {\n      targetLayout = shouldConnectToSameSide('x', source, target, end) ? 'v' : 'l';\n    }\n  } else {\n    targetLayout = 'v';\n  }\n\n  return [ sourceLayout + ':' + targetLayout ];\n}\n\nfunction shouldConnectToSameSide(axis, source, target, end) {\n  var threshold = BOUNDARY_TO_HOST_THRESHOLD;\n\n  return !(\n    areCloseOnAxis(axis, end, target, threshold) ||\n    areCloseOnAxis(axis, end, {\n      x: target.x + target.width,\n      y: target.y + target.height\n    }, threshold) ||\n    areCloseOnAxis(axis, end, getMid(source), threshold)\n  );\n}\n\nfunction areCloseOnAxis(axis, a, b, threshold) {\n  return Math.abs(a[ axis ] - b[ axis ]) < threshold;\n}\n\nfunction getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[ attachOrientation ];\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // same vertical or opposite horizontal orientation\n  if (isSame(\n    getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)\n  ) || isOppositeOrientation(\n    getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation)\n  )) {\n    return orientationDirectionMapping[ getVerticalOrientation(attachOrientation) ];\n  }\n\n  // fallback\n  return orientationDirectionMapping[ getHorizontalOrientation(attachOrientation) ];\n}\n\nfunction getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n\n      // orientation is right or left\n\n      // opposite horizontal orientation or same orientation\n      if (\n        isOppositeHorizontalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'h';\n      }\n\n      // fallback\n      return 'v';\n    } else {\n\n      // orientation is top or bottom\n\n      // opposite vertical orientation or same orientation\n      if (\n        isOppositeVerticalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'v';\n      }\n\n      // fallback\n      return 'h';\n    }\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // orientation is right, left\n  // or same vertical orientation but also right or left\n  if (isHorizontalOrientation(targetOrientation) ||\n    (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) &&\n      getHorizontalOrientation(targetOrientation))) {\n    return 'h';\n  } else {\n    return 'v';\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}