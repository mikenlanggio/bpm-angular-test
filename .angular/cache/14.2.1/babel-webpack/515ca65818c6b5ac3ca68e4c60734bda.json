{"ast":null,"code":"import inherits from 'inherits-browser';\nimport { getOrientation, getMid, asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nimport { substract } from 'diagram-js/lib/util/Math';\nimport { hasExternalLabel } from '../../../util/LabelUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nvar ALIGNMENTS = ['top', 'bottom', 'left', 'right'];\nvar ELEMENT_LABEL_DISTANCE = 10;\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\n\nexport default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  this.postExecuted(['connection.create', 'connection.layout', 'connection.updateWaypoints'], function (event) {\n    var context = event.context,\n        connection = context.connection,\n        source = connection.source,\n        target = connection.target,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(source);\n      checkLabelAdjustment(target);\n    }\n  });\n  this.postExecuted(['label.create'], function (event) {\n    var context = event.context,\n        shape = context.shape,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(shape.labelTarget);\n    }\n  });\n  this.postExecuted(['elements.create'], function (event) {\n    var context = event.context,\n        elements = context.elements,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      elements.forEach(function (element) {\n        checkLabelAdjustment(element);\n      });\n    }\n  });\n\n  function checkLabelAdjustment(element) {\n    // skip non-existing labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n\n    var optimalPosition = getOptimalPosition(element); // no optimal position found\n\n    if (!optimalPosition) {\n      return;\n    }\n\n    adjustLabelPosition(element, optimalPosition);\n  }\n\n  function adjustLabelPosition(element, orientation) {\n    var elementMid = getMid(element),\n        label = element.label,\n        labelMid = getMid(label); // ignore labels that are being created\n\n    if (!label.parent) {\n      return;\n    }\n\n    var elementTrbl = asTRBL(element);\n    var newLabelMid;\n\n    switch (orientation) {\n      case 'top':\n        newLabelMid = {\n          x: elementMid.x,\n          y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2\n        };\n        break;\n\n      case 'left':\n        newLabelMid = {\n          x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,\n          y: elementMid.y\n        };\n        break;\n\n      case 'bottom':\n        newLabelMid = {\n          x: elementMid.x,\n          y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2\n        };\n        break;\n\n      case 'right':\n        newLabelMid = {\n          x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,\n          y: elementMid.y\n        };\n        break;\n    }\n\n    var delta = substract(newLabelMid, labelMid);\n    modeling.moveShape(label, delta);\n  }\n}\ninherits(AdaptiveLabelPositioningBehavior, CommandInterceptor);\nAdaptiveLabelPositioningBehavior.$inject = ['eventBus', 'modeling']; // helpers //////////////////////\n\n/**\n * Return alignments which are taken by a boundary's host element\n *\n * @param {Shape} element\n *\n * @return {Array<string>}\n */\n\nfunction getTakenHostAlignments(element) {\n  var hostElement = element.host,\n      elementMid = getMid(element),\n      hostOrientation = getOrientation(elementMid, hostElement);\n  var freeAlignments; // check whether there is a multi-orientation, e.g. 'top-left'\n\n  if (hostOrientation.indexOf('-') >= 0) {\n    freeAlignments = hostOrientation.split('-');\n  } else {\n    freeAlignments = [hostOrientation];\n  }\n\n  var takenAlignments = ALIGNMENTS.filter(function (alignment) {\n    return freeAlignments.indexOf(alignment) === -1;\n  });\n  return takenAlignments;\n}\n/**\n * Return alignments which are taken by related connections\n *\n * @param {Shape} element\n *\n * @return {Array<string>}\n */\n\n\nfunction getTakenConnectionAlignments(element) {\n  var elementMid = getMid(element);\n  var takenAlignments = [].concat(element.incoming.map(function (c) {\n    return c.waypoints[c.waypoints.length - 2];\n  }), element.outgoing.map(function (c) {\n    return c.waypoints[1];\n  })).map(function (point) {\n    return getApproximateOrientation(elementMid, point);\n  });\n  return takenAlignments;\n}\n/**\n * Return the optimal label position around an element\n * or _undefined_, if none was found.\n *\n * @param  {Shape} element\n *\n * @return {string} positioning identifier\n */\n\n\nfunction getOptimalPosition(element) {\n  var labelMid = getMid(element.label);\n  var elementMid = getMid(element);\n  var labelOrientation = getApproximateOrientation(elementMid, labelMid);\n\n  if (!isAligned(labelOrientation)) {\n    return;\n  }\n\n  var takenAlignments = getTakenConnectionAlignments(element);\n\n  if (element.host) {\n    var takenHostAlignments = getTakenHostAlignments(element);\n    takenAlignments = takenAlignments.concat(takenHostAlignments);\n  }\n\n  var freeAlignments = ALIGNMENTS.filter(function (alignment) {\n    return takenAlignments.indexOf(alignment) === -1;\n  }); // NOTHING TO DO; label already aligned a.O.K.\n\n  if (freeAlignments.indexOf(labelOrientation) !== -1) {\n    return;\n  }\n\n  return freeAlignments[0];\n}\n\nfunction getApproximateOrientation(p0, p1) {\n  return getOrientation(p1, p0, 5);\n}\n\nfunction isAligned(orientation) {\n  return ALIGNMENTS.indexOf(orientation) !== -1;\n}","map":{"version":3,"names":["inherits","getOrientation","getMid","asTRBL","substract","hasExternalLabel","CommandInterceptor","ALIGNMENTS","ELEMENT_LABEL_DISTANCE","AdaptiveLabelPositioningBehavior","eventBus","modeling","call","postExecuted","event","context","connection","source","target","hints","createElementsBehavior","checkLabelAdjustment","shape","labelTarget","elements","forEach","element","optimalPosition","getOptimalPosition","adjustLabelPosition","orientation","elementMid","label","labelMid","parent","elementTrbl","newLabelMid","x","y","top","height","left","width","bottom","right","delta","moveShape","$inject","getTakenHostAlignments","hostElement","host","hostOrientation","freeAlignments","indexOf","split","takenAlignments","filter","alignment","getTakenConnectionAlignments","concat","incoming","map","c","waypoints","length","outgoing","point","getApproximateOrientation","labelOrientation","isAligned","takenHostAlignments","p0","p1"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport {\n  getOrientation,\n  getMid,\n  asTRBL\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  substract\n} from 'diagram-js/lib/util/Math';\n\nimport {\n  hasExternalLabel\n} from '../../../util/LabelUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nvar ALIGNMENTS = [\n  'top',\n  'bottom',\n  'left',\n  'right'\n];\n\nvar ELEMENT_LABEL_DISTANCE = 10;\n\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\nexport default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.postExecuted([\n    'connection.create',\n    'connection.layout',\n    'connection.updateWaypoints'\n  ], function(event) {\n    var context = event.context,\n        connection = context.connection,\n        source = connection.source,\n        target = connection.target,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(source);\n      checkLabelAdjustment(target);\n    }\n  });\n\n\n  this.postExecuted([\n    'label.create'\n  ], function(event) {\n    var context = event.context,\n        shape = context.shape,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(shape.labelTarget);\n    }\n  });\n\n\n  this.postExecuted([\n    'elements.create'\n  ], function(event) {\n    var context = event.context,\n        elements = context.elements,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      elements.forEach(function(element) {\n        checkLabelAdjustment(element);\n      });\n    }\n  });\n\n  function checkLabelAdjustment(element) {\n\n    // skip non-existing labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n\n    var optimalPosition = getOptimalPosition(element);\n\n    // no optimal position found\n    if (!optimalPosition) {\n      return;\n    }\n\n    adjustLabelPosition(element, optimalPosition);\n  }\n\n  function adjustLabelPosition(element, orientation) {\n\n    var elementMid = getMid(element),\n        label = element.label,\n        labelMid = getMid(label);\n\n    // ignore labels that are being created\n    if (!label.parent) {\n      return;\n    }\n\n    var elementTrbl = asTRBL(element);\n\n    var newLabelMid;\n\n    switch (orientation) {\n    case 'top':\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2\n      };\n\n      break;\n\n    case 'left':\n\n      newLabelMid = {\n        x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n\n    case 'bottom':\n\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2\n      };\n\n      break;\n\n    case 'right':\n\n      newLabelMid = {\n        x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n    }\n\n    var delta = substract(newLabelMid, labelMid);\n\n    modeling.moveShape(label, delta);\n  }\n\n}\n\ninherits(AdaptiveLabelPositioningBehavior, CommandInterceptor);\n\nAdaptiveLabelPositioningBehavior.$inject = [\n  'eventBus',\n  'modeling'\n];\n\n\n// helpers //////////////////////\n\n/**\n * Return alignments which are taken by a boundary's host element\n *\n * @param {Shape} element\n *\n * @return {Array<string>}\n */\nfunction getTakenHostAlignments(element) {\n\n  var hostElement = element.host,\n      elementMid = getMid(element),\n      hostOrientation = getOrientation(elementMid, hostElement);\n\n  var freeAlignments;\n\n  // check whether there is a multi-orientation, e.g. 'top-left'\n  if (hostOrientation.indexOf('-') >= 0) {\n    freeAlignments = hostOrientation.split('-');\n  } else {\n    freeAlignments = [ hostOrientation ];\n  }\n\n  var takenAlignments = ALIGNMENTS.filter(function(alignment) {\n\n    return freeAlignments.indexOf(alignment) === -1;\n  });\n\n  return takenAlignments;\n\n}\n\n/**\n * Return alignments which are taken by related connections\n *\n * @param {Shape} element\n *\n * @return {Array<string>}\n */\nfunction getTakenConnectionAlignments(element) {\n\n  var elementMid = getMid(element);\n\n  var takenAlignments = [].concat(\n    element.incoming.map(function(c) {\n      return c.waypoints[c.waypoints.length - 2 ];\n    }),\n    element.outgoing.map(function(c) {\n      return c.waypoints[1];\n    })\n  ).map(function(point) {\n    return getApproximateOrientation(elementMid, point);\n  });\n\n  return takenAlignments;\n}\n\n/**\n * Return the optimal label position around an element\n * or _undefined_, if none was found.\n *\n * @param  {Shape} element\n *\n * @return {string} positioning identifier\n */\nfunction getOptimalPosition(element) {\n\n  var labelMid = getMid(element.label);\n\n  var elementMid = getMid(element);\n\n  var labelOrientation = getApproximateOrientation(elementMid, labelMid);\n\n  if (!isAligned(labelOrientation)) {\n    return;\n  }\n\n  var takenAlignments = getTakenConnectionAlignments(element);\n\n  if (element.host) {\n    var takenHostAlignments = getTakenHostAlignments(element);\n\n    takenAlignments = takenAlignments.concat(takenHostAlignments);\n  }\n\n  var freeAlignments = ALIGNMENTS.filter(function(alignment) {\n\n    return takenAlignments.indexOf(alignment) === -1;\n  });\n\n  // NOTHING TO DO; label already aligned a.O.K.\n  if (freeAlignments.indexOf(labelOrientation) !== -1) {\n    return;\n  }\n\n  return freeAlignments[0];\n}\n\nfunction getApproximateOrientation(p0, p1) {\n  return getOrientation(p1, p0, 5);\n}\n\nfunction isAligned(orientation) {\n  return ALIGNMENTS.indexOf(orientation) !== -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}