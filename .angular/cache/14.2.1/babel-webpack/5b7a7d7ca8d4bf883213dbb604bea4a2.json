{"ast":null,"code":"import { isObject, sortBy } from 'min-dash';\nimport { pointDistance, pointsOnLine } from '../util/Geometry';\nimport intersectPaths from 'path-intersection';\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\nexport function roundPoint(point) {\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Object}\n */\n\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {Object} trbl\n *\n * @return {Bounds}\n */\n\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Point}\n */\n\nexport function getBoundsMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n}\n/**\n * Get the mid of the given Connection.\n *\n * @param {djs.Base.Connection} connection\n *\n * @return {Point}\n */\n\nexport function getConnectionMid(connection) {\n  var waypoints = connection.waypoints; // calculate total length and length of each segment\n\n  var parts = waypoints.reduce(function (parts, point, index) {\n    var lastPoint = waypoints[index - 1];\n\n    if (lastPoint) {\n      var lastPart = parts[parts.length - 1];\n      var startLength = lastPart && lastPart.endLength || 0;\n      var length = distance(lastPoint, point);\n      parts.push({\n        start: lastPoint,\n        end: point,\n        startLength: startLength,\n        endLength: startLength + length,\n        length: length\n      });\n    }\n\n    return parts;\n  }, []);\n  var totalLength = parts.reduce(function (length, part) {\n    return length + part.length;\n  }, 0); // find which segement contains middle point\n\n  var midLength = totalLength / 2;\n  var i = 0;\n  var midSegment = parts[i];\n\n  while (midSegment.endLength < midLength) {\n    midSegment = parts[++i];\n  } // calculate relative position on mid segment\n\n\n  var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;\n  var midPoint = {\n    x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,\n    y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress\n  };\n  return midPoint;\n}\n/**\n * Get the mid of the given Element.\n *\n * @param {djs.Base.Connection} connection\n *\n * @return {Point}\n */\n\nexport function getMid(element) {\n  if (isConnection(element)) {\n    return getConnectionMid(element);\n  }\n\n  return getBoundsMid(element);\n} // orientation utils //////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Bounds} rect\n * @param {Bounds} reference\n * @param {Point|number} padding\n *\n * @return {string} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\n\nexport function getOrientation(rect, reference, padding) {\n  padding = padding || 0; // make sure we can use an object, too\n  // for individual { x, y } padding\n\n  if (!isObject(padding)) {\n    padding = {\n      x: padding,\n      y: padding\n    };\n  }\n\n  var rectOrientation = asTRBL(rect),\n      referenceOrientation = asTRBL(reference);\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\n  var vertical = top ? 'top' : bottom ? 'bottom' : null,\n      horizontal = left ? 'left' : right ? 'right' : null;\n\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n} // intersection utils //////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {PathDef} elementPath\n * @param {PathDef} linePath\n * @param {boolean} cropStart crop from start or end\n *\n * @return {Point}\n */\n\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n  var intersections = getIntersections(elementPath, linePath); // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function (i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n      distance = 100 - distance;\n      distance = (distance < 10 ? '0' : '') + distance; // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n\n      return i.segment2 + '#' + distance;\n    });\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n\n  return null;\n}\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}\nexport function filterRedundantWaypoints(waypoints) {\n  // alter copy of waypoints, not original\n  waypoints = waypoints.slice();\n  var idx = 0,\n      point,\n      previousPoint,\n      nextPoint;\n\n  while (waypoints[idx]) {\n    point = waypoints[idx];\n    previousPoint = waypoints[idx - 1];\n    nextPoint = waypoints[idx + 1];\n\n    if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {\n      // remove point, if overlapping with {nextPoint}\n      // or on line with {previousPoint} -> {point} -> {nextPoint}\n      waypoints.splice(idx, 1);\n    } else {\n      idx++;\n    }\n  }\n\n  return waypoints;\n} // helpers //////////////////////\n\nfunction distance(a, b) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\n\nfunction isConnection(element) {\n  return !!element.waypoints;\n}","map":{"version":3,"names":["isObject","sortBy","pointDistance","pointsOnLine","intersectPaths","roundBounds","bounds","x","Math","round","y","width","height","roundPoint","point","asTRBL","top","right","bottom","left","asBounds","trbl","getBoundsMid","getConnectionMid","connection","waypoints","parts","reduce","index","lastPoint","lastPart","length","startLength","endLength","distance","push","start","end","totalLength","part","midLength","i","midSegment","segmentProgress","midPoint","getMid","element","isConnection","getOrientation","rect","reference","padding","rectOrientation","referenceOrientation","vertical","horizontal","getElementLineIntersection","elementPath","linePath","cropStart","intersections","getIntersections","floor","t2","segment2","a","b","filterRedundantWaypoints","slice","idx","previousPoint","nextPoint","splice","sqrt","pow"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/layout/LayoutUtil.js"],"sourcesContent":["import {\n  isObject,\n  sortBy\n} from 'min-dash';\n\nimport {\n  pointDistance,\n  pointsOnLine\n} from '../util/Geometry';\n\nimport intersectPaths from 'path-intersection';\n\n\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\n\n\nexport function roundPoint(point) {\n\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n\n\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Object}\n */\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n\n\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {Object} trbl\n *\n * @return {Bounds}\n */\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n\n\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Point}\n */\nexport function getBoundsMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n}\n\n\n/**\n * Get the mid of the given Connection.\n *\n * @param {djs.Base.Connection} connection\n *\n * @return {Point}\n */\nexport function getConnectionMid(connection) {\n  var waypoints = connection.waypoints;\n\n  // calculate total length and length of each segment\n  var parts = waypoints.reduce(function(parts, point, index) {\n\n    var lastPoint = waypoints[index - 1];\n\n    if (lastPoint) {\n      var lastPart = parts[parts.length - 1];\n\n      var startLength = lastPart && lastPart.endLength || 0;\n      var length = distance(lastPoint, point);\n\n      parts.push({\n        start: lastPoint,\n        end: point,\n        startLength: startLength,\n        endLength: startLength + length,\n        length: length\n      });\n    }\n\n    return parts;\n  }, []);\n\n  var totalLength = parts.reduce(function(length, part) {\n    return length + part.length;\n  }, 0);\n\n  // find which segement contains middle point\n  var midLength = totalLength / 2;\n\n  var i = 0;\n  var midSegment = parts[i];\n\n  while (midSegment.endLength < midLength) {\n    midSegment = parts[++i];\n  }\n\n  // calculate relative position on mid segment\n  var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;\n\n  var midPoint = {\n    x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,\n    y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress\n  };\n\n  return midPoint;\n}\n\n\n/**\n * Get the mid of the given Element.\n *\n * @param {djs.Base.Connection} connection\n *\n * @return {Point}\n */\nexport function getMid(element) {\n  if (isConnection(element)) {\n    return getConnectionMid(element);\n  }\n\n  return getBoundsMid(element);\n}\n\n// orientation utils //////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Bounds} rect\n * @param {Bounds} reference\n * @param {Point|number} padding\n *\n * @return {string} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\nexport function getOrientation(rect, reference, padding) {\n\n  padding = padding || 0;\n\n  // make sure we can use an object, too\n  // for individual { x, y } padding\n  if (!isObject(padding)) {\n    padding = { x: padding, y: padding };\n  }\n\n\n  var rectOrientation = asTRBL(rect),\n      referenceOrientation = asTRBL(reference);\n\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\n\n  var vertical = top ? 'top' : (bottom ? 'bottom' : null),\n      horizontal = left ? 'left' : (right ? 'right' : null);\n\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n}\n\n\n// intersection utils //////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {PathDef} elementPath\n * @param {PathDef} linePath\n * @param {boolean} cropStart crop from start or end\n *\n * @return {Point}\n */\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n\n  var intersections = getIntersections(elementPath, linePath);\n\n  // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function(i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n\n      distance = 100 - distance;\n\n      distance = (distance < 10 ? '0' : '') + distance;\n\n      // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n      return i.segment2 + '#' + distance;\n    });\n\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n\n  return null;\n}\n\n\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}\n\n\nexport function filterRedundantWaypoints(waypoints) {\n\n  // alter copy of waypoints, not original\n  waypoints = waypoints.slice();\n\n  var idx = 0,\n      point,\n      previousPoint,\n      nextPoint;\n\n  while (waypoints[idx]) {\n    point = waypoints[idx];\n    previousPoint = waypoints[idx - 1];\n    nextPoint = waypoints[idx + 1];\n\n    if (pointDistance(point, nextPoint) === 0 ||\n        pointsOnLine(previousPoint, nextPoint, point)) {\n\n      // remove point, if overlapping with {nextPoint}\n      // or on line with {previousPoint} -> {point} -> {nextPoint}\n      waypoints.splice(idx, 1);\n    } else {\n      idx++;\n    }\n  }\n\n  return waypoints;\n}\n\n// helpers //////////////////////\n\nfunction distance(a, b) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\n\nfunction isConnection(element) {\n  return !!element.waypoints;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}