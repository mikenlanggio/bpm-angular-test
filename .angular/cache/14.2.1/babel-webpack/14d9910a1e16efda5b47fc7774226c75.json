{"ast":null,"code":"import { assign, forEach } from 'min-dash';\nimport inherits from 'inherits-browser';\nimport { remove as collectionRemove, add as collectionAdd } from 'diagram-js/lib/util/Collections';\nimport { Label } from 'diagram-js/lib/model';\nimport { getBusinessObject, getDi, is } from '../../util/ModelUtil';\nimport { isAny } from './util/ModelingUtil';\nimport { delta } from 'diagram-js/lib/util/PositionUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML + DI\n * once changes on the diagram happen\n */\n\nexport default function BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate) {\n  CommandInterceptor.call(this, eventBus);\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n  var self = this; // connection cropping //////////////////////\n  // crop connection ends during create/update\n\n  function cropConnection(e) {\n    var context = e.context,\n        hints = context.hints || {},\n        connection;\n\n    if (!context.cropped && hints.createElementsBehavior !== false) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed(['connection.layout', 'connection.create'], cropConnection);\n  this.reverted(['connection.layout'], function (e) {\n    delete e.context.cropped;\n  }); // BPMN + DI update //////////////////////\n  // update parent\n\n  function updateParent(e) {\n    var context = e.context;\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n    var element = context.shape || context.connection,\n        // oldParent is the (old) new parent, because we are undoing\n    oldParent = context.parent || context.newParent;\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(updateParent));\n  this.reverted(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(reverseUpdateParent));\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n    forEach(children, function (child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed(['canvas.updateRoot'], updateRoot);\n  this.reverted(['canvas.updateRoot'], updateRoot); // update bounds\n\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n  this.reverted(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  })); // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n\n  eventBus.on('shape.changed', function (event) {\n    if (event.element.type === 'label') {\n      updateBounds({\n        context: {\n          shape: event.element\n        }\n      });\n    }\n  }); // attach / detach connection\n\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection));\n  this.reverted(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection)); // update waypoints\n\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints));\n  this.reverted(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints)); // update conditional/default flows\n\n  this.executed('connection.reconnect', ifBpmn(function (event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource); // remove condition from connection on reconnect to new source\n    // if new source can NOT have condional sequence flow\n\n    if (connectionBo.conditionExpression && !isAny(newSourceBo, ['bpmn:Activity', 'bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway'])) {\n      context.oldConditionExpression = connectionBo.conditionExpression;\n      delete connectionBo.conditionExpression;\n    } // remove default from old source flow on reconnect to new source\n    // if source changed\n\n\n    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {\n      context.oldDefault = oldSourceBo.default;\n      delete oldSourceBo.default;\n    }\n  }));\n  this.reverted('connection.reconnect', ifBpmn(function (event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource); // add condition to connection on revert reconnect to new source\n\n    if (context.oldConditionExpression) {\n      connectionBo.conditionExpression = context.oldConditionExpression;\n    } // add default to old source on revert reconnect to new source\n\n\n    if (context.oldDefault) {\n      oldSourceBo.default = context.oldDefault;\n      delete newSourceBo.default;\n    }\n  })); // update attachments\n\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed(['element.updateAttachment'], ifBpmn(updateAttachment));\n  this.reverted(['element.updateAttachment'], ifBpmn(updateAttachment));\n}\ninherits(BpmnUpdater, CommandInterceptor);\nBpmnUpdater.$inject = ['eventBus', 'bpmnFactory', 'connectionDocking', 'translate']; // implementation //////////////////////\n\nBpmnUpdater.prototype.updateAttachment = function (context) {\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\nBpmnUpdater.prototype.updateParent = function (element, oldParent) {\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Label) {\n    return;\n  } // data stores in collaborations are handled separately by DataStoreBehavior\n\n\n  if (is(element, 'bpmn:DataStoreReference') && element.parent && is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n\n  var parentShape = element.parent;\n  var businessObject = element.businessObject,\n      di = getDi(element),\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = getDi(parentShape);\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(di, parentDi);\n};\n\nBpmnUpdater.prototype.updateBounds = function (shape) {\n  var di = getDi(shape),\n      embeddedLabelBounds = getEmbeddedLabelBounds(shape); // update embedded label bounds if possible\n\n  if (embeddedLabelBounds) {\n    var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get('bounds'));\n    assign(embeddedLabelBounds, {\n      x: shape.x + embeddedLabelBoundsDelta.x,\n      y: shape.y + embeddedLabelBoundsDelta.y\n    });\n  }\n\n  var target = shape instanceof Label ? this._getLabel(di) : di;\n  var bounds = target.bounds;\n\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\nBpmnUpdater.prototype.updateFlowNodeRefs = function (businessObject, newContainment, oldContainment) {\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is(oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n}; // update existing sourceElement and targetElement di information\n\n\nBpmnUpdater.prototype.updateDiConnection = function (connection, newSource, newTarget) {\n  var connectionDi = getDi(connection),\n      newSourceDi = getDi(newSource),\n      newTargetDi = getDi(newTarget);\n\n  if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {\n    connectionDi.sourceElement = newSource && newSourceDi;\n  }\n\n  if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {\n    connectionDi.targetElement = newTarget && newTargetDi;\n  }\n};\n\nBpmnUpdater.prototype.updateDiParent = function (di, parentDi) {\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}\n\nBpmnUpdater.prototype.getLaneSet = function (container) {\n  var laneSet, laneSets; // bpmn:Lane\n\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  } // bpmn:Participant\n\n\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  } // bpmn:FlowElementsContainer\n\n\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};\n\nBpmnUpdater.prototype.updateSemanticParent = function (businessObject, newParent, visualParent) {\n  var containment,\n      translate = this._translate;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    } // already in correct ioSpecification\n\n\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else if (is(businessObject, 'bpmn:FlowElement')) {\n    if (newParent) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else if (is(newParent, 'bpmn:Lane')) {\n        do {\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n      }\n    }\n\n    containment = 'flowElements';\n  } else if (is(businessObject, 'bpmn:Artifact')) {\n    while (newParent && !is(newParent, 'bpmn:Process') && !is(newParent, 'bpmn:SubProcess') && !is(newParent, 'bpmn:Collaboration')) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n  } else if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants'; // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(translate('no parent for {element} in {parent}', {\n      element: businessObject.id,\n      parent: newParent.id\n    }));\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n    collectionRemove(children, businessObject);\n\n    if (newParent) {\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};\n\nBpmnUpdater.prototype.updateConnectionWaypoints = function (connection) {\n  var di = getDi(connection);\n  di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\nBpmnUpdater.prototype.updateConnection = function (context) {\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = connection.source,\n      newSourceBo = getBusinessObject(newSource),\n      newTarget = connection.target,\n      newTargetBo = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSourceBo) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSourceBo && newSourceBo.get('outgoing')) {\n          newSourceBo.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSourceBo;\n    }\n\n    if (businessObject.targetRef !== newTargetBo) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTargetBo && newTargetBo.get('incoming')) {\n          newTargetBo.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTargetBo;\n    }\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSourceBo;\n    visualParent = context.parent || context.newParent || newTargetBo;\n    this.updateSemanticParent(businessObject, newTargetBo, visualParent);\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSourceBo;\n    this.updateSemanticParent(businessObject, newSourceBo, visualParent); // targetRef = new target\n\n    businessObject.targetRef = newTargetBo;\n  }\n\n  this.updateConnectionWaypoints(connection);\n  this.updateDiConnection(connection, newSource, newTarget);\n}; // helpers //////////////////////\n\n\nBpmnUpdater.prototype._getLabel = function (di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};\n/**\n * Make sure the event listener is only called\n * if the touched element is a BPMN element.\n *\n * @param  {Function} fn\n * @return {Function} guarded function\n */\n\n\nfunction ifBpmn(fn) {\n  return function (event) {\n    var context = event.context,\n        element = context.shape || context.connection;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}\n/**\n * Return dc:Bounds of bpmndi:BPMNLabel if exists.\n *\n * @param {djs.model.shape} shape\n *\n * @returns {Object|undefined}\n */\n\n\nfunction getEmbeddedLabelBounds(shape) {\n  if (!is(shape, 'bpmn:Activity')) {\n    return;\n  }\n\n  var di = getDi(shape);\n\n  if (!di) {\n    return;\n  }\n\n  var label = di.get('label');\n\n  if (!label) {\n    return;\n  }\n\n  return label.get('bounds');\n}","map":{"version":3,"names":["assign","forEach","inherits","remove","collectionRemove","add","collectionAdd","Label","getBusinessObject","getDi","is","isAny","delta","CommandInterceptor","BpmnUpdater","eventBus","bpmnFactory","connectionDocking","translate","call","_bpmnFactory","_translate","self","cropConnection","e","context","hints","connection","cropped","createElementsBehavior","waypoints","getCroppedWaypoints","executed","reverted","updateParent","shape","oldParent","reverseUpdateParent","element","parent","newParent","ifBpmn","updateRoot","event","oldRoot","children","child","updateBounds","type","on","updateConnection","updateConnectionWaypoints","oldSource","newSource","connectionBo","oldSourceBo","newSourceBo","conditionExpression","oldConditionExpression","default","oldDefault","updateAttachment","$inject","prototype","businessObject","host","attachedToRef","parentShape","di","parentBusinessObject","parentDi","updateFlowNodeRefs","source","target","updateSemanticParent","dataObjectRef","updateDiParent","embeddedLabelBounds","getEmbeddedLabelBounds","embeddedLabelBoundsDelta","get","x","y","_getLabel","bounds","createDiBounds","set","width","height","newContainment","oldContainment","oldRefs","newRefs","updateDiConnection","newTarget","connectionDi","newSourceDi","newTargetDi","sourceElement","bpmnElement","targetElement","$parent","planeElements","push","getDefinitions","getLaneSet","container","laneSet","laneSets","childLaneSet","create","processRef","visualParent","containment","ioSpecification","process","definitions","Error","id","diChildren","createDiWaypoints","newTargetBo","inverseSet","sourceRef","targetRef","label","createDiLabel","fn"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js"],"sourcesContent":["import {\n  assign,\n  forEach\n} from 'min-dash';\n\nimport inherits from 'inherits-browser';\n\nimport {\n  remove as collectionRemove,\n  add as collectionAdd\n} from 'diagram-js/lib/util/Collections';\n\nimport {\n  Label\n} from 'diagram-js/lib/model';\n\nimport {\n  getBusinessObject,\n  getDi,\n  is\n} from '../../util/ModelUtil';\n\nimport {\n  isAny\n} from './util/ModelingUtil';\n\nimport {\n  delta\n} from 'diagram-js/lib/util/PositionUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML + DI\n * once changes on the diagram happen\n */\nexport default function BpmnUpdater(\n    eventBus, bpmnFactory, connectionDocking,\n    translate) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n\n  var self = this;\n\n\n\n  // connection cropping //////////////////////\n\n  // crop connection ends during create/update\n  function cropConnection(e) {\n    var context = e.context,\n        hints = context.hints || {},\n        connection;\n\n    if (!context.cropped && hints.createElementsBehavior !== false) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.create'\n  ], cropConnection);\n\n  this.reverted([ 'connection.layout' ], function(e) {\n    delete e.context.cropped;\n  });\n\n\n\n  // BPMN + DI update //////////////////////\n\n\n  // update parent\n  function updateParent(e) {\n    var context = e.context;\n\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n\n        // oldParent is the (old) new parent, because we are undoing\n        oldParent = context.parent || context.newParent;\n\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(updateParent));\n\n  this.reverted([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(reverseUpdateParent));\n\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n\n    forEach(children, function(child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed([ 'canvas.updateRoot' ], updateRoot);\n  this.reverted([ 'canvas.updateRoot' ], updateRoot);\n\n\n  // update bounds\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n  eventBus.on('shape.changed', function(event) {\n    if (event.element.type === 'label') {\n      updateBounds({ context: { shape: event.element } });\n    }\n  });\n\n  // attach / detach connection\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnect'\n  ], ifBpmn(updateConnection));\n\n  this.reverted([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnect'\n  ], ifBpmn(updateConnection));\n\n\n  // update waypoints\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n  this.reverted([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n  // update conditional/default flows\n  this.executed('connection.reconnect', ifBpmn(function(event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource);\n\n    // remove condition from connection on reconnect to new source\n    // if new source can NOT have condional sequence flow\n    if (connectionBo.conditionExpression && !isAny(newSourceBo, [\n      'bpmn:Activity',\n      'bpmn:ExclusiveGateway',\n      'bpmn:InclusiveGateway'\n    ])) {\n      context.oldConditionExpression = connectionBo.conditionExpression;\n\n      delete connectionBo.conditionExpression;\n    }\n\n    // remove default from old source flow on reconnect to new source\n    // if source changed\n    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {\n      context.oldDefault = oldSourceBo.default;\n\n      delete oldSourceBo.default;\n    }\n  }));\n\n  this.reverted('connection.reconnect', ifBpmn(function(event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource);\n\n    // add condition to connection on revert reconnect to new source\n    if (context.oldConditionExpression) {\n      connectionBo.conditionExpression = context.oldConditionExpression;\n    }\n\n    // add default to old source on revert reconnect to new source\n    if (context.oldDefault) {\n      oldSourceBo.default = context.oldDefault;\n\n      delete newSourceBo.default;\n    }\n  }));\n\n  // update attachments\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n  this.reverted([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n}\n\ninherits(BpmnUpdater, CommandInterceptor);\n\nBpmnUpdater.$inject = [\n  'eventBus',\n  'bpmnFactory',\n  'connectionDocking',\n  'translate'\n];\n\n\n// implementation //////////////////////\n\nBpmnUpdater.prototype.updateAttachment = function(context) {\n\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\nBpmnUpdater.prototype.updateParent = function(element, oldParent) {\n\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Label) {\n    return;\n  }\n\n  // data stores in collaborations are handled separately by DataStoreBehavior\n  if (is(element, 'bpmn:DataStoreReference') &&\n      element.parent &&\n      is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n\n  var parentShape = element.parent;\n\n  var businessObject = element.businessObject,\n      di = getDi(element),\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = getDi(parentShape);\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(di, parentDi);\n};\n\n\nBpmnUpdater.prototype.updateBounds = function(shape) {\n\n  var di = getDi(shape),\n      embeddedLabelBounds = getEmbeddedLabelBounds(shape);\n\n  // update embedded label bounds if possible\n  if (embeddedLabelBounds) {\n    var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get('bounds'));\n\n    assign(embeddedLabelBounds, {\n      x: shape.x + embeddedLabelBoundsDelta.x,\n      y: shape.y + embeddedLabelBoundsDelta.y\n    });\n  }\n\n  var target = (shape instanceof Label) ? this._getLabel(di) : di;\n\n  var bounds = target.bounds;\n\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\nBpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {\n\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is (oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n};\n\n\n// update existing sourceElement and targetElement di information\nBpmnUpdater.prototype.updateDiConnection = function(connection, newSource, newTarget) {\n  var connectionDi = getDi(connection),\n      newSourceDi = getDi(newSource),\n      newTargetDi = getDi(newTarget);\n\n  if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {\n    connectionDi.sourceElement = newSource && newSourceDi;\n  }\n\n  if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {\n    connectionDi.targetElement = newTarget && newTargetDi;\n  }\n\n};\n\n\nBpmnUpdater.prototype.updateDiParent = function(di, parentDi) {\n\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}\n\nBpmnUpdater.prototype.getLaneSet = function(container) {\n\n  var laneSet, laneSets;\n\n  // bpmn:Lane\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  }\n\n  // bpmn:Participant\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  }\n\n  // bpmn:FlowElementsContainer\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};\n\nBpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {\n\n  var containment,\n      translate = this._translate;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    }\n\n    // already in correct ioSpecification\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else\n\n  if (is(businessObject, 'bpmn:FlowElement')) {\n\n    if (newParent) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else\n\n      if (is(newParent, 'bpmn:Lane')) {\n        do {\n\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n\n      }\n    }\n\n    containment = 'flowElements';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Artifact')) {\n\n    while (newParent &&\n           !is(newParent, 'bpmn:Process') &&\n           !is(newParent, 'bpmn:SubProcess') &&\n           !is(newParent, 'bpmn:Collaboration')) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else\n\n  if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants';\n\n    // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(translate(\n      'no parent for {element} in {parent}',\n      {\n        element: businessObject.id,\n        parent: newParent.id\n      }\n    ));\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n\n    collectionRemove(children, businessObject);\n\n    if (newParent) {\n\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};\n\n\nBpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {\n  var di = getDi(connection);\n\n  di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\n\nBpmnUpdater.prototype.updateConnection = function(context) {\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = connection.source,\n      newSourceBo = getBusinessObject(newSource),\n      newTarget = connection.target,\n      newTargetBo = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSourceBo) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSourceBo && newSourceBo.get('outgoing')) {\n          newSourceBo.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSourceBo;\n    }\n\n    if (businessObject.targetRef !== newTargetBo) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTargetBo && newTargetBo.get('incoming')) {\n          newTargetBo.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTargetBo;\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSourceBo;\n\n    visualParent = context.parent || context.newParent || newTargetBo;\n\n    this.updateSemanticParent(businessObject, newTargetBo, visualParent);\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSourceBo;\n\n    this.updateSemanticParent(businessObject, newSourceBo, visualParent);\n\n    // targetRef = new target\n    businessObject.targetRef = newTargetBo;\n  }\n\n  this.updateConnectionWaypoints(connection);\n\n  this.updateDiConnection(connection, newSource, newTarget);\n};\n\n\n// helpers //////////////////////\n\nBpmnUpdater.prototype._getLabel = function(di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};\n\n\n/**\n * Make sure the event listener is only called\n * if the touched element is a BPMN element.\n *\n * @param  {Function} fn\n * @return {Function} guarded function\n */\nfunction ifBpmn(fn) {\n\n  return function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}\n\n/**\n * Return dc:Bounds of bpmndi:BPMNLabel if exists.\n *\n * @param {djs.model.shape} shape\n *\n * @returns {Object|undefined}\n */\nfunction getEmbeddedLabelBounds(shape) {\n  if (!is(shape, 'bpmn:Activity')) {\n    return;\n  }\n\n  var di = getDi(shape);\n\n  if (!di) {\n    return;\n  }\n\n  var label = di.get('label');\n\n  if (!label) {\n    return;\n  }\n\n  return label.get('bounds');\n}"],"mappings":"AAAA,SACEA,MADF,EAEEC,OAFF,QAGO,UAHP;AAKA,OAAOC,QAAP,MAAqB,kBAArB;AAEA,SACEC,MAAM,IAAIC,gBADZ,EAEEC,GAAG,IAAIC,aAFT,QAGO,iCAHP;AAKA,SACEC,KADF,QAEO,sBAFP;AAIA,SACEC,iBADF,EAEEC,KAFF,EAGEC,EAHF,QAIO,sBAJP;AAMA,SACEC,KADF,QAEO,qBAFP;AAIA,SACEC,KADF,QAEO,kCAFP;AAIA,OAAOC,kBAAP,MAA+B,2CAA/B;AAEA;AACA;AACA;AACA;;AACA,eAAe,SAASC,WAAT,CACXC,QADW,EACDC,WADC,EACYC,iBADZ,EAEXC,SAFW,EAEA;EAEbL,kBAAkB,CAACM,IAAnB,CAAwB,IAAxB,EAA8BJ,QAA9B;EAEA,KAAKK,YAAL,GAAoBJ,WAApB;EACA,KAAKK,UAAL,GAAkBH,SAAlB;EAEA,IAAII,IAAI,GAAG,IAAX,CAPa,CAWb;EAEA;;EACA,SAASC,cAAT,CAAwBC,CAAxB,EAA2B;IACzB,IAAIC,OAAO,GAAGD,CAAC,CAACC,OAAhB;IAAA,IACIC,KAAK,GAAGD,OAAO,CAACC,KAAR,IAAiB,EAD7B;IAAA,IAEIC,UAFJ;;IAIA,IAAI,CAACF,OAAO,CAACG,OAAT,IAAoBF,KAAK,CAACG,sBAAN,KAAiC,KAAzD,EAAgE;MAC9DF,UAAU,GAAGF,OAAO,CAACE,UAArB;MACAA,UAAU,CAACG,SAAX,GAAuBb,iBAAiB,CAACc,mBAAlB,CAAsCJ,UAAtC,CAAvB;MACAF,OAAO,CAACG,OAAR,GAAkB,IAAlB;IACD;EACF;;EAED,KAAKI,QAAL,CAAc,CACZ,mBADY,EAEZ,mBAFY,CAAd,EAGGT,cAHH;EAKA,KAAKU,QAAL,CAAc,CAAE,mBAAF,CAAd,EAAuC,UAAST,CAAT,EAAY;IACjD,OAAOA,CAAC,CAACC,OAAF,CAAUG,OAAjB;EACD,CAFD,EA/Ba,CAqCb;EAGA;;EACA,SAASM,YAAT,CAAsBV,CAAtB,EAAyB;IACvB,IAAIC,OAAO,GAAGD,CAAC,CAACC,OAAhB;IAEAH,IAAI,CAACY,YAAL,CAAkBT,OAAO,CAACU,KAAR,IAAiBV,OAAO,CAACE,UAA3C,EAAuDF,OAAO,CAACW,SAA/D;EACD;;EAED,SAASC,mBAAT,CAA6Bb,CAA7B,EAAgC;IAC9B,IAAIC,OAAO,GAAGD,CAAC,CAACC,OAAhB;IAEA,IAAIa,OAAO,GAAGb,OAAO,CAACU,KAAR,IAAiBV,OAAO,CAACE,UAAvC;IAAA,IAEI;IACAS,SAAS,GAAGX,OAAO,CAACc,MAAR,IAAkBd,OAAO,CAACe,SAH1C;IAKAlB,IAAI,CAACY,YAAL,CAAkBI,OAAlB,EAA2BF,SAA3B;EACD;;EAED,KAAKJ,QAAL,CAAc,CACZ,YADY,EAEZ,cAFY,EAGZ,cAHY,EAIZ,mBAJY,EAKZ,iBALY,EAMZ,mBANY,CAAd,EAOGS,MAAM,CAACP,YAAD,CAPT;EASA,KAAKD,QAAL,CAAc,CACZ,YADY,EAEZ,cAFY,EAGZ,cAHY,EAIZ,mBAJY,EAKZ,iBALY,EAMZ,mBANY,CAAd,EAOGQ,MAAM,CAACJ,mBAAD,CAPT;EASA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,SAASK,UAAT,CAAoBC,KAApB,EAA2B;IACzB,IAAIlB,OAAO,GAAGkB,KAAK,CAAClB,OAApB;IAAA,IACImB,OAAO,GAAGnB,OAAO,CAACmB,OADtB;IAAA,IAEIC,QAAQ,GAAGD,OAAO,CAACC,QAFvB;IAIA5C,OAAO,CAAC4C,QAAD,EAAW,UAASC,KAAT,EAAgB;MAChC,IAAIpC,EAAE,CAACoC,KAAD,EAAQ,kBAAR,CAAN,EAAmC;QACjCxB,IAAI,CAACY,YAAL,CAAkBY,KAAlB;MACD;IACF,CAJM,CAAP;EAKD;;EAED,KAAKd,QAAL,CAAc,CAAE,mBAAF,CAAd,EAAuCU,UAAvC;EACA,KAAKT,QAAL,CAAc,CAAE,mBAAF,CAAd,EAAuCS,UAAvC,EAjGa,CAoGb;;EACA,SAASK,YAAT,CAAsBvB,CAAtB,EAAyB;IACvB,IAAIW,KAAK,GAAGX,CAAC,CAACC,OAAF,CAAUU,KAAtB;;IAEA,IAAI,CAACzB,EAAE,CAACyB,KAAD,EAAQ,kBAAR,CAAP,EAAoC;MAClC;IACD;;IAEDb,IAAI,CAACyB,YAAL,CAAkBZ,KAAlB;EACD;;EAED,KAAKH,QAAL,CAAc,CAAE,YAAF,EAAgB,cAAhB,EAAgC,cAAhC,CAAd,EAAgES,MAAM,CAAC,UAASE,KAAT,EAAgB;IAErF;IACA,IAAIA,KAAK,CAAClB,OAAN,CAAcU,KAAd,CAAoBa,IAApB,KAA6B,OAAjC,EAA0C;MACxC;IACD;;IAEDD,YAAY,CAACJ,KAAD,CAAZ;EACD,CARqE,CAAtE;EAUA,KAAKV,QAAL,CAAc,CAAE,YAAF,EAAgB,cAAhB,EAAgC,cAAhC,CAAd,EAAgEQ,MAAM,CAAC,UAASE,KAAT,EAAgB;IAErF;IACA,IAAIA,KAAK,CAAClB,OAAN,CAAcU,KAAd,CAAoBa,IAApB,KAA6B,OAAjC,EAA0C;MACxC;IACD;;IAEDD,YAAY,CAACJ,KAAD,CAAZ;EACD,CARqE,CAAtE,EAzHa,CAmIb;EACA;;EACA5B,QAAQ,CAACkC,EAAT,CAAY,eAAZ,EAA6B,UAASN,KAAT,EAAgB;IAC3C,IAAIA,KAAK,CAACL,OAAN,CAAcU,IAAd,KAAuB,OAA3B,EAAoC;MAClCD,YAAY,CAAC;QAAEtB,OAAO,EAAE;UAAEU,KAAK,EAAEQ,KAAK,CAACL;QAAf;MAAX,CAAD,CAAZ;IACD;EACF,CAJD,EArIa,CA2Ib;;EACA,SAASY,gBAAT,CAA0B1B,CAA1B,EAA6B;IAC3BF,IAAI,CAAC4B,gBAAL,CAAsB1B,CAAC,CAACC,OAAxB;EACD;;EAED,KAAKO,QAAL,CAAc,CACZ,mBADY,EAEZ,iBAFY,EAGZ,mBAHY,EAIZ,sBAJY,CAAd,EAKGS,MAAM,CAACS,gBAAD,CALT;EAOA,KAAKjB,QAAL,CAAc,CACZ,mBADY,EAEZ,iBAFY,EAGZ,mBAHY,EAIZ,sBAJY,CAAd,EAKGQ,MAAM,CAACS,gBAAD,CALT,EAvJa,CA+Jb;;EACA,SAASC,yBAAT,CAAmC3B,CAAnC,EAAsC;IACpCF,IAAI,CAAC6B,yBAAL,CAA+B3B,CAAC,CAACC,OAAF,CAAUE,UAAzC;EACD;;EAED,KAAKK,QAAL,CAAc,CACZ,mBADY,EAEZ,iBAFY,EAGZ,4BAHY,CAAd,EAIGS,MAAM,CAACU,yBAAD,CAJT;EAMA,KAAKlB,QAAL,CAAc,CACZ,mBADY,EAEZ,iBAFY,EAGZ,4BAHY,CAAd,EAIGQ,MAAM,CAACU,yBAAD,CAJT,EA1Ka,CAgLb;;EACA,KAAKnB,QAAL,CAAc,sBAAd,EAAsCS,MAAM,CAAC,UAASE,KAAT,EAAgB;IAC3D,IAAIlB,OAAO,GAAGkB,KAAK,CAAClB,OAApB;IAAA,IACIE,UAAU,GAAGF,OAAO,CAACE,UADzB;IAAA,IAEIyB,SAAS,GAAG3B,OAAO,CAAC2B,SAFxB;IAAA,IAGIC,SAAS,GAAG5B,OAAO,CAAC4B,SAHxB;IAAA,IAIIC,YAAY,GAAG9C,iBAAiB,CAACmB,UAAD,CAJpC;IAAA,IAKI4B,WAAW,GAAG/C,iBAAiB,CAAC4C,SAAD,CALnC;IAAA,IAMII,WAAW,GAAGhD,iBAAiB,CAAC6C,SAAD,CANnC,CAD2D,CAS3D;IACA;;IACA,IAAIC,YAAY,CAACG,mBAAb,IAAoC,CAAC9C,KAAK,CAAC6C,WAAD,EAAc,CAC1D,eAD0D,EAE1D,uBAF0D,EAG1D,uBAH0D,CAAd,CAA9C,EAII;MACF/B,OAAO,CAACiC,sBAAR,GAAiCJ,YAAY,CAACG,mBAA9C;MAEA,OAAOH,YAAY,CAACG,mBAApB;IACD,CAnB0D,CAqB3D;IACA;;;IACA,IAAIL,SAAS,KAAKC,SAAd,IAA2BE,WAAW,CAACI,OAAZ,KAAwBL,YAAvD,EAAqE;MACnE7B,OAAO,CAACmC,UAAR,GAAqBL,WAAW,CAACI,OAAjC;MAEA,OAAOJ,WAAW,CAACI,OAAnB;IACD;EACF,CA5B2C,CAA5C;EA8BA,KAAK1B,QAAL,CAAc,sBAAd,EAAsCQ,MAAM,CAAC,UAASE,KAAT,EAAgB;IAC3D,IAAIlB,OAAO,GAAGkB,KAAK,CAAClB,OAApB;IAAA,IACIE,UAAU,GAAGF,OAAO,CAACE,UADzB;IAAA,IAEIyB,SAAS,GAAG3B,OAAO,CAAC2B,SAFxB;IAAA,IAGIC,SAAS,GAAG5B,OAAO,CAAC4B,SAHxB;IAAA,IAIIC,YAAY,GAAG9C,iBAAiB,CAACmB,UAAD,CAJpC;IAAA,IAKI4B,WAAW,GAAG/C,iBAAiB,CAAC4C,SAAD,CALnC;IAAA,IAMII,WAAW,GAAGhD,iBAAiB,CAAC6C,SAAD,CANnC,CAD2D,CAS3D;;IACA,IAAI5B,OAAO,CAACiC,sBAAZ,EAAoC;MAClCJ,YAAY,CAACG,mBAAb,GAAmChC,OAAO,CAACiC,sBAA3C;IACD,CAZ0D,CAc3D;;;IACA,IAAIjC,OAAO,CAACmC,UAAZ,EAAwB;MACtBL,WAAW,CAACI,OAAZ,GAAsBlC,OAAO,CAACmC,UAA9B;MAEA,OAAOJ,WAAW,CAACG,OAAnB;IACD;EACF,CApB2C,CAA5C,EA/Ma,CAqOb;;EACA,SAASE,gBAAT,CAA0BrC,CAA1B,EAA6B;IAC3BF,IAAI,CAACuC,gBAAL,CAAsBrC,CAAC,CAACC,OAAxB;EACD;;EAED,KAAKO,QAAL,CAAc,CAAE,0BAAF,CAAd,EAA8CS,MAAM,CAACoB,gBAAD,CAApD;EACA,KAAK5B,QAAL,CAAc,CAAE,0BAAF,CAAd,EAA8CQ,MAAM,CAACoB,gBAAD,CAApD;AACD;AAED3D,QAAQ,CAACY,WAAD,EAAcD,kBAAd,CAAR;AAEAC,WAAW,CAACgD,OAAZ,GAAsB,CACpB,UADoB,EAEpB,aAFoB,EAGpB,mBAHoB,EAIpB,WAJoB,CAAtB,C,CAQA;;AAEAhD,WAAW,CAACiD,SAAZ,CAAsBF,gBAAtB,GAAyC,UAASpC,OAAT,EAAkB;EAEzD,IAAIU,KAAK,GAAGV,OAAO,CAACU,KAApB;EAAA,IACI6B,cAAc,GAAG7B,KAAK,CAAC6B,cAD3B;EAAA,IAEIC,IAAI,GAAG9B,KAAK,CAAC8B,IAFjB;EAIAD,cAAc,CAACE,aAAf,GAA+BD,IAAI,IAAIA,IAAI,CAACD,cAA5C;AACD,CAPD;;AASAlD,WAAW,CAACiD,SAAZ,CAAsB7B,YAAtB,GAAqC,UAASI,OAAT,EAAkBF,SAAlB,EAA6B;EAEhE;EACA,IAAIE,OAAO,YAAY/B,KAAvB,EAA8B;IAC5B;EACD,CAL+D,CAOhE;;;EACA,IAAIG,EAAE,CAAC4B,OAAD,EAAU,yBAAV,CAAF,IACAA,OAAO,CAACC,MADR,IAEA7B,EAAE,CAAC4B,OAAO,CAACC,MAAT,EAAiB,oBAAjB,CAFN,EAE8C;IAC5C;EACD;;EAED,IAAI4B,WAAW,GAAG7B,OAAO,CAACC,MAA1B;EAEA,IAAIyB,cAAc,GAAG1B,OAAO,CAAC0B,cAA7B;EAAA,IACII,EAAE,GAAG3D,KAAK,CAAC6B,OAAD,CADd;EAAA,IAEI+B,oBAAoB,GAAGF,WAAW,IAAIA,WAAW,CAACH,cAFtD;EAAA,IAGIM,QAAQ,GAAG7D,KAAK,CAAC0D,WAAD,CAHpB;;EAKA,IAAIzD,EAAE,CAAC4B,OAAD,EAAU,eAAV,CAAN,EAAkC;IAChC,KAAKiC,kBAAL,CAAwBP,cAAxB,EAAwCK,oBAAxC,EAA8DjC,SAAS,IAAIA,SAAS,CAAC4B,cAArF;EACD;;EAED,IAAItD,EAAE,CAAC4B,OAAD,EAAU,4BAAV,CAAN,EAA+C;IAC7C,IAAIA,OAAO,CAACkC,MAAZ,EAAoB;MAClBH,oBAAoB,GAAG/B,OAAO,CAACkC,MAAR,CAAeR,cAAtC;IACD,CAFD,MAEO;MACLK,oBAAoB,GAAG,IAAvB;IACD;EACF;;EAED,IAAI3D,EAAE,CAAC4B,OAAD,EAAU,2BAAV,CAAN,EAA8C;IAC5C,IAAIA,OAAO,CAACmC,MAAZ,EAAoB;MAClBJ,oBAAoB,GAAG/B,OAAO,CAACmC,MAAR,CAAeT,cAAtC;IACD,CAFD,MAEO;MACLK,oBAAoB,GAAG,IAAvB;IACD;EACF;;EAED,KAAKK,oBAAL,CAA0BV,cAA1B,EAA0CK,oBAA1C;;EAEA,IAAI3D,EAAE,CAAC4B,OAAD,EAAU,0BAAV,CAAF,IAA2C0B,cAAc,CAACW,aAA9D,EAA6E;IAC3E,KAAKD,oBAAL,CAA0BV,cAAc,CAACW,aAAzC,EAAwDN,oBAAxD;EACD;;EAED,KAAKO,cAAL,CAAoBR,EAApB,EAAwBE,QAAxB;AACD,CAhDD;;AAmDAxD,WAAW,CAACiD,SAAZ,CAAsBhB,YAAtB,GAAqC,UAASZ,KAAT,EAAgB;EAEnD,IAAIiC,EAAE,GAAG3D,KAAK,CAAC0B,KAAD,CAAd;EAAA,IACI0C,mBAAmB,GAAGC,sBAAsB,CAAC3C,KAAD,CADhD,CAFmD,CAKnD;;EACA,IAAI0C,mBAAJ,EAAyB;IACvB,IAAIE,wBAAwB,GAAGnE,KAAK,CAACiE,mBAAD,EAAsBT,EAAE,CAACY,GAAH,CAAO,QAAP,CAAtB,CAApC;IAEAhF,MAAM,CAAC6E,mBAAD,EAAsB;MAC1BI,CAAC,EAAE9C,KAAK,CAAC8C,CAAN,GAAUF,wBAAwB,CAACE,CADZ;MAE1BC,CAAC,EAAE/C,KAAK,CAAC+C,CAAN,GAAUH,wBAAwB,CAACG;IAFZ,CAAtB,CAAN;EAID;;EAED,IAAIT,MAAM,GAAItC,KAAK,YAAY5B,KAAlB,GAA2B,KAAK4E,SAAL,CAAef,EAAf,CAA3B,GAAgDA,EAA7D;EAEA,IAAIgB,MAAM,GAAGX,MAAM,CAACW,MAApB;;EAEA,IAAI,CAACA,MAAL,EAAa;IACXA,MAAM,GAAG,KAAKhE,YAAL,CAAkBiE,cAAlB,EAAT;IACAZ,MAAM,CAACa,GAAP,CAAW,QAAX,EAAqBF,MAArB;EACD;;EAEDpF,MAAM,CAACoF,MAAD,EAAS;IACbH,CAAC,EAAE9C,KAAK,CAAC8C,CADI;IAEbC,CAAC,EAAE/C,KAAK,CAAC+C,CAFI;IAGbK,KAAK,EAAEpD,KAAK,CAACoD,KAHA;IAIbC,MAAM,EAAErD,KAAK,CAACqD;EAJD,CAAT,CAAN;AAMD,CA9BD;;AAgCA1E,WAAW,CAACiD,SAAZ,CAAsBQ,kBAAtB,GAA2C,UAASP,cAAT,EAAyByB,cAAzB,EAAyCC,cAAzC,EAAyD;EAElG,IAAIA,cAAc,KAAKD,cAAvB,EAAuC;IACrC;EACD;;EAED,IAAIE,OAAJ,EAAaC,OAAb;;EAEA,IAAIlF,EAAE,CAAEgF,cAAF,EAAkB,WAAlB,CAAN,EAAsC;IACpCC,OAAO,GAAGD,cAAc,CAACV,GAAf,CAAmB,aAAnB,CAAV;IACA5E,gBAAgB,CAACuF,OAAD,EAAU3B,cAAV,CAAhB;EACD;;EAED,IAAItD,EAAE,CAAC+E,cAAD,EAAiB,WAAjB,CAAN,EAAqC;IACnCG,OAAO,GAAGH,cAAc,CAACT,GAAf,CAAmB,aAAnB,CAAV;IACA1E,aAAa,CAACsF,OAAD,EAAU5B,cAAV,CAAb;EACD;AACF,CAjBD,C,CAoBA;;;AACAlD,WAAW,CAACiD,SAAZ,CAAsB8B,kBAAtB,GAA2C,UAASlE,UAAT,EAAqB0B,SAArB,EAAgCyC,SAAhC,EAA2C;EACpF,IAAIC,YAAY,GAAGtF,KAAK,CAACkB,UAAD,CAAxB;EAAA,IACIqE,WAAW,GAAGvF,KAAK,CAAC4C,SAAD,CADvB;EAAA,IAEI4C,WAAW,GAAGxF,KAAK,CAACqF,SAAD,CAFvB;;EAIA,IAAIC,YAAY,CAACG,aAAb,IAA8BH,YAAY,CAACG,aAAb,CAA2BC,WAA3B,KAA2C3F,iBAAiB,CAAC6C,SAAD,CAA9F,EAA2G;IACzG0C,YAAY,CAACG,aAAb,GAA6B7C,SAAS,IAAI2C,WAA1C;EACD;;EAED,IAAID,YAAY,CAACK,aAAb,IAA8BL,YAAY,CAACK,aAAb,CAA2BD,WAA3B,KAA2C3F,iBAAiB,CAACsF,SAAD,CAA9F,EAA2G;IACzGC,YAAY,CAACK,aAAb,GAA6BN,SAAS,IAAIG,WAA1C;EACD;AAEF,CAbD;;AAgBAnF,WAAW,CAACiD,SAAZ,CAAsBa,cAAtB,GAAuC,UAASR,EAAT,EAAaE,QAAb,EAAuB;EAE5D,IAAIA,QAAQ,IAAI,CAAC5D,EAAE,CAAC4D,QAAD,EAAW,kBAAX,CAAnB,EAAmD;IACjDA,QAAQ,GAAGA,QAAQ,CAAC+B,OAApB;EACD;;EAED,IAAIjC,EAAE,CAACiC,OAAH,KAAe/B,QAAnB,EAA6B;IAC3B;EACD;;EAED,IAAIgC,aAAa,GAAG,CAAChC,QAAQ,IAAIF,EAAE,CAACiC,OAAhB,EAAyBrB,GAAzB,CAA6B,cAA7B,CAApB;;EAEA,IAAIV,QAAJ,EAAc;IACZgC,aAAa,CAACC,IAAd,CAAmBnC,EAAnB;IACAA,EAAE,CAACiC,OAAH,GAAa/B,QAAb;EACD,CAHD,MAGO;IACLlE,gBAAgB,CAACkG,aAAD,EAAgBlC,EAAhB,CAAhB;IACAA,EAAE,CAACiC,OAAH,GAAa,IAAb;EACD;AACF,CAnBD;;AAqBA,SAASG,cAAT,CAAwBlE,OAAxB,EAAiC;EAC/B,OAAOA,OAAO,IAAI,CAAC5B,EAAE,CAAC4B,OAAD,EAAU,kBAAV,CAArB,EAAoD;IAClDA,OAAO,GAAGA,OAAO,CAAC+D,OAAlB;EACD;;EAED,OAAO/D,OAAP;AACD;;AAEDxB,WAAW,CAACiD,SAAZ,CAAsB0C,UAAtB,GAAmC,UAASC,SAAT,EAAoB;EAErD,IAAIC,OAAJ,EAAaC,QAAb,CAFqD,CAIrD;;EACA,IAAIlG,EAAE,CAACgG,SAAD,EAAY,WAAZ,CAAN,EAAgC;IAC9BC,OAAO,GAAGD,SAAS,CAACG,YAApB;;IAEA,IAAI,CAACF,OAAL,EAAc;MACZA,OAAO,GAAG,KAAKvF,YAAL,CAAkB0F,MAAlB,CAAyB,cAAzB,CAAV;MACAJ,SAAS,CAACG,YAAV,GAAyBF,OAAzB;MACAA,OAAO,CAACN,OAAR,GAAkBK,SAAlB;IACD;;IAED,OAAOC,OAAP;EACD,CAfoD,CAiBrD;;;EACA,IAAIjG,EAAE,CAACgG,SAAD,EAAY,kBAAZ,CAAN,EAAuC;IACrCA,SAAS,GAAGA,SAAS,CAACK,UAAtB;EACD,CApBoD,CAsBrD;;;EACAH,QAAQ,GAAGF,SAAS,CAAC1B,GAAV,CAAc,UAAd,CAAX;EACA2B,OAAO,GAAGC,QAAQ,CAAC,CAAD,CAAlB;;EAEA,IAAI,CAACD,OAAL,EAAc;IACZA,OAAO,GAAG,KAAKvF,YAAL,CAAkB0F,MAAlB,CAAyB,cAAzB,CAAV;IACAH,OAAO,CAACN,OAAR,GAAkBK,SAAlB;IACAE,QAAQ,CAACL,IAAT,CAAcI,OAAd;EACD;;EAED,OAAOA,OAAP;AACD,CAjCD;;AAmCA7F,WAAW,CAACiD,SAAZ,CAAsBW,oBAAtB,GAA6C,UAASV,cAAT,EAAyBxB,SAAzB,EAAoCwE,YAApC,EAAkD;EAE7F,IAAIC,WAAJ;EAAA,IACI/F,SAAS,GAAG,KAAKG,UADrB;;EAGA,IAAI2C,cAAc,CAACqC,OAAf,KAA2B7D,SAA/B,EAA0C;IACxC;EACD;;EAED,IAAI9B,EAAE,CAACsD,cAAD,EAAiB,gBAAjB,CAAF,IAAwCtD,EAAE,CAACsD,cAAD,EAAiB,iBAAjB,CAA9C,EAAmF;IAEjF,IAAItD,EAAE,CAAC8B,SAAD,EAAY,kBAAZ,CAAF,IAAqC,gBAAgBA,SAAzD,EAAoE;MAClEA,SAAS,GAAGA,SAAS,CAACuE,UAAtB;IACD,CAJgF,CAMjF;;;IACA,IAAI,qBAAqBvE,SAArB,IAAkCA,SAAS,CAAC0E,eAAV,KAA8BlD,cAAc,CAACqC,OAAnF,EAA4F;MAC1F;IACD;EACF;;EAED,IAAI3F,EAAE,CAACsD,cAAD,EAAiB,WAAjB,CAAN,EAAqC;IAEnC,IAAIxB,SAAJ,EAAe;MACbA,SAAS,GAAG,KAAKiE,UAAL,CAAgBjE,SAAhB,CAAZ;IACD;;IAEDyE,WAAW,GAAG,OAAd;EACD,CAPD,MASA,IAAIvG,EAAE,CAACsD,cAAD,EAAiB,kBAAjB,CAAN,EAA4C;IAE1C,IAAIxB,SAAJ,EAAe;MAEb,IAAI9B,EAAE,CAAC8B,SAAD,EAAY,kBAAZ,CAAN,EAAuC;QACrCA,SAAS,GAAGA,SAAS,CAACuE,UAAtB;MACD,CAFD,MAIA,IAAIrG,EAAE,CAAC8B,SAAD,EAAY,WAAZ,CAAN,EAAgC;QAC9B,GAAG;UAED;UACAA,SAAS,GAAGA,SAAS,CAAC6D,OAAV,CAAkBA,OAA9B;QACD,CAJD,QAIS3F,EAAE,CAAC8B,SAAD,EAAY,WAAZ,CAJX;MAMD;IACF;;IAEDyE,WAAW,GAAG,cAAd;EAED,CApBD,MAsBA,IAAIvG,EAAE,CAACsD,cAAD,EAAiB,eAAjB,CAAN,EAAyC;IAEvC,OAAOxB,SAAS,IACT,CAAC9B,EAAE,CAAC8B,SAAD,EAAY,cAAZ,CADH,IAEA,CAAC9B,EAAE,CAAC8B,SAAD,EAAY,iBAAZ,CAFH,IAGA,CAAC9B,EAAE,CAAC8B,SAAD,EAAY,oBAAZ,CAHV,EAG6C;MAE3C,IAAI9B,EAAE,CAAC8B,SAAD,EAAY,kBAAZ,CAAN,EAAuC;QACrCA,SAAS,GAAGA,SAAS,CAACuE,UAAtB;QACA;MACD,CAHD,MAGO;QACLvE,SAAS,GAAGA,SAAS,CAAC6D,OAAtB;MACD;IACF;;IAEDY,WAAW,GAAG,WAAd;EACD,CAhBD,MAkBA,IAAIvG,EAAE,CAACsD,cAAD,EAAiB,kBAAjB,CAAN,EAA4C;IAC1CiD,WAAW,GAAG,cAAd;EAED,CAHD,MAKA,IAAIvG,EAAE,CAACsD,cAAD,EAAiB,kBAAjB,CAAN,EAA4C;IAC1CiD,WAAW,GAAG,cAAd,CAD0C,CAG1C;IACA;;IAEA,IAAIE,OAAO,GAAGnD,cAAc,CAAC+C,UAA7B;IAAA,IACIK,WADJ;;IAGA,IAAID,OAAJ,EAAa;MACXC,WAAW,GAAGZ,cAAc,CAACxC,cAAc,CAACqC,OAAf,IAA0B7D,SAA3B,CAA5B;;MAEA,IAAIwB,cAAc,CAACqC,OAAnB,EAA4B;QAC1BjG,gBAAgB,CAACgH,WAAW,CAACpC,GAAZ,CAAgB,cAAhB,CAAD,EAAkCmC,OAAlC,CAAhB;QACAA,OAAO,CAACd,OAAR,GAAkB,IAAlB;MACD;;MAED,IAAI7D,SAAJ,EAAe;QACblC,aAAa,CAAC8G,WAAW,CAACpC,GAAZ,CAAgB,cAAhB,CAAD,EAAkCmC,OAAlC,CAAb;QACAA,OAAO,CAACd,OAAR,GAAkBe,WAAlB;MACD;IACF;EACF,CAtBD,MAwBA,IAAI1G,EAAE,CAACsD,cAAD,EAAiB,4BAAjB,CAAN,EAAsD;IACpDiD,WAAW,GAAG,wBAAd;EACD,CAFD,MAIA,IAAIvG,EAAE,CAACsD,cAAD,EAAiB,2BAAjB,CAAN,EAAqD;IACnDiD,WAAW,GAAG,uBAAd;EACD;;EAED,IAAI,CAACA,WAAL,EAAkB;IAChB,MAAM,IAAII,KAAJ,CAAUnG,SAAS,CACvB,qCADuB,EAEvB;MACEoB,OAAO,EAAE0B,cAAc,CAACsD,EAD1B;MAEE/E,MAAM,EAAEC,SAAS,CAAC8E;IAFpB,CAFuB,CAAnB,CAAN;EAOD;;EAED,IAAIzE,QAAJ;;EAEA,IAAImB,cAAc,CAACqC,OAAnB,EAA4B;IAE1B;IACAxD,QAAQ,GAAGmB,cAAc,CAACqC,OAAf,CAAuBrB,GAAvB,CAA2BiC,WAA3B,CAAX;IACA7G,gBAAgB,CAACyC,QAAD,EAAWmB,cAAX,CAAhB;EACD;;EAED,IAAI,CAACxB,SAAL,EAAgB;IACdwB,cAAc,CAACqC,OAAf,GAAyB,IAAzB;EACD,CAFD,MAEO;IAEL;IACAxD,QAAQ,GAAGL,SAAS,CAACwC,GAAV,CAAciC,WAAd,CAAX;IACApE,QAAQ,CAAC0D,IAAT,CAAcvC,cAAd;IACAA,cAAc,CAACqC,OAAf,GAAyB7D,SAAzB;EACD;;EAED,IAAIwE,YAAJ,EAAkB;IAChB,IAAIO,UAAU,GAAGP,YAAY,CAAChC,GAAb,CAAiBiC,WAAjB,CAAjB;IAEA7G,gBAAgB,CAACyC,QAAD,EAAWmB,cAAX,CAAhB;;IAEA,IAAIxB,SAAJ,EAAe;MAEb,IAAI,CAAC+E,UAAL,EAAiB;QACfA,UAAU,GAAG,EAAb;QACA/E,SAAS,CAAC8C,GAAV,CAAc2B,WAAd,EAA2BM,UAA3B;MACD;;MAEDA,UAAU,CAAChB,IAAX,CAAgBvC,cAAhB;IACD;EACF;AACF,CAvJD;;AA0JAlD,WAAW,CAACiD,SAAZ,CAAsBZ,yBAAtB,GAAkD,UAASxB,UAAT,EAAqB;EACrE,IAAIyC,EAAE,GAAG3D,KAAK,CAACkB,UAAD,CAAd;EAEAyC,EAAE,CAACkB,GAAH,CAAO,UAAP,EAAmB,KAAKlE,YAAL,CAAkBoG,iBAAlB,CAAoC7F,UAAU,CAACG,SAA/C,CAAnB;AACD,CAJD;;AAOAhB,WAAW,CAACiD,SAAZ,CAAsBb,gBAAtB,GAAyC,UAASzB,OAAT,EAAkB;EACzD,IAAIE,UAAU,GAAGF,OAAO,CAACE,UAAzB;EAAA,IACIqC,cAAc,GAAGxD,iBAAiB,CAACmB,UAAD,CADtC;EAAA,IAEI0B,SAAS,GAAG1B,UAAU,CAAC6C,MAF3B;EAAA,IAGIhB,WAAW,GAAGhD,iBAAiB,CAAC6C,SAAD,CAHnC;EAAA,IAIIyC,SAAS,GAAGnE,UAAU,CAAC8C,MAJ3B;EAAA,IAKIgD,WAAW,GAAGjH,iBAAiB,CAACmB,UAAU,CAAC8C,MAAZ,CALnC;EAAA,IAMIuC,YANJ;;EAQA,IAAI,CAACtG,EAAE,CAACsD,cAAD,EAAiB,sBAAjB,CAAP,EAAiD;IAE/C,IAAI0D,UAAU,GAAGhH,EAAE,CAACsD,cAAD,EAAiB,mBAAjB,CAAnB;;IAEA,IAAIA,cAAc,CAAC2D,SAAf,KAA6BnE,WAAjC,EAA8C;MAC5C,IAAIkE,UAAJ,EAAgB;QACdtH,gBAAgB,CAAC4D,cAAc,CAAC2D,SAAf,IAA4B3D,cAAc,CAAC2D,SAAf,CAAyB3C,GAAzB,CAA6B,UAA7B,CAA7B,EAAuEhB,cAAvE,CAAhB;;QAEA,IAAIR,WAAW,IAAIA,WAAW,CAACwB,GAAZ,CAAgB,UAAhB,CAAnB,EAAgD;UAC9CxB,WAAW,CAACwB,GAAZ,CAAgB,UAAhB,EAA4BuB,IAA5B,CAAiCvC,cAAjC;QACD;MACF;;MAEDA,cAAc,CAAC2D,SAAf,GAA2BnE,WAA3B;IACD;;IAED,IAAIQ,cAAc,CAAC4D,SAAf,KAA6BH,WAAjC,EAA8C;MAC5C,IAAIC,UAAJ,EAAgB;QACdtH,gBAAgB,CAAC4D,cAAc,CAAC4D,SAAf,IAA4B5D,cAAc,CAAC4D,SAAf,CAAyB5C,GAAzB,CAA6B,UAA7B,CAA7B,EAAuEhB,cAAvE,CAAhB;;QAEA,IAAIyD,WAAW,IAAIA,WAAW,CAACzC,GAAZ,CAAgB,UAAhB,CAAnB,EAAgD;UAC9CyC,WAAW,CAACzC,GAAZ,CAAgB,UAAhB,EAA4BuB,IAA5B,CAAiCvC,cAAjC;QACD;MACF;;MAEDA,cAAc,CAAC4D,SAAf,GAA2BH,WAA3B;IACD;EACF,CA3BD,MA6BA,IAAI/G,EAAE,CAACsD,cAAD,EAAiB,2BAAjB,CAAN,EAAqD;IAEnD;IACAA,cAAc,CAACgB,GAAf,CAAmB,WAAnB,EAAgC,CAAhC,IAAqCxB,WAArC;IAEAwD,YAAY,GAAGvF,OAAO,CAACc,MAAR,IAAkBd,OAAO,CAACe,SAA1B,IAAuCiF,WAAtD;IAEA,KAAK/C,oBAAL,CAA0BV,cAA1B,EAA0CyD,WAA1C,EAAuDT,YAAvD;EACD,CARD,MAUA,IAAItG,EAAE,CAACsD,cAAD,EAAiB,4BAAjB,CAAN,EAAsD;IACpDgD,YAAY,GAAGvF,OAAO,CAACc,MAAR,IAAkBd,OAAO,CAACe,SAA1B,IAAuCgB,WAAtD;IAEA,KAAKkB,oBAAL,CAA0BV,cAA1B,EAA0CR,WAA1C,EAAuDwD,YAAvD,EAHoD,CAKpD;;IACAhD,cAAc,CAAC4D,SAAf,GAA2BH,WAA3B;EACD;;EAED,KAAKtE,yBAAL,CAA+BxB,UAA/B;EAEA,KAAKkE,kBAAL,CAAwBlE,UAAxB,EAAoC0B,SAApC,EAA+CyC,SAA/C;AACD,CA5DD,C,CA+DA;;;AAEAhF,WAAW,CAACiD,SAAZ,CAAsBoB,SAAtB,GAAkC,UAASf,EAAT,EAAa;EAC7C,IAAI,CAACA,EAAE,CAACyD,KAAR,EAAe;IACbzD,EAAE,CAACyD,KAAH,GAAW,KAAKzG,YAAL,CAAkB0G,aAAlB,EAAX;EACD;;EAED,OAAO1D,EAAE,CAACyD,KAAV;AACD,CAND;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASpF,MAAT,CAAgBsF,EAAhB,EAAoB;EAElB,OAAO,UAASpF,KAAT,EAAgB;IAErB,IAAIlB,OAAO,GAAGkB,KAAK,CAAClB,OAApB;IAAA,IACIa,OAAO,GAAGb,OAAO,CAACU,KAAR,IAAiBV,OAAO,CAACE,UADvC;;IAGA,IAAIjB,EAAE,CAAC4B,OAAD,EAAU,kBAAV,CAAN,EAAqC;MACnCyF,EAAE,CAACpF,KAAD,CAAF;IACD;EACF,CARD;AASD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmC,sBAAT,CAAgC3C,KAAhC,EAAuC;EACrC,IAAI,CAACzB,EAAE,CAACyB,KAAD,EAAQ,eAAR,CAAP,EAAiC;IAC/B;EACD;;EAED,IAAIiC,EAAE,GAAG3D,KAAK,CAAC0B,KAAD,CAAd;;EAEA,IAAI,CAACiC,EAAL,EAAS;IACP;EACD;;EAED,IAAIyD,KAAK,GAAGzD,EAAE,CAACY,GAAH,CAAO,OAAP,CAAZ;;EAEA,IAAI,CAAC6C,KAAL,EAAY;IACV;EACD;;EAED,OAAOA,KAAK,CAAC7C,GAAN,CAAU,QAAV,CAAP;AACD"},"metadata":{},"sourceType":"module"}