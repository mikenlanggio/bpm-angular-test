{"ast":null,"code":"import { assign, filter, groupBy, isObject } from 'min-dash';\nimport { classes as svgClasses } from 'tiny-svg';\nvar LOW_PRIORITY = 500,\n    MEDIUM_PRIORITY = 1250,\n    HIGH_PRIORITY = 1500;\nimport { getOriginal as getOriginalEvent } from '../../util/Event';\nimport { isPrimaryButton } from '../../util/Mouse';\nvar round = Math.round;\n\nfunction mid(element) {\n  return {\n    x: element.x + round(element.width / 2),\n    y: element.y + round(element.height / 2)\n  };\n}\n/**\n * A plugin that makes shapes draggable / droppable.\n *\n * @param {EventBus} eventBus\n * @param {Dragging} dragging\n * @param {Modeling} modeling\n * @param {Selection} selection\n * @param {Rules} rules\n */\n\n\nexport default function MoveEvents(eventBus, dragging, modeling, selection, rules) {\n  // rules\n  function canMove(shapes, delta, position, target) {\n    return rules.allowed('elements.move', {\n      shapes: shapes,\n      delta: delta,\n      position: position,\n      target: target\n    });\n  } // move events\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment.\n  //\n  // This sets up the context with\n  //\n  // * shape: the primary shape being moved\n  // * shapes: a list of shapes to be moved\n  // * validatedShapes: a list of shapes that are being checked\n  //                    against the rules before and during move\n  //\n\n\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function (event) {\n    var context = event.context,\n        shape = event.shape,\n        shapes = selection.get().slice(); // move only single shape if the dragged element\n    // is not part of the current selection\n\n    if (shapes.indexOf(shape) === -1) {\n      shapes = [shape];\n    } // ensure we remove nested elements in the collection\n    // and add attachers for a proper dragger\n\n\n    shapes = removeNested(shapes); // attach shapes to drag context\n\n    assign(context, {\n      shapes: shapes,\n      validatedShapes: shapes,\n      shape: shape\n    });\n  }); // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment\n  //\n\n  eventBus.on('shape.move.start', MEDIUM_PRIORITY, function (event) {\n    var context = event.context,\n        validatedShapes = context.validatedShapes,\n        canExecute;\n    canExecute = context.canExecute = canMove(validatedShapes); // check if we can move the elements\n\n    if (!canExecute) {\n      return false;\n    }\n  }); // assign a low priority to this handler\n  // to let others modify the move event before we update\n  // the context\n  //\n\n  eventBus.on('shape.move.move', LOW_PRIORITY, function (event) {\n    var context = event.context,\n        validatedShapes = context.validatedShapes,\n        hover = event.hover,\n        delta = {\n      x: event.dx,\n      y: event.dy\n    },\n        position = {\n      x: event.x,\n      y: event.y\n    },\n        canExecute; // check if we can move the elements\n\n    canExecute = canMove(validatedShapes, delta, position, hover);\n    context.delta = delta;\n    context.canExecute = canExecute; // simply ignore move over\n\n    if (canExecute === null) {\n      context.target = null;\n      return;\n    }\n\n    context.target = hover;\n  });\n  eventBus.on('shape.move.end', function (event) {\n    var context = event.context;\n    var delta = context.delta,\n        canExecute = context.canExecute,\n        isAttach = canExecute === 'attach',\n        shapes = context.shapes;\n\n    if (canExecute === false) {\n      return false;\n    } // ensure we have actual pixel values deltas\n    // (important when zoom level was > 1 during move)\n\n\n    delta.x = round(delta.x);\n    delta.y = round(delta.y);\n\n    if (delta.x === 0 && delta.y === 0) {\n      // didn't move\n      return;\n    }\n\n    modeling.moveElements(shapes, delta, context.target, {\n      primaryShape: context.shape,\n      attach: isAttach\n    });\n  }); // move activation\n\n  eventBus.on('element.mousedown', function (event) {\n    if (!isPrimaryButton(event)) {\n      return;\n    }\n\n    var originalEvent = getOriginalEvent(event);\n\n    if (!originalEvent) {\n      throw new Error('must supply DOM mousedown event');\n    }\n\n    return start(originalEvent, event.element);\n  });\n  /**\n   * Start move.\n   *\n   * @param {MouseEvent} event\n   * @param {djs.model.Shape} shape\n   * @param {boolean} [activate]\n   * @param {Object} [context]\n   */\n\n  function start(event, element, activate, context) {\n    if (isObject(activate)) {\n      context = activate;\n      activate = false;\n    } // do not move connections or the root element\n\n\n    if (element.waypoints || !element.parent) {\n      return;\n    } // ignore non-draggable hits\n\n\n    if (svgClasses(event.target).has('djs-hit-no-move')) {\n      return;\n    }\n\n    var referencePoint = mid(element);\n    dragging.init(event, referencePoint, 'shape.move', {\n      cursor: 'grabbing',\n      autoActivate: activate,\n      data: {\n        shape: element,\n        context: context || {}\n      }\n    }); // we've handled the event\n\n    return true;\n  } // API\n\n\n  this.start = start;\n}\nMoveEvents.$inject = ['eventBus', 'dragging', 'modeling', 'selection', 'rules'];\n/**\n * Return a filtered list of elements that do not contain\n * those nested into others.\n *\n * @param  {Array<djs.model.Base>} elements\n *\n * @return {Array<djs.model.Base>} filtered\n */\n\nfunction removeNested(elements) {\n  var ids = groupBy(elements, 'id');\n  return filter(elements, function (element) {\n    while (element = element.parent) {\n      // parent in selection\n      if (ids[element.id]) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}","map":{"version":3,"names":["assign","filter","groupBy","isObject","classes","svgClasses","LOW_PRIORITY","MEDIUM_PRIORITY","HIGH_PRIORITY","getOriginal","getOriginalEvent","isPrimaryButton","round","Math","mid","element","x","width","y","height","MoveEvents","eventBus","dragging","modeling","selection","rules","canMove","shapes","delta","position","target","allowed","on","event","context","shape","get","slice","indexOf","removeNested","validatedShapes","canExecute","hover","dx","dy","isAttach","moveElements","primaryShape","attach","originalEvent","Error","start","activate","waypoints","parent","has","referencePoint","init","cursor","autoActivate","data","$inject","elements","ids","id"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/move/Move.js"],"sourcesContent":["import {\n  assign,\n  filter,\n  groupBy,\n  isObject\n} from 'min-dash';\n\nimport {\n  classes as svgClasses\n} from 'tiny-svg';\n\nvar LOW_PRIORITY = 500,\n    MEDIUM_PRIORITY = 1250,\n    HIGH_PRIORITY = 1500;\n\nimport { getOriginal as getOriginalEvent } from '../../util/Event';\n\nimport {\n  isPrimaryButton\n} from '../../util/Mouse';\n\nvar round = Math.round;\n\nfunction mid(element) {\n  return {\n    x: element.x + round(element.width / 2),\n    y: element.y + round(element.height / 2)\n  };\n}\n\n/**\n * A plugin that makes shapes draggable / droppable.\n *\n * @param {EventBus} eventBus\n * @param {Dragging} dragging\n * @param {Modeling} modeling\n * @param {Selection} selection\n * @param {Rules} rules\n */\nexport default function MoveEvents(\n    eventBus, dragging, modeling,\n    selection, rules) {\n\n  // rules\n\n  function canMove(shapes, delta, position, target) {\n\n    return rules.allowed('elements.move', {\n      shapes: shapes,\n      delta: delta,\n      position: position,\n      target: target\n    });\n  }\n\n\n  // move events\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment.\n  //\n  // This sets up the context with\n  //\n  // * shape: the primary shape being moved\n  // * shapes: a list of shapes to be moved\n  // * validatedShapes: a list of shapes that are being checked\n  //                    against the rules before and during move\n  //\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        shape = event.shape,\n        shapes = selection.get().slice();\n\n    // move only single shape if the dragged element\n    // is not part of the current selection\n    if (shapes.indexOf(shape) === -1) {\n      shapes = [ shape ];\n    }\n\n    // ensure we remove nested elements in the collection\n    // and add attachers for a proper dragger\n    shapes = removeNested(shapes);\n\n    // attach shapes to drag context\n    assign(context, {\n      shapes: shapes,\n      validatedShapes: shapes,\n      shape: shape\n    });\n  });\n\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment\n  //\n  eventBus.on('shape.move.start', MEDIUM_PRIORITY, function(event) {\n\n    var context = event.context,\n        validatedShapes = context.validatedShapes,\n        canExecute;\n\n    canExecute = context.canExecute = canMove(validatedShapes);\n\n    // check if we can move the elements\n    if (!canExecute) {\n      return false;\n    }\n  });\n\n  // assign a low priority to this handler\n  // to let others modify the move event before we update\n  // the context\n  //\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        validatedShapes = context.validatedShapes,\n        hover = event.hover,\n        delta = { x: event.dx, y: event.dy },\n        position = { x: event.x, y: event.y },\n        canExecute;\n\n    // check if we can move the elements\n    canExecute = canMove(validatedShapes, delta, position, hover);\n\n    context.delta = delta;\n    context.canExecute = canExecute;\n\n    // simply ignore move over\n    if (canExecute === null) {\n      context.target = null;\n\n      return;\n    }\n\n    context.target = hover;\n  });\n\n  eventBus.on('shape.move.end', function(event) {\n\n    var context = event.context;\n\n    var delta = context.delta,\n        canExecute = context.canExecute,\n        isAttach = canExecute === 'attach',\n        shapes = context.shapes;\n\n    if (canExecute === false) {\n      return false;\n    }\n\n    // ensure we have actual pixel values deltas\n    // (important when zoom level was > 1 during move)\n    delta.x = round(delta.x);\n    delta.y = round(delta.y);\n\n    if (delta.x === 0 && delta.y === 0) {\n\n      // didn't move\n      return;\n    }\n\n    modeling.moveElements(shapes, delta, context.target, {\n      primaryShape: context.shape,\n      attach: isAttach\n    });\n  });\n\n\n  // move activation\n\n  eventBus.on('element.mousedown', function(event) {\n\n    if (!isPrimaryButton(event)) {\n      return;\n    }\n\n    var originalEvent = getOriginalEvent(event);\n\n    if (!originalEvent) {\n      throw new Error('must supply DOM mousedown event');\n    }\n\n    return start(originalEvent, event.element);\n  });\n\n  /**\n   * Start move.\n   *\n   * @param {MouseEvent} event\n   * @param {djs.model.Shape} shape\n   * @param {boolean} [activate]\n   * @param {Object} [context]\n   */\n  function start(event, element, activate, context) {\n    if (isObject(activate)) {\n      context = activate;\n      activate = false;\n    }\n\n    // do not move connections or the root element\n    if (element.waypoints || !element.parent) {\n      return;\n    }\n\n    // ignore non-draggable hits\n    if (svgClasses(event.target).has('djs-hit-no-move')) {\n      return;\n    }\n\n    var referencePoint = mid(element);\n\n    dragging.init(event, referencePoint, 'shape.move', {\n      cursor: 'grabbing',\n      autoActivate: activate,\n      data: {\n        shape: element,\n        context: context || {}\n      }\n    });\n\n    // we've handled the event\n    return true;\n  }\n\n  // API\n\n  this.start = start;\n}\n\nMoveEvents.$inject = [\n  'eventBus',\n  'dragging',\n  'modeling',\n  'selection',\n  'rules'\n];\n\n\n/**\n * Return a filtered list of elements that do not contain\n * those nested into others.\n *\n * @param  {Array<djs.model.Base>} elements\n *\n * @return {Array<djs.model.Base>} filtered\n */\nfunction removeNested(elements) {\n\n  var ids = groupBy(elements, 'id');\n\n  return filter(elements, function(element) {\n    while ((element = element.parent)) {\n\n      // parent in selection\n      if (ids[element.id]) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}