{"ast":null,"code":"import { assign, forEach, isArray } from 'min-dash';\nimport { setSnapped } from '../snapping/SnapUtil';\nimport { getClosestPointOnConnection } from './BendpointUtil';\nvar abs = Math.abs,\n    round = Math.round;\nvar TOLERANCE = 10;\nexport default function BendpointSnapping(eventBus) {\n  function snapTo(values, value) {\n    if (isArray(values)) {\n      var i = values.length;\n\n      while (i--) if (abs(values[i] - value) <= TOLERANCE) {\n        return values[i];\n      }\n    } else {\n      values = +values;\n      var rem = value % values;\n\n      if (rem < TOLERANCE) {\n        return value - rem;\n      }\n\n      if (rem > values - TOLERANCE) {\n        return value - rem + values;\n      }\n    }\n\n    return value;\n  }\n\n  function getSnapPoint(element, event) {\n    if (element.waypoints) {\n      return getClosestPointOnConnection(event, element);\n    }\n\n    if (element.width) {\n      return {\n        x: round(element.width / 2 + element.x),\n        y: round(element.height / 2 + element.y)\n      };\n    }\n  } // connection segment snapping //////////////////////\n\n\n  function getConnectionSegmentSnaps(event) {\n    var context = event.context,\n        snapPoints = context.snapPoints,\n        connection = context.connection,\n        waypoints = connection.waypoints,\n        segmentStart = context.segmentStart,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEnd = context.segmentEnd,\n        segmentEndIndex = context.segmentEndIndex,\n        axis = context.axis;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [waypoints[segmentStartIndex - 1], segmentStart, segmentEnd, waypoints[segmentEndIndex + 1]];\n\n    if (segmentStartIndex < 2) {\n      referenceWaypoints.unshift(getSnapPoint(connection.source, event));\n    }\n\n    if (segmentEndIndex > waypoints.length - 3) {\n      referenceWaypoints.unshift(getSnapPoint(connection.target, event));\n    }\n\n    context.snapPoints = snapPoints = {\n      horizontal: [],\n      vertical: []\n    };\n    forEach(referenceWaypoints, function (p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        if (axis === 'y') {\n          snapPoints.horizontal.push(p.y);\n        }\n\n        if (axis === 'x') {\n          snapPoints.vertical.push(p.x);\n        }\n      }\n    });\n    return snapPoints;\n  }\n\n  eventBus.on('connectionSegment.move.move', 1500, function (event) {\n    var snapPoints = getConnectionSegmentSnaps(event),\n        x = event.x,\n        y = event.y,\n        sx,\n        sy;\n\n    if (!snapPoints) {\n      return;\n    } // snap\n\n\n    sx = snapTo(snapPoints.vertical, x);\n    sy = snapTo(snapPoints.horizontal, y); // correction x/y\n\n    var cx = x - sx,\n        cy = y - sy; // update delta\n\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: sx,\n      y: sy\n    }); // only set snapped if actually snapped\n\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  }); // bendpoint snapping //////////////////////\n\n  function getBendpointSnaps(context) {\n    var snapPoints = context.snapPoints,\n        waypoints = context.connection.waypoints,\n        bendpointIndex = context.bendpointIndex;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];\n    context.snapPoints = snapPoints = {\n      horizontal: [],\n      vertical: []\n    };\n    forEach(referenceWaypoints, function (p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n        snapPoints.horizontal.push(p.y);\n        snapPoints.vertical.push(p.x);\n      }\n    });\n    return snapPoints;\n  } // Snap Endpoint of new connection\n\n\n  eventBus.on(['connect.hover', 'connect.move', 'connect.end'], 1500, function (event) {\n    var context = event.context,\n        hover = context.hover,\n        hoverMid = hover && getSnapPoint(hover, event); // only snap on connections, elements can have multiple connect endpoints\n\n    if (!isConnection(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {\n      return;\n    }\n\n    setSnapped(event, 'x', hoverMid.x);\n    setSnapped(event, 'y', hoverMid.y);\n  });\n  eventBus.on(['bendpoint.move.move', 'bendpoint.move.end'], 1500, function (event) {\n    var context = event.context,\n        snapPoints = getBendpointSnaps(context),\n        hover = context.hover,\n        hoverMid = hover && getSnapPoint(hover, event),\n        x = event.x,\n        y = event.y,\n        sx,\n        sy;\n\n    if (!snapPoints) {\n      return;\n    } // snap to hover mid\n\n\n    sx = snapTo(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x);\n    sy = snapTo(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y); // correction x/y\n\n    var cx = x - sx,\n        cy = y - sy; // update delta\n\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: event.x - cx,\n      y: event.y - cy\n    }); // only set snapped if actually snapped\n\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  });\n}\nBendpointSnapping.$inject = ['eventBus']; // helpers //////////////////////\n\nfunction isConnection(element) {\n  return element && !!element.waypoints;\n}","map":{"version":3,"names":["assign","forEach","isArray","setSnapped","getClosestPointOnConnection","abs","Math","round","TOLERANCE","BendpointSnapping","eventBus","snapTo","values","value","i","length","rem","getSnapPoint","element","event","waypoints","width","x","y","height","getConnectionSegmentSnaps","context","snapPoints","connection","segmentStart","segmentStartIndex","segmentEnd","segmentEndIndex","axis","referenceWaypoints","unshift","source","target","horizontal","vertical","p","original","push","on","sx","sy","cx","cy","dx","dy","indexOf","getBendpointSnaps","bendpointIndex","hover","hoverMid","isConnection","concat","$inject"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js"],"sourcesContent":["import {\n  assign,\n  forEach,\n  isArray\n} from 'min-dash';\n\nimport { setSnapped } from '../snapping/SnapUtil';\n\nimport { getClosestPointOnConnection } from './BendpointUtil';\n\nvar abs = Math.abs,\n    round = Math.round;\n\nvar TOLERANCE = 10;\n\n\nexport default function BendpointSnapping(eventBus) {\n\n  function snapTo(values, value) {\n\n    if (isArray(values)) {\n      var i = values.length;\n\n      while (i--) if (abs(values[i] - value) <= TOLERANCE) {\n        return values[i];\n      }\n    } else {\n      values = +values;\n      var rem = value % values;\n\n      if (rem < TOLERANCE) {\n        return value - rem;\n      }\n\n      if (rem > values - TOLERANCE) {\n        return value - rem + values;\n      }\n    }\n\n    return value;\n  }\n\n  function getSnapPoint(element, event) {\n\n    if (element.waypoints) {\n      return getClosestPointOnConnection(event, element);\n    }\n\n    if (element.width) {\n      return {\n        x: round(element.width / 2 + element.x),\n        y: round(element.height / 2 + element.y)\n      };\n    }\n  }\n\n  // connection segment snapping //////////////////////\n\n  function getConnectionSegmentSnaps(event) {\n\n    var context = event.context,\n        snapPoints = context.snapPoints,\n        connection = context.connection,\n        waypoints = connection.waypoints,\n        segmentStart = context.segmentStart,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEnd = context.segmentEnd,\n        segmentEndIndex = context.segmentEndIndex,\n        axis = context.axis;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [\n      waypoints[segmentStartIndex - 1],\n      segmentStart,\n      segmentEnd,\n      waypoints[segmentEndIndex + 1]\n    ];\n\n    if (segmentStartIndex < 2) {\n      referenceWaypoints.unshift(getSnapPoint(connection.source, event));\n    }\n\n    if (segmentEndIndex > waypoints.length - 3) {\n      referenceWaypoints.unshift(getSnapPoint(connection.target, event));\n    }\n\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\n\n    forEach(referenceWaypoints, function(p) {\n\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        if (axis === 'y') {\n          snapPoints.horizontal.push(p.y);\n        }\n\n        if (axis === 'x') {\n          snapPoints.vertical.push(p.x);\n        }\n      }\n    });\n\n    return snapPoints;\n  }\n\n  eventBus.on('connectionSegment.move.move', 1500, function(event) {\n    var snapPoints = getConnectionSegmentSnaps(event),\n        x = event.x,\n        y = event.y,\n        sx, sy;\n\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap\n    sx = snapTo(snapPoints.vertical, x);\n    sy = snapTo(snapPoints.horizontal, y);\n\n\n    // correction x/y\n    var cx = (x - sx),\n        cy = (y - sy);\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: sx,\n      y: sy\n    });\n\n    // only set snapped if actually snapped\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  });\n\n\n  // bendpoint snapping //////////////////////\n\n  function getBendpointSnaps(context) {\n\n    var snapPoints = context.snapPoints,\n        waypoints = context.connection.waypoints,\n        bendpointIndex = context.bendpointIndex;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [ waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1] ];\n\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\n\n    forEach(referenceWaypoints, function(p) {\n\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        snapPoints.horizontal.push(p.y);\n        snapPoints.vertical.push(p.x);\n      }\n    });\n\n    return snapPoints;\n  }\n\n  // Snap Endpoint of new connection\n  eventBus.on([\n    'connect.hover',\n    'connect.move',\n    'connect.end'\n  ], 1500, function(event) {\n    var context = event.context,\n        hover = context.hover,\n        hoverMid = hover && getSnapPoint(hover, event);\n\n    // only snap on connections, elements can have multiple connect endpoints\n    if (!isConnection(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {\n      return;\n    }\n\n    setSnapped(event, 'x', hoverMid.x);\n    setSnapped(event, 'y', hoverMid.y);\n  });\n\n  eventBus.on([ 'bendpoint.move.move', 'bendpoint.move.end' ], 1500, function(event) {\n\n    var context = event.context,\n        snapPoints = getBendpointSnaps(context),\n        hover = context.hover,\n        hoverMid = hover && getSnapPoint(hover, event),\n        x = event.x,\n        y = event.y,\n        sx, sy;\n\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap to hover mid\n    sx = snapTo(hoverMid ? snapPoints.vertical.concat([ hoverMid.x ]) : snapPoints.vertical, x);\n    sy = snapTo(hoverMid ? snapPoints.horizontal.concat([ hoverMid.y ]) : snapPoints.horizontal, y);\n\n    // correction x/y\n    var cx = (x - sx),\n        cy = (y - sy);\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: event.x - cx,\n      y: event.y - cy\n    });\n\n    // only set snapped if actually snapped\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  });\n}\n\n\nBendpointSnapping.$inject = [ 'eventBus' ];\n\n\n// helpers //////////////////////\n\nfunction isConnection(element) {\n  return element && !!element.waypoints;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}