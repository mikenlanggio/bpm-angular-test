{"ast":null,"code":"import { closest as domClosest } from 'min-dom';\nimport { toPoint } from '../../util/Event';\nvar HIGH_PRIORITY = 1500;\n/**\n * Browsers may swallow certain events (hover, out ...) if users are to\n * fast with the mouse.\n *\n * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event\n *\n * The fix implemented in this component ensure that we\n *\n * 1) have a hover state after a successful drag.move event\n * 2) have an out event when dragging leaves an element\n *\n * @param {ElementRegistry} elementRegistry\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\n\nexport default function HoverFix(elementRegistry, eventBus, injector) {\n  var self = this;\n  var dragging = injector.get('dragging', false);\n  /**\n   * Make sure we are god damn hovering!\n   *\n   * @param {Event} dragging event\n   */\n\n  function ensureHover(event) {\n    if (event.hover) {\n      return;\n    }\n\n    var originalEvent = event.originalEvent;\n\n    var gfx = self._findTargetGfx(originalEvent);\n\n    var element = gfx && elementRegistry.get(gfx);\n\n    if (gfx && element) {\n      // 1) cancel current mousemove\n      event.stopPropagation(); // 2) emit fake hover for new target\n\n      dragging.hover({\n        element: element,\n        gfx: gfx\n      }); // 3) re-trigger move event\n\n      dragging.move(originalEvent);\n    }\n  }\n\n  if (dragging) {\n    /**\n     * We wait for a specific sequence of events before\n     * emitting a fake drag.hover event.\n     *\n     * Event Sequence:\n     *\n     * drag.start\n     * drag.move >> ensure we are hovering\n     */\n    eventBus.on('drag.start', function (event) {\n      eventBus.once('drag.move', HIGH_PRIORITY, function (event) {\n        ensureHover(event);\n      });\n    });\n  }\n  /**\n   * We make sure that element.out is always fired, even if the\n   * browser swallows an element.out event.\n   *\n   * Event sequence:\n   *\n   * element.hover\n   * (element.out >> sometimes swallowed)\n   * element.hover >> ensure we fired element.out\n   */\n\n\n  (function () {\n    var hoverGfx;\n    var hover;\n    eventBus.on('element.hover', function (event) {\n      // (1) remember current hover element\n      hoverGfx = event.gfx;\n      hover = event.element;\n    });\n    eventBus.on('element.hover', HIGH_PRIORITY, function (event) {\n      // (3) am I on an element still?\n      if (hover) {\n        // (4) that is a problem, gotta \"simulate the out\"\n        eventBus.fire('element.out', {\n          element: hover,\n          gfx: hoverGfx\n        });\n      }\n    });\n    eventBus.on('element.out', function () {\n      // (2) unset hover state if we correctly outed us *GG*\n      hoverGfx = null;\n      hover = null;\n    });\n  })();\n\n  this._findTargetGfx = function (event) {\n    var position, target;\n\n    if (!(event instanceof MouseEvent)) {\n      return;\n    }\n\n    position = toPoint(event); // damn expensive operation, ouch!\n\n    target = document.elementFromPoint(position.x, position.y);\n    return getGfx(target);\n  };\n}\nHoverFix.$inject = ['elementRegistry', 'eventBus', 'injector']; // helpers /////////////////////\n\nfunction getGfx(target) {\n  return domClosest(target, 'svg, .djs-element', true);\n}","map":{"version":3,"names":["closest","domClosest","toPoint","HIGH_PRIORITY","HoverFix","elementRegistry","eventBus","injector","self","dragging","get","ensureHover","event","hover","originalEvent","gfx","_findTargetGfx","element","stopPropagation","move","on","once","hoverGfx","fire","position","target","MouseEvent","document","elementFromPoint","x","y","getGfx","$inject"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/hover-fix/HoverFix.js"],"sourcesContent":["import {\n  closest as domClosest\n} from 'min-dom';\n\nimport {\n  toPoint\n} from '../../util/Event';\n\nvar HIGH_PRIORITY = 1500;\n\n\n/**\n * Browsers may swallow certain events (hover, out ...) if users are to\n * fast with the mouse.\n *\n * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event\n *\n * The fix implemented in this component ensure that we\n *\n * 1) have a hover state after a successful drag.move event\n * 2) have an out event when dragging leaves an element\n *\n * @param {ElementRegistry} elementRegistry\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function HoverFix(elementRegistry, eventBus, injector) {\n\n  var self = this;\n\n  var dragging = injector.get('dragging', false);\n\n  /**\n   * Make sure we are god damn hovering!\n   *\n   * @param {Event} dragging event\n   */\n  function ensureHover(event) {\n\n    if (event.hover) {\n      return;\n    }\n\n    var originalEvent = event.originalEvent;\n\n    var gfx = self._findTargetGfx(originalEvent);\n\n    var element = gfx && elementRegistry.get(gfx);\n\n    if (gfx && element) {\n\n      // 1) cancel current mousemove\n      event.stopPropagation();\n\n      // 2) emit fake hover for new target\n      dragging.hover({ element: element, gfx: gfx });\n\n      // 3) re-trigger move event\n      dragging.move(originalEvent);\n    }\n  }\n\n\n  if (dragging) {\n\n    /**\n     * We wait for a specific sequence of events before\n     * emitting a fake drag.hover event.\n     *\n     * Event Sequence:\n     *\n     * drag.start\n     * drag.move >> ensure we are hovering\n     */\n    eventBus.on('drag.start', function(event) {\n\n      eventBus.once('drag.move', HIGH_PRIORITY, function(event) {\n\n        ensureHover(event);\n\n      });\n\n    });\n  }\n\n\n  /**\n   * We make sure that element.out is always fired, even if the\n   * browser swallows an element.out event.\n   *\n   * Event sequence:\n   *\n   * element.hover\n   * (element.out >> sometimes swallowed)\n   * element.hover >> ensure we fired element.out\n   */\n  (function() {\n    var hoverGfx;\n    var hover;\n\n    eventBus.on('element.hover', function(event) {\n\n      // (1) remember current hover element\n      hoverGfx = event.gfx;\n      hover = event.element;\n    });\n\n    eventBus.on('element.hover', HIGH_PRIORITY, function(event) {\n\n      // (3) am I on an element still?\n      if (hover) {\n\n        // (4) that is a problem, gotta \"simulate the out\"\n        eventBus.fire('element.out', {\n          element: hover,\n          gfx: hoverGfx\n        });\n      }\n\n    });\n\n    eventBus.on('element.out', function() {\n\n      // (2) unset hover state if we correctly outed us *GG*\n      hoverGfx = null;\n      hover = null;\n    });\n\n  })();\n\n  this._findTargetGfx = function(event) {\n    var position,\n        target;\n\n    if (!(event instanceof MouseEvent)) {\n      return;\n    }\n\n    position = toPoint(event);\n\n    // damn expensive operation, ouch!\n    target = document.elementFromPoint(position.x, position.y);\n\n    return getGfx(target);\n  };\n\n}\n\nHoverFix.$inject = [\n  'elementRegistry',\n  'eventBus',\n  'injector'\n];\n\n\n// helpers /////////////////////\n\nfunction getGfx(target) {\n  return domClosest(target, 'svg, .djs-element', true);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}