{"ast":null,"code":"import { assign, find, isArray, without } from 'min-dash';\nimport { getOrientation, getMid } from './LayoutUtil';\nimport { pointInRect, pointDistance, pointsAligned, pointsOnLine } from '../util/Geometry';\nvar MIN_SEGMENT_LENGTH = 20,\n    POINT_ORIENTATION_PADDING = 5;\nvar round = Math.round;\nvar INTERSECTION_THRESHOLD = 20,\n    ORIENTATION_THRESHOLD = {\n  'h:h': 20,\n  'v:v': 20,\n  'h:v': -10,\n  'v:h': -10\n};\n\nfunction needsTurn(orientation, startDirection) {\n  return !{\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /./,\n    v: /./\n  }[startDirection].test(orientation);\n}\n\nfunction canLayoutStraight(direction, targetOrientation) {\n  return {\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /left|right/,\n    v: /top|bottom/\n  }[direction].test(targetOrientation);\n}\n\nfunction getSegmentBendpoints(a, b, directions) {\n  var orientation = getOrientation(b, a, POINT_ORIENTATION_PADDING);\n  var startDirection = directions.split(':')[0];\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y);\n  var segmentEnd, segmentDirections;\n  var layoutStraight = canLayoutStraight(startDirection, orientation),\n      layoutHorizontal = /h|r|l/.test(startDirection),\n      layoutTurn = false;\n  var turnNextDirections = false;\n\n  if (layoutStraight) {\n    segmentEnd = layoutHorizontal ? {\n      x: xmid,\n      y: a.y\n    } : {\n      x: a.x,\n      y: ymid\n    };\n    segmentDirections = layoutHorizontal ? 'h:h' : 'v:v';\n  } else {\n    layoutTurn = needsTurn(orientation, startDirection);\n    segmentDirections = layoutHorizontal ? 'h:v' : 'v:h';\n\n    if (layoutTurn) {\n      if (layoutHorizontal) {\n        turnNextDirections = ymid === a.y;\n        segmentEnd = {\n          x: a.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),\n          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid\n        };\n      } else {\n        turnNextDirections = xmid === a.x;\n        segmentEnd = {\n          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,\n          y: a.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)\n        };\n      }\n    } else {\n      segmentEnd = {\n        x: xmid,\n        y: ymid\n      };\n    }\n  }\n\n  return {\n    waypoints: getBendpoints(a, segmentEnd, segmentDirections).concat(segmentEnd),\n    directions: segmentDirections,\n    turnNextDirections: turnNextDirections\n  };\n}\n\nfunction getStartSegment(a, b, directions) {\n  return getSegmentBendpoints(a, b, directions);\n}\n\nfunction getEndSegment(a, b, directions) {\n  var invertedSegment = getSegmentBendpoints(b, a, invertDirections(directions));\n  return {\n    waypoints: invertedSegment.waypoints.slice().reverse(),\n    directions: invertDirections(invertedSegment.directions),\n    turnNextDirections: invertedSegment.turnNextDirections\n  };\n}\n\nfunction getMidSegment(startSegment, endSegment) {\n  var startDirection = startSegment.directions.split(':')[1],\n      endDirection = endSegment.directions.split(':')[0];\n\n  if (startSegment.turnNextDirections) {\n    startDirection = startDirection == 'h' ? 'v' : 'h';\n  }\n\n  if (endSegment.turnNextDirections) {\n    endDirection = endDirection == 'h' ? 'v' : 'h';\n  }\n\n  var directions = startDirection + ':' + endDirection;\n  var bendpoints = getBendpoints(startSegment.waypoints[startSegment.waypoints.length - 1], endSegment.waypoints[0], directions);\n  return {\n    waypoints: bendpoints,\n    directions: directions\n  };\n}\n\nfunction invertDirections(directions) {\n  return directions.split(':').reverse().join(':');\n}\n/**\n * Handle simple layouts with maximum two bendpoints.\n */\n\n\nfunction getSimpleBendpoints(a, b, directions) {\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y); // one point, right or left from a\n\n  if (directions === 'h:v') {\n    return [{\n      x: b.x,\n      y: a.y\n    }];\n  } // one point, above or below a\n\n\n  if (directions === 'v:h') {\n    return [{\n      x: a.x,\n      y: b.y\n    }];\n  } // vertical segment between a and b\n\n\n  if (directions === 'h:h') {\n    return [{\n      x: xmid,\n      y: a.y\n    }, {\n      x: xmid,\n      y: b.y\n    }];\n  } // horizontal segment between a and b\n\n\n  if (directions === 'v:v') {\n    return [{\n      x: a.x,\n      y: ymid\n    }, {\n      x: b.x,\n      y: ymid\n    }];\n  }\n\n  throw new Error('invalid directions: can only handle varians of [hv]:[hv]');\n}\n/**\n * Returns the mid points for a manhattan connection between two points.\n *\n * @example h:h (horizontal:horizontal)\n *\n * [a]----[x]\n *         |\n *        [x]----[b]\n *\n * @example h:v (horizontal:vertical)\n *\n * [a]----[x]\n *         |\n *        [b]\n *\n * @example h:r (horizontal:right)\n *\n * [a]----[x]\n *         |\n *    [b]-[x]\n *\n * @param  {Point} a\n * @param  {Point} b\n * @param  {string} directions\n *\n * @return {Array<Point>}\n */\n\n\nfunction getBendpoints(a, b, directions) {\n  directions = directions || 'h:h';\n\n  if (!isValidDirections(directions)) {\n    throw new Error('unknown directions: <' + directions + '>: ' + 'must be specified as <start>:<end> ' + 'with start/end in { h,v,t,r,b,l }');\n  } // compute explicit directions, involving trbl dockings\n  // using a three segmented layouting algorithm\n\n\n  if (isExplicitDirections(directions)) {\n    var startSegment = getStartSegment(a, b, directions),\n        endSegment = getEndSegment(a, b, directions),\n        midSegment = getMidSegment(startSegment, endSegment);\n    return [].concat(startSegment.waypoints, midSegment.waypoints, endSegment.waypoints);\n  } // handle simple [hv]:[hv] cases that can be easily computed\n\n\n  return getSimpleBendpoints(a, b, directions);\n}\n/**\n * Create a connection between the two points according\n * to the manhattan layout (only horizontal and vertical) edges.\n *\n * @param {Point} a\n * @param {Point} b\n *\n * @param {string} [directions='h:h'] specifies manhattan directions for each point as {adirection}:{bdirection}.\n                   A directionfor a point is either `h` (horizontal) or `v` (vertical)\n *\n * @return {Array<Point>}\n */\n\n\nexport function connectPoints(a, b, directions) {\n  var points = getBendpoints(a, b, directions);\n  points.unshift(a);\n  points.push(b);\n  return withoutRedundantPoints(points);\n}\n/**\n * Connect two rectangles using a manhattan layouted connection.\n *\n * @param {Bounds} source source rectangle\n * @param {Bounds} target target rectangle\n * @param {Point} [start] source docking\n * @param {Point} [end] target docking\n *\n * @param {Object} [hints]\n * @param {string} [hints.preserveDocking=source] preserve docking on selected side\n * @param {Array<string>} [hints.preferredLayouts]\n * @param {Point|boolean} [hints.connectionStart] whether the start changed\n * @param {Point|boolean} [hints.connectionEnd] whether the end changed\n *\n * @return {Array<Point>} connection points\n */\n\nexport function connectRectangles(source, target, start, end, hints) {\n  var preferredLayouts = hints && hints.preferredLayouts || [];\n  var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';\n  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;\n  var orientation = getOrientation(source, target, threshold);\n  var directions = getDirections(orientation, preferredLayout);\n  start = start || getMid(source);\n  end = end || getMid(target);\n  var directionSplit = directions.split(':'); // compute actual docking points for start / end\n  // this ensures we properly layout only parts of the\n  // connection that lies in between the two rectangles\n\n  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)),\n      endDocking = getDockingPoint(end, target, directionSplit[1], orientation);\n  return connectPoints(startDocking, endDocking, directions);\n}\n/**\n * Repair the connection between two rectangles, of which one has been updated.\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} [start]\n * @param {Point} [end]\n * @param {Array<Point>} [waypoints]\n * @param {Object} [hints]\n * @param {Array<string>} [hints.preferredLayouts] list of preferred layouts\n * @param {boolean} [hints.connectionStart]\n * @param {boolean} [hints.connectionEnd]\n *\n * @return {Array<Point>} repaired waypoints\n */\n\nexport function repairConnection(source, target, start, end, waypoints, hints) {\n  if (isArray(start)) {\n    waypoints = start;\n    hints = end;\n    start = getMid(source);\n    end = getMid(target);\n  }\n\n  hints = assign({\n    preferredLayouts: []\n  }, hints);\n  waypoints = waypoints || [];\n  var preferredLayouts = hints.preferredLayouts,\n      preferStraight = preferredLayouts.indexOf('straight') !== -1,\n      repairedWaypoints; // just layout non-existing or simple connections\n  // attempt to render straight lines, if required\n  // attempt to layout a straight line\n\n  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  } // try to layout from end\n\n\n  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  } // try to layout from start\n\n\n  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  } // or whether nothing seems to have changed\n\n\n  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {\n    return waypoints;\n  } // simply reconnect if nothing else worked\n\n\n  return connectRectangles(source, target, start, end, hints);\n}\n\nfunction inRange(a, start, end) {\n  return a >= start && a <= end;\n}\n\nfunction isInRange(axis, a, b) {\n  var size = {\n    x: 'width',\n    y: 'height'\n  };\n  return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);\n}\n/**\n * Layout a straight connection\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} start\n * @param {Point} end\n * @param {Object} [hints]\n *\n * @return {Array<Point>|null} waypoints if straight layout worked\n */\n\n\nexport function tryLayoutStraight(source, target, start, end, hints) {\n  var axis = {},\n      primaryAxis,\n      orientation;\n  orientation = getOrientation(source, target); // only layout a straight connection if shapes are\n  // horizontally or vertically aligned\n\n  if (!/^(top|bottom|left|right)$/.test(orientation)) {\n    return null;\n  }\n\n  if (/top|bottom/.test(orientation)) {\n    primaryAxis = 'x';\n  }\n\n  if (/left|right/.test(orientation)) {\n    primaryAxis = 'y';\n  }\n\n  if (hints.preserveDocking === 'target') {\n    if (!isInRange(primaryAxis, end, source)) {\n      return null;\n    }\n\n    axis[primaryAxis] = end[primaryAxis];\n    return [{\n      x: axis.x !== undefined ? axis.x : start.x,\n      y: axis.y !== undefined ? axis.y : start.y,\n      original: {\n        x: axis.x !== undefined ? axis.x : start.x,\n        y: axis.y !== undefined ? axis.y : start.y\n      }\n    }, {\n      x: end.x,\n      y: end.y\n    }];\n  } else {\n    if (!isInRange(primaryAxis, start, target)) {\n      return null;\n    }\n\n    axis[primaryAxis] = start[primaryAxis];\n    return [{\n      x: start.x,\n      y: start.y\n    }, {\n      x: axis.x !== undefined ? axis.x : end.x,\n      y: axis.y !== undefined ? axis.y : end.y,\n      original: {\n        x: axis.x !== undefined ? axis.x : end.x,\n        y: axis.y !== undefined ? axis.y : end.y\n      }\n    }];\n  }\n}\n/**\n * Repair a connection from start.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\n\nfunction tryRepairConnectionStart(moved, other, newDocking, points) {\n  return _tryRepairConnectionSide(moved, other, newDocking, points);\n}\n/**\n * Repair a connection from end.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\n\n\nfunction tryRepairConnectionEnd(moved, other, newDocking, points) {\n  var waypoints = points.slice().reverse();\n  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);\n  return waypoints ? waypoints.reverse() : null;\n}\n/**\n * Repair a connection from one side that moved.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>} the repaired points between the two rectangles\n */\n\n\nfunction _tryRepairConnectionSide(moved, other, newDocking, points) {\n  function needsRelayout(points) {\n    if (points.length < 3) {\n      return true;\n    }\n\n    if (points.length > 4) {\n      return false;\n    } // relayout if two points overlap\n    // this is most likely due to\n\n\n    return !!find(points, function (p, idx) {\n      var q = points[idx - 1];\n      return q && pointDistance(p, q) < 3;\n    });\n  }\n\n  function repairBendpoint(candidate, oldPeer, newPeer) {\n    var alignment = pointsAligned(oldPeer, candidate);\n\n    switch (alignment) {\n      case 'v':\n        // repair horizontal alignment\n        return {\n          x: newPeer.x,\n          y: candidate.y\n        };\n\n      case 'h':\n        // repair vertical alignment\n        return {\n          x: candidate.x,\n          y: newPeer.y\n        };\n    }\n\n    return {\n      x: candidate.x,\n      y: candidate.y\n    };\n  }\n\n  function removeOverlapping(points, a, b) {\n    var i;\n\n    for (i = points.length - 2; i !== 0; i--) {\n      // intersects (?) break, remove all bendpoints up to this one and relayout\n      if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) || pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {\n        // return sliced old connection\n        return points.slice(i);\n      }\n    }\n\n    return points;\n  } // (0) only repair what has layoutable bendpoints\n  // (1) if only one bendpoint and on shape moved onto other shapes axis\n  //     (horizontally / vertically), relayout\n\n\n  if (needsRelayout(points)) {\n    return null;\n  }\n\n  var oldDocking = points[0],\n      newPoints = points.slice(),\n      slicedPoints; // (2) repair only last line segment and only if it was layouted before\n\n  newPoints[0] = newDocking;\n  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking); // (3) if shape intersects with any bendpoint after repair,\n  //     remove all segments up to this bendpoint and repair from there\n\n  slicedPoints = removeOverlapping(newPoints, moved, other);\n\n  if (slicedPoints !== newPoints) {\n    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);\n  } // (4) do NOT repair if repaired bendpoints are aligned\n\n\n  if (newPoints && pointsAligned(newPoints)) {\n    return null;\n  }\n\n  return newPoints;\n}\n/**\n * Returns the manhattan directions connecting two rectangles\n * with the given orientation.\n *\n * Will always return the default layout, if it is specific\n * regarding sides already (trbl).\n *\n * @example\n *\n * getDirections('top'); // -> 'v:v'\n * getDirections('intersect'); // -> 't:t'\n *\n * getDirections('top-right', 'v:h'); // -> 'v:h'\n * getDirections('top-right', 'h:h'); // -> 'h:h'\n *\n *\n * @param {string} orientation\n * @param {string} defaultLayout\n *\n * @return {string}\n */\n\n\nfunction getDirections(orientation, defaultLayout) {\n  // don't override specific trbl directions\n  if (isExplicitDirections(defaultLayout)) {\n    return defaultLayout;\n  }\n\n  switch (orientation) {\n    case 'intersect':\n      return 't:t';\n\n    case 'top':\n    case 'bottom':\n      return 'v:v';\n\n    case 'left':\n    case 'right':\n      return 'h:h';\n    // 'top-left'\n    // 'top-right'\n    // 'bottom-left'\n    // 'bottom-right'\n\n    default:\n      return defaultLayout;\n  }\n}\n\nfunction isValidDirections(directions) {\n  return directions && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions);\n}\n\nfunction isExplicitDirections(directions) {\n  return directions && /t|r|b|l/.test(directions);\n}\n\nfunction invertOrientation(orientation) {\n  return {\n    'top': 'bottom',\n    'bottom': 'top',\n    'left': 'right',\n    'right': 'left',\n    'top-left': 'bottom-right',\n    'bottom-right': 'top-left',\n    'top-right': 'bottom-left',\n    'bottom-left': 'top-right'\n  }[orientation];\n}\n\nfunction getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {\n  // ensure we end up with a specific docking direction\n  // based on the targetOrientation, if <h|v> is being passed\n  if (dockingDirection === 'h') {\n    dockingDirection = /left/.test(targetOrientation) ? 'l' : 'r';\n  }\n\n  if (dockingDirection === 'v') {\n    dockingDirection = /top/.test(targetOrientation) ? 't' : 'b';\n  }\n\n  if (dockingDirection === 't') {\n    return {\n      original: point,\n      x: point.x,\n      y: rectangle.y\n    };\n  }\n\n  if (dockingDirection === 'r') {\n    return {\n      original: point,\n      x: rectangle.x + rectangle.width,\n      y: point.y\n    };\n  }\n\n  if (dockingDirection === 'b') {\n    return {\n      original: point,\n      x: point.x,\n      y: rectangle.y + rectangle.height\n    };\n  }\n\n  if (dockingDirection === 'l') {\n    return {\n      original: point,\n      x: rectangle.x,\n      y: point.y\n    };\n  }\n\n  throw new Error('unexpected dockingDirection: <' + dockingDirection + '>');\n}\n/**\n * Return list of waypoints with redundant ones filtered out.\n *\n * @example\n *\n * Original points:\n *\n *   [x] ----- [x] ------ [x]\n *                         |\n *                        [x] ----- [x] - [x]\n *\n * Filtered:\n *\n *   [x] ---------------- [x]\n *                         |\n *                        [x] ----------- [x]\n *\n * @param  {Array<Point>} waypoints\n *\n * @return {Array<Point>}\n */\n\n\nexport function withoutRedundantPoints(waypoints) {\n  return waypoints.reduce(function (points, p, idx) {\n    var previous = points[points.length - 1],\n        next = waypoints[idx + 1];\n\n    if (!pointsOnLine(previous, next, p, 0)) {\n      points.push(p);\n    }\n\n    return points;\n  }, []);\n}","map":{"version":3,"names":["assign","find","isArray","without","getOrientation","getMid","pointInRect","pointDistance","pointsAligned","pointsOnLine","MIN_SEGMENT_LENGTH","POINT_ORIENTATION_PADDING","round","Math","INTERSECTION_THRESHOLD","ORIENTATION_THRESHOLD","needsTurn","orientation","startDirection","t","r","b","l","h","v","test","canLayoutStraight","direction","targetOrientation","getSegmentBendpoints","a","directions","split","xmid","x","ymid","y","segmentEnd","segmentDirections","layoutStraight","layoutHorizontal","layoutTurn","turnNextDirections","waypoints","getBendpoints","concat","getStartSegment","getEndSegment","invertedSegment","invertDirections","slice","reverse","getMidSegment","startSegment","endSegment","endDirection","bendpoints","length","join","getSimpleBendpoints","Error","isValidDirections","isExplicitDirections","midSegment","connectPoints","points","unshift","push","withoutRedundantPoints","connectRectangles","source","target","start","end","hints","preferredLayouts","preferredLayout","threshold","getDirections","directionSplit","startDocking","getDockingPoint","invertOrientation","endDocking","repairConnection","preferStraight","indexOf","repairedWaypoints","tryLayoutStraight","connectionEnd","tryRepairConnectionEnd","connectionStart","tryRepairConnectionStart","inRange","isInRange","axis","size","primaryAxis","preserveDocking","undefined","original","moved","other","newDocking","_tryRepairConnectionSide","needsRelayout","p","idx","q","repairBendpoint","candidate","oldPeer","newPeer","alignment","removeOverlapping","i","oldDocking","newPoints","slicedPoints","defaultLayout","point","rectangle","dockingDirection","width","height","reduce","previous","next"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/layout/ManhattanLayout.js"],"sourcesContent":["import {\n  assign,\n  find,\n  isArray,\n  without\n} from 'min-dash';\n\nimport {\n  getOrientation,\n  getMid\n} from './LayoutUtil';\n\nimport {\n  pointInRect,\n  pointDistance,\n  pointsAligned,\n  pointsOnLine\n} from '../util/Geometry';\n\nvar MIN_SEGMENT_LENGTH = 20,\n    POINT_ORIENTATION_PADDING = 5;\n\nvar round = Math.round;\n\nvar INTERSECTION_THRESHOLD = 20,\n    ORIENTATION_THRESHOLD = {\n      'h:h': 20,\n      'v:v': 20,\n      'h:v': -10,\n      'v:h': -10\n    };\n\nfunction needsTurn(orientation, startDirection) {\n  return !{\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /./,\n    v: /./\n  }[startDirection].test(orientation);\n}\n\nfunction canLayoutStraight(direction, targetOrientation) {\n  return {\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /left|right/,\n    v: /top|bottom/\n  }[direction].test(targetOrientation);\n}\n\nfunction getSegmentBendpoints(a, b, directions) {\n  var orientation = getOrientation(b, a, POINT_ORIENTATION_PADDING);\n\n  var startDirection = directions.split(':')[0];\n\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y);\n\n  var segmentEnd, segmentDirections;\n\n  var layoutStraight = canLayoutStraight(startDirection, orientation),\n      layoutHorizontal = /h|r|l/.test(startDirection),\n      layoutTurn = false;\n\n  var turnNextDirections = false;\n\n  if (layoutStraight) {\n    segmentEnd = layoutHorizontal ? { x: xmid, y: a.y } : { x: a.x, y: ymid };\n\n    segmentDirections = layoutHorizontal ? 'h:h' : 'v:v';\n  } else {\n    layoutTurn = needsTurn(orientation, startDirection);\n\n    segmentDirections = layoutHorizontal ? 'h:v' : 'v:h';\n\n    if (layoutTurn) {\n\n      if (layoutHorizontal) {\n        turnNextDirections = ymid === a.y;\n\n        segmentEnd = {\n          x: a.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),\n          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid\n        };\n      } else {\n        turnNextDirections = xmid === a.x;\n\n        segmentEnd = {\n          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,\n          y: a.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)\n        };\n      }\n\n    } else {\n      segmentEnd = {\n        x: xmid,\n        y: ymid\n      };\n    }\n  }\n\n  return {\n    waypoints: getBendpoints(a, segmentEnd, segmentDirections).concat(segmentEnd),\n    directions:  segmentDirections,\n    turnNextDirections: turnNextDirections\n  };\n}\n\nfunction getStartSegment(a, b, directions) {\n  return getSegmentBendpoints(a, b, directions);\n}\n\nfunction getEndSegment(a, b, directions) {\n  var invertedSegment = getSegmentBendpoints(b, a, invertDirections(directions));\n\n  return {\n    waypoints: invertedSegment.waypoints.slice().reverse(),\n    directions: invertDirections(invertedSegment.directions),\n    turnNextDirections: invertedSegment.turnNextDirections\n  };\n}\n\nfunction getMidSegment(startSegment, endSegment) {\n\n  var startDirection = startSegment.directions.split(':')[1],\n      endDirection = endSegment.directions.split(':')[0];\n\n  if (startSegment.turnNextDirections) {\n    startDirection = startDirection == 'h' ? 'v' : 'h';\n  }\n\n  if (endSegment.turnNextDirections) {\n    endDirection = endDirection == 'h' ? 'v' : 'h';\n  }\n\n  var directions = startDirection + ':' + endDirection;\n\n  var bendpoints = getBendpoints(\n    startSegment.waypoints[startSegment.waypoints.length - 1],\n    endSegment.waypoints[0],\n    directions\n  );\n\n  return {\n    waypoints: bendpoints,\n    directions: directions\n  };\n}\n\nfunction invertDirections(directions) {\n  return directions.split(':').reverse().join(':');\n}\n\n/**\n * Handle simple layouts with maximum two bendpoints.\n */\nfunction getSimpleBendpoints(a, b, directions) {\n\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y);\n\n  // one point, right or left from a\n  if (directions === 'h:v') {\n    return [ { x: b.x, y: a.y } ];\n  }\n\n  // one point, above or below a\n  if (directions === 'v:h') {\n    return [ { x: a.x, y: b.y } ];\n  }\n\n  // vertical segment between a and b\n  if (directions === 'h:h') {\n    return [\n      { x: xmid, y: a.y },\n      { x: xmid, y: b.y }\n    ];\n  }\n\n  // horizontal segment between a and b\n  if (directions === 'v:v') {\n    return [\n      { x: a.x, y: ymid },\n      { x: b.x, y: ymid }\n    ];\n  }\n\n  throw new Error('invalid directions: can only handle varians of [hv]:[hv]');\n}\n\n\n/**\n * Returns the mid points for a manhattan connection between two points.\n *\n * @example h:h (horizontal:horizontal)\n *\n * [a]----[x]\n *         |\n *        [x]----[b]\n *\n * @example h:v (horizontal:vertical)\n *\n * [a]----[x]\n *         |\n *        [b]\n *\n * @example h:r (horizontal:right)\n *\n * [a]----[x]\n *         |\n *    [b]-[x]\n *\n * @param  {Point} a\n * @param  {Point} b\n * @param  {string} directions\n *\n * @return {Array<Point>}\n */\nfunction getBendpoints(a, b, directions) {\n  directions = directions || 'h:h';\n\n  if (!isValidDirections(directions)) {\n    throw new Error(\n      'unknown directions: <' + directions + '>: ' +\n      'must be specified as <start>:<end> ' +\n      'with start/end in { h,v,t,r,b,l }'\n    );\n  }\n\n  // compute explicit directions, involving trbl dockings\n  // using a three segmented layouting algorithm\n  if (isExplicitDirections(directions)) {\n    var startSegment = getStartSegment(a, b, directions),\n        endSegment = getEndSegment(a, b, directions),\n        midSegment = getMidSegment(startSegment, endSegment);\n\n    return [].concat(\n      startSegment.waypoints,\n      midSegment.waypoints,\n      endSegment.waypoints\n    );\n  }\n\n  // handle simple [hv]:[hv] cases that can be easily computed\n  return getSimpleBendpoints(a, b, directions);\n}\n\n/**\n * Create a connection between the two points according\n * to the manhattan layout (only horizontal and vertical) edges.\n *\n * @param {Point} a\n * @param {Point} b\n *\n * @param {string} [directions='h:h'] specifies manhattan directions for each point as {adirection}:{bdirection}.\n                   A directionfor a point is either `h` (horizontal) or `v` (vertical)\n *\n * @return {Array<Point>}\n */\nexport function connectPoints(a, b, directions) {\n\n  var points = getBendpoints(a, b, directions);\n\n  points.unshift(a);\n  points.push(b);\n\n  return withoutRedundantPoints(points);\n}\n\n\n/**\n * Connect two rectangles using a manhattan layouted connection.\n *\n * @param {Bounds} source source rectangle\n * @param {Bounds} target target rectangle\n * @param {Point} [start] source docking\n * @param {Point} [end] target docking\n *\n * @param {Object} [hints]\n * @param {string} [hints.preserveDocking=source] preserve docking on selected side\n * @param {Array<string>} [hints.preferredLayouts]\n * @param {Point|boolean} [hints.connectionStart] whether the start changed\n * @param {Point|boolean} [hints.connectionEnd] whether the end changed\n *\n * @return {Array<Point>} connection points\n */\nexport function connectRectangles(source, target, start, end, hints) {\n\n  var preferredLayouts = hints && hints.preferredLayouts || [];\n\n  var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';\n\n  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;\n\n  var orientation = getOrientation(source, target, threshold);\n\n  var directions = getDirections(orientation, preferredLayout);\n\n  start = start || getMid(source);\n  end = end || getMid(target);\n\n  var directionSplit = directions.split(':');\n\n  // compute actual docking points for start / end\n  // this ensures we properly layout only parts of the\n  // connection that lies in between the two rectangles\n  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)),\n      endDocking = getDockingPoint(end, target, directionSplit[1], orientation);\n\n  return connectPoints(startDocking, endDocking, directions);\n}\n\n\n/**\n * Repair the connection between two rectangles, of which one has been updated.\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} [start]\n * @param {Point} [end]\n * @param {Array<Point>} [waypoints]\n * @param {Object} [hints]\n * @param {Array<string>} [hints.preferredLayouts] list of preferred layouts\n * @param {boolean} [hints.connectionStart]\n * @param {boolean} [hints.connectionEnd]\n *\n * @return {Array<Point>} repaired waypoints\n */\nexport function repairConnection(source, target, start, end, waypoints, hints) {\n\n  if (isArray(start)) {\n    waypoints = start;\n    hints = end;\n\n    start = getMid(source);\n    end = getMid(target);\n  }\n\n  hints = assign({ preferredLayouts: [] }, hints);\n  waypoints = waypoints || [];\n\n  var preferredLayouts = hints.preferredLayouts,\n      preferStraight = preferredLayouts.indexOf('straight') !== -1,\n      repairedWaypoints;\n\n  // just layout non-existing or simple connections\n  // attempt to render straight lines, if required\n\n  // attempt to layout a straight line\n  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from end\n  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from start\n  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // or whether nothing seems to have changed\n  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {\n    return waypoints;\n  }\n\n  // simply reconnect if nothing else worked\n  return connectRectangles(source, target, start, end, hints);\n}\n\n\nfunction inRange(a, start, end) {\n  return a >= start && a <= end;\n}\n\nfunction isInRange(axis, a, b) {\n  var size = {\n    x: 'width',\n    y: 'height'\n  };\n\n  return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);\n}\n\n/**\n * Layout a straight connection\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} start\n * @param {Point} end\n * @param {Object} [hints]\n *\n * @return {Array<Point>|null} waypoints if straight layout worked\n */\nexport function tryLayoutStraight(source, target, start, end, hints) {\n  var axis = {},\n      primaryAxis,\n      orientation;\n\n  orientation = getOrientation(source, target);\n\n  // only layout a straight connection if shapes are\n  // horizontally or vertically aligned\n  if (!/^(top|bottom|left|right)$/.test(orientation)) {\n    return null;\n  }\n\n  if (/top|bottom/.test(orientation)) {\n    primaryAxis = 'x';\n  }\n\n  if (/left|right/.test(orientation)) {\n    primaryAxis = 'y';\n  }\n\n  if (hints.preserveDocking === 'target') {\n\n    if (!isInRange(primaryAxis, end, source)) {\n      return null;\n    }\n\n    axis[primaryAxis] = end[primaryAxis];\n\n    return [\n      {\n        x: axis.x !== undefined ? axis.x : start.x,\n        y: axis.y !== undefined ? axis.y : start.y,\n        original: {\n          x: axis.x !== undefined ? axis.x : start.x,\n          y: axis.y !== undefined ? axis.y : start.y\n        }\n      },\n      {\n        x: end.x,\n        y: end.y\n      }\n    ];\n\n  } else {\n\n    if (!isInRange(primaryAxis, start, target)) {\n      return null;\n    }\n\n    axis[primaryAxis] = start[primaryAxis];\n\n    return [\n      {\n        x: start.x,\n        y: start.y\n      },\n      {\n        x: axis.x !== undefined ? axis.x : end.x,\n        y: axis.y !== undefined ? axis.y : end.y,\n        original: {\n          x: axis.x !== undefined ? axis.x : end.x,\n          y: axis.y !== undefined ? axis.y : end.y\n        }\n      }\n    ];\n  }\n\n}\n\n/**\n * Repair a connection from start.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\nfunction tryRepairConnectionStart(moved, other, newDocking, points) {\n  return _tryRepairConnectionSide(moved, other, newDocking, points);\n}\n\n/**\n * Repair a connection from end.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\nfunction tryRepairConnectionEnd(moved, other, newDocking, points) {\n  var waypoints = points.slice().reverse();\n\n  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);\n\n  return waypoints ? waypoints.reverse() : null;\n}\n\n/**\n * Repair a connection from one side that moved.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>} the repaired points between the two rectangles\n */\nfunction _tryRepairConnectionSide(moved, other, newDocking, points) {\n\n  function needsRelayout(points) {\n    if (points.length < 3) {\n      return true;\n    }\n\n    if (points.length > 4) {\n      return false;\n    }\n\n    // relayout if two points overlap\n    // this is most likely due to\n    return !!find(points, function(p, idx) {\n      var q = points[idx - 1];\n\n      return q && pointDistance(p, q) < 3;\n    });\n  }\n\n  function repairBendpoint(candidate, oldPeer, newPeer) {\n\n    var alignment = pointsAligned(oldPeer, candidate);\n\n    switch (alignment) {\n    case 'v':\n\n      // repair horizontal alignment\n      return { x: newPeer.x, y: candidate.y };\n    case 'h':\n\n      // repair vertical alignment\n      return { x: candidate.x, y: newPeer.y };\n    }\n\n    return { x: candidate.x, y: candidate. y };\n  }\n\n  function removeOverlapping(points, a, b) {\n    var i;\n\n    for (i = points.length - 2; i !== 0; i--) {\n\n      // intersects (?) break, remove all bendpoints up to this one and relayout\n      if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) ||\n          pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {\n\n        // return sliced old connection\n        return points.slice(i);\n      }\n    }\n\n    return points;\n  }\n\n  // (0) only repair what has layoutable bendpoints\n\n  // (1) if only one bendpoint and on shape moved onto other shapes axis\n  //     (horizontally / vertically), relayout\n\n  if (needsRelayout(points)) {\n    return null;\n  }\n\n  var oldDocking = points[0],\n      newPoints = points.slice(),\n      slicedPoints;\n\n  // (2) repair only last line segment and only if it was layouted before\n\n  newPoints[0] = newDocking;\n  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);\n\n\n  // (3) if shape intersects with any bendpoint after repair,\n  //     remove all segments up to this bendpoint and repair from there\n  slicedPoints = removeOverlapping(newPoints, moved, other);\n\n  if (slicedPoints !== newPoints) {\n    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);\n  }\n\n  // (4) do NOT repair if repaired bendpoints are aligned\n  if (newPoints && pointsAligned(newPoints)) {\n    return null;\n  }\n\n  return newPoints;\n}\n\n\n/**\n * Returns the manhattan directions connecting two rectangles\n * with the given orientation.\n *\n * Will always return the default layout, if it is specific\n * regarding sides already (trbl).\n *\n * @example\n *\n * getDirections('top'); // -> 'v:v'\n * getDirections('intersect'); // -> 't:t'\n *\n * getDirections('top-right', 'v:h'); // -> 'v:h'\n * getDirections('top-right', 'h:h'); // -> 'h:h'\n *\n *\n * @param {string} orientation\n * @param {string} defaultLayout\n *\n * @return {string}\n */\nfunction getDirections(orientation, defaultLayout) {\n\n  // don't override specific trbl directions\n  if (isExplicitDirections(defaultLayout)) {\n    return defaultLayout;\n  }\n\n  switch (orientation) {\n  case 'intersect':\n    return 't:t';\n\n  case 'top':\n  case 'bottom':\n    return 'v:v';\n\n  case 'left':\n  case 'right':\n    return 'h:h';\n\n  // 'top-left'\n  // 'top-right'\n  // 'bottom-left'\n  // 'bottom-right'\n  default:\n    return defaultLayout;\n  }\n}\n\nfunction isValidDirections(directions) {\n  return directions && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions);\n}\n\nfunction isExplicitDirections(directions) {\n  return directions && /t|r|b|l/.test(directions);\n}\n\nfunction invertOrientation(orientation) {\n  return {\n    'top': 'bottom',\n    'bottom': 'top',\n    'left': 'right',\n    'right': 'left',\n    'top-left': 'bottom-right',\n    'bottom-right': 'top-left',\n    'top-right': 'bottom-left',\n    'bottom-left': 'top-right',\n  }[orientation];\n}\n\nfunction getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {\n\n  // ensure we end up with a specific docking direction\n  // based on the targetOrientation, if <h|v> is being passed\n\n  if (dockingDirection === 'h') {\n    dockingDirection = /left/.test(targetOrientation) ? 'l' : 'r';\n  }\n\n  if (dockingDirection === 'v') {\n    dockingDirection = /top/.test(targetOrientation) ? 't' : 'b';\n  }\n\n  if (dockingDirection === 't') {\n    return { original: point, x: point.x, y: rectangle.y };\n  }\n\n  if (dockingDirection === 'r') {\n    return { original: point, x: rectangle.x + rectangle.width, y: point.y };\n  }\n\n  if (dockingDirection === 'b') {\n    return { original: point, x: point.x, y: rectangle.y + rectangle.height };\n  }\n\n  if (dockingDirection === 'l') {\n    return { original: point, x: rectangle.x, y: point.y };\n  }\n\n  throw new Error('unexpected dockingDirection: <' + dockingDirection + '>');\n}\n\n\n/**\n * Return list of waypoints with redundant ones filtered out.\n *\n * @example\n *\n * Original points:\n *\n *   [x] ----- [x] ------ [x]\n *                         |\n *                        [x] ----- [x] - [x]\n *\n * Filtered:\n *\n *   [x] ---------------- [x]\n *                         |\n *                        [x] ----------- [x]\n *\n * @param  {Array<Point>} waypoints\n *\n * @return {Array<Point>}\n */\nexport function withoutRedundantPoints(waypoints) {\n  return waypoints.reduce(function(points, p, idx) {\n\n    var previous = points[points.length - 1],\n        next = waypoints[idx + 1];\n\n    if (!pointsOnLine(previous, next, p, 0)) {\n      points.push(p);\n    }\n\n    return points;\n  }, []);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}