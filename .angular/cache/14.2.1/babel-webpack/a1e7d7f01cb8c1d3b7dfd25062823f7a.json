{"ast":null,"code":"import { getChildLanes, LANE_INDENTATION } from '../util/LaneUtil';\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if necessary.\n *\n * @param {Modeling} modeling\n */\n\nexport default function SplitLaneHandler(modeling, translate) {\n  this._modeling = modeling;\n  this._translate = translate;\n}\nSplitLaneHandler.$inject = ['modeling', 'translate'];\n\nSplitLaneHandler.prototype.preExecute = function (context) {\n  var modeling = this._modeling,\n      translate = this._translate;\n  var shape = context.shape,\n      newLanesCount = context.count;\n  var childLanes = getChildLanes(shape),\n      existingLanesCount = childLanes.length;\n\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(translate('more than {count} child lanes', {\n      count: newLanesCount\n    }));\n  }\n\n  var newLanesHeight = Math.round(shape.height / newLanesCount); // Iterate from top to bottom in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the bottom lane\n  // needs to take up all the remaining space.\n\n  var laneY, laneHeight, laneBounds, newLaneAttrs, idx;\n\n  for (idx = 0; idx < newLanesCount; idx++) {\n    laneY = shape.y + idx * newLanesHeight; // if bottom lane\n\n    if (idx === newLanesCount - 1) {\n      laneHeight = shape.height - newLanesHeight * idx;\n    } else {\n      laneHeight = newLanesHeight;\n    }\n\n    laneBounds = {\n      x: shape.x + LANE_INDENTATION,\n      y: laneY,\n      width: shape.width - LANE_INDENTATION,\n      height: laneHeight\n    };\n\n    if (idx < existingLanesCount) {\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane'\n      };\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};","map":{"version":3,"names":["getChildLanes","LANE_INDENTATION","SplitLaneHandler","modeling","translate","_modeling","_translate","$inject","prototype","preExecute","context","shape","newLanesCount","count","childLanes","existingLanesCount","length","Error","newLanesHeight","Math","round","height","laneY","laneHeight","laneBounds","newLaneAttrs","idx","y","x","width","resizeShape","type","createShape"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/features/modeling/cmd/SplitLaneHandler.js"],"sourcesContent":["import {\n  getChildLanes,\n  LANE_INDENTATION\n} from '../util/LaneUtil';\n\n\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if necessary.\n *\n * @param {Modeling} modeling\n */\nexport default function SplitLaneHandler(modeling, translate) {\n  this._modeling = modeling;\n  this._translate = translate;\n}\n\nSplitLaneHandler.$inject = [\n  'modeling',\n  'translate'\n];\n\n\nSplitLaneHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling,\n      translate = this._translate;\n\n  var shape = context.shape,\n      newLanesCount = context.count;\n\n  var childLanes = getChildLanes(shape),\n      existingLanesCount = childLanes.length;\n\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(translate('more than {count} child lanes', { count: newLanesCount }));\n  }\n\n  var newLanesHeight = Math.round(shape.height / newLanesCount);\n\n  // Iterate from top to bottom in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the bottom lane\n  // needs to take up all the remaining space.\n  var laneY,\n      laneHeight,\n      laneBounds,\n      newLaneAttrs,\n      idx;\n\n  for (idx = 0; idx < newLanesCount; idx++) {\n\n    laneY = shape.y + idx * newLanesHeight;\n\n    // if bottom lane\n    if (idx === newLanesCount - 1) {\n      laneHeight = shape.height - (newLanesHeight * idx);\n    } else {\n      laneHeight = newLanesHeight;\n    }\n\n    laneBounds = {\n      x: shape.x + LANE_INDENTATION,\n      y: laneY,\n      width: shape.width - LANE_INDENTATION,\n      height: laneHeight\n    };\n\n    if (idx < existingLanesCount) {\n\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane'\n      };\n\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};\n"],"mappings":"AAAA,SACEA,aADF,EAEEC,gBAFF,QAGO,kBAHP;AAMA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,gBAAT,CAA0BC,QAA1B,EAAoCC,SAApC,EAA+C;EAC5D,KAAKC,SAAL,GAAiBF,QAAjB;EACA,KAAKG,UAAL,GAAkBF,SAAlB;AACD;AAEDF,gBAAgB,CAACK,OAAjB,GAA2B,CACzB,UADyB,EAEzB,WAFyB,CAA3B;;AAMAL,gBAAgB,CAACM,SAAjB,CAA2BC,UAA3B,GAAwC,UAASC,OAAT,EAAkB;EAExD,IAAIP,QAAQ,GAAG,KAAKE,SAApB;EAAA,IACID,SAAS,GAAG,KAAKE,UADrB;EAGA,IAAIK,KAAK,GAAGD,OAAO,CAACC,KAApB;EAAA,IACIC,aAAa,GAAGF,OAAO,CAACG,KAD5B;EAGA,IAAIC,UAAU,GAAGd,aAAa,CAACW,KAAD,CAA9B;EAAA,IACII,kBAAkB,GAAGD,UAAU,CAACE,MADpC;;EAGA,IAAID,kBAAkB,GAAGH,aAAzB,EAAwC;IACtC,MAAM,IAAIK,KAAJ,CAAUb,SAAS,CAAC,+BAAD,EAAkC;MAAES,KAAK,EAAED;IAAT,CAAlC,CAAnB,CAAN;EACD;;EAED,IAAIM,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWT,KAAK,CAACU,MAAN,GAAeT,aAA1B,CAArB,CAfwD,CAiBxD;EACA;EACA;EACA;EACA;EACA;;EACA,IAAIU,KAAJ,EACIC,UADJ,EAEIC,UAFJ,EAGIC,YAHJ,EAIIC,GAJJ;;EAMA,KAAKA,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGd,aAApB,EAAmCc,GAAG,EAAtC,EAA0C;IAExCJ,KAAK,GAAGX,KAAK,CAACgB,CAAN,GAAUD,GAAG,GAAGR,cAAxB,CAFwC,CAIxC;;IACA,IAAIQ,GAAG,KAAKd,aAAa,GAAG,CAA5B,EAA+B;MAC7BW,UAAU,GAAGZ,KAAK,CAACU,MAAN,GAAgBH,cAAc,GAAGQ,GAA9C;IACD,CAFD,MAEO;MACLH,UAAU,GAAGL,cAAb;IACD;;IAEDM,UAAU,GAAG;MACXI,CAAC,EAAEjB,KAAK,CAACiB,CAAN,GAAU3B,gBADF;MAEX0B,CAAC,EAAEL,KAFQ;MAGXO,KAAK,EAAElB,KAAK,CAACkB,KAAN,GAAc5B,gBAHV;MAIXoB,MAAM,EAAEE;IAJG,CAAb;;IAOA,IAAIG,GAAG,GAAGX,kBAAV,EAA8B;MAE5B;MACAZ,QAAQ,CAAC2B,WAAT,CAAqBhB,UAAU,CAACY,GAAD,CAA/B,EAAsCF,UAAtC;IACD,CAJD,MAIO;MAEL;MACAC,YAAY,GAAG;QACbM,IAAI,EAAE;MADO,CAAf;MAIA5B,QAAQ,CAAC6B,WAAT,CAAqBP,YAArB,EAAmCD,UAAnC,EAA+Cb,KAA/C;IACD;EACF;AACF,CA7DD"},"metadata":{},"sourceType":"module"}