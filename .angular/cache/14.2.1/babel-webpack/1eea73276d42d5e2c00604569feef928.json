{"ast":null,"code":"import { setSnapped, isSnapped } from '../snapping/SnapUtil';\nimport { isCmd } from '../keyboard/KeyboardUtil';\nimport { assign, isNumber } from 'min-dash';\nimport { SPACING, quantize } from './GridUtil';\nvar LOWER_PRIORITY = 1200;\nvar LOW_PRIORITY = 800;\n/**\r\n * Basic grid snapping that covers connecting, creating, moving, resizing shapes, moving bendpoints\r\n * and connection segments.\r\n */\n\nexport default function GridSnapping(elementRegistry, eventBus, config) {\n  var active = !config || config.active !== false;\n  this._eventBus = eventBus;\n  var self = this;\n  eventBus.on('diagram.init', LOW_PRIORITY, function () {\n    self.setActive(active);\n  });\n  eventBus.on(['create.move', 'create.end', 'bendpoint.move.move', 'bendpoint.move.end', 'connect.move', 'connect.end', 'connectionSegment.move.move', 'connectionSegment.move.end', 'resize.move', 'resize.end', 'shape.move.move', 'shape.move.end'], LOWER_PRIORITY, function (event) {\n    var originalEvent = event.originalEvent;\n\n    if (!self.active || originalEvent && isCmd(originalEvent)) {\n      return;\n    }\n\n    var context = event.context,\n        gridSnappingContext = context.gridSnappingContext;\n\n    if (!gridSnappingContext) {\n      gridSnappingContext = context.gridSnappingContext = {};\n    }\n\n    ['x', 'y'].forEach(function (axis) {\n      var options = {}; // allow snapping with offset\n\n      var snapOffset = getSnapOffset(event, axis, elementRegistry);\n\n      if (snapOffset) {\n        options.offset = snapOffset;\n      } // allow snapping with min and max\n\n\n      var snapConstraints = getSnapConstraints(event, axis);\n\n      if (snapConstraints) {\n        assign(options, snapConstraints);\n      }\n\n      if (!isSnapped(event, axis)) {\n        self.snapEvent(event, axis, options);\n      }\n    });\n  });\n}\n/**\r\n * Snap an events x or y with optional min, max and offset.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\n\nGridSnapping.prototype.snapEvent = function (event, axis, options) {\n  var snappedValue = this.snapValue(event[axis], options);\n  setSnapped(event, axis, snappedValue);\n};\n/**\r\n * Expose grid spacing for third parties (i.e. extensions).\r\n *\r\n * @return {number} spacing of grid dots\r\n */\n\n\nGridSnapping.prototype.getGridSpacing = function () {\n  return SPACING;\n};\n/**\r\n * Snap value with optional min, max and offset.\r\n *\r\n * @param {number} value\r\n * @param {Object} options\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\n\n\nGridSnapping.prototype.snapValue = function (value, options) {\n  var offset = 0;\n\n  if (options && options.offset) {\n    offset = options.offset;\n  }\n\n  value += offset;\n  value = quantize(value, SPACING);\n  var min, max;\n\n  if (options && options.min) {\n    min = options.min;\n\n    if (isNumber(min)) {\n      min = quantize(min + offset, SPACING, 'ceil');\n      value = Math.max(value, min);\n    }\n  }\n\n  if (options && options.max) {\n    max = options.max;\n\n    if (isNumber(max)) {\n      max = quantize(max + offset, SPACING, 'floor');\n      value = Math.min(value, max);\n    }\n  }\n\n  value -= offset;\n  return value;\n};\n\nGridSnapping.prototype.isActive = function () {\n  return this.active;\n};\n\nGridSnapping.prototype.setActive = function (active) {\n  this.active = active;\n\n  this._eventBus.fire('gridSnapping.toggle', {\n    active: active\n  });\n};\n\nGridSnapping.prototype.toggleActive = function () {\n  this.setActive(!this.active);\n};\n\nGridSnapping.$inject = ['elementRegistry', 'eventBus', 'config.gridSnapping']; // helpers //////////\n\n/**\r\n * Get minimum and maximum snap constraints.\r\n * Constraints are cached.\r\n *\r\n * @param {Object} event\r\n * @param {Object} event.context\r\n * @param {string} axis\r\n *\r\n * @returns {boolean|Object}\r\n */\n\nfunction getSnapConstraints(event, axis) {\n  var context = event.context,\n      createConstraints = context.createConstraints,\n      resizeConstraints = context.resizeConstraints || {},\n      gridSnappingContext = context.gridSnappingContext,\n      snapConstraints = gridSnappingContext.snapConstraints; // cache snap constraints\n\n  if (snapConstraints && snapConstraints[axis]) {\n    return snapConstraints[axis];\n  }\n\n  if (!snapConstraints) {\n    snapConstraints = gridSnappingContext.snapConstraints = {};\n  }\n\n  if (!snapConstraints[axis]) {\n    snapConstraints[axis] = {};\n  }\n\n  var direction = context.direction; // create\n\n  if (createConstraints) {\n    if (isHorizontal(axis)) {\n      snapConstraints.x.min = createConstraints.left;\n      snapConstraints.x.max = createConstraints.right;\n    } else {\n      snapConstraints.y.min = createConstraints.top;\n      snapConstraints.y.max = createConstraints.bottom;\n    }\n  } // resize\n\n\n  var minResizeConstraints = resizeConstraints.min,\n      maxResizeConstraints = resizeConstraints.max;\n\n  if (minResizeConstraints) {\n    if (isHorizontal(axis)) {\n      if (isWest(direction)) {\n        snapConstraints.x.max = minResizeConstraints.left;\n      } else {\n        snapConstraints.x.min = minResizeConstraints.right;\n      }\n    } else {\n      if (isNorth(direction)) {\n        snapConstraints.y.max = minResizeConstraints.top;\n      } else {\n        snapConstraints.y.min = minResizeConstraints.bottom;\n      }\n    }\n  }\n\n  if (maxResizeConstraints) {\n    if (isHorizontal(axis)) {\n      if (isWest(direction)) {\n        snapConstraints.x.min = maxResizeConstraints.left;\n      } else {\n        snapConstraints.x.max = maxResizeConstraints.right;\n      }\n    } else {\n      if (isNorth(direction)) {\n        snapConstraints.y.min = maxResizeConstraints.top;\n      } else {\n        snapConstraints.y.max = maxResizeConstraints.bottom;\n      }\n    }\n  }\n\n  return snapConstraints[axis];\n}\n/**\r\n * Get snap offset.\r\n * Offset is cached.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {ElementRegistry} elementRegistry\r\n *\r\n * @returns {number}\r\n */\n\n\nfunction getSnapOffset(event, axis, elementRegistry) {\n  var context = event.context,\n      shape = event.shape,\n      gridSnappingContext = context.gridSnappingContext,\n      snapLocation = gridSnappingContext.snapLocation,\n      snapOffset = gridSnappingContext.snapOffset; // cache snap offset\n\n  if (snapOffset && isNumber(snapOffset[axis])) {\n    return snapOffset[axis];\n  }\n\n  if (!snapOffset) {\n    snapOffset = gridSnappingContext.snapOffset = {};\n  }\n\n  if (!isNumber(snapOffset[axis])) {\n    snapOffset[axis] = 0;\n  }\n\n  if (!shape) {\n    return snapOffset[axis];\n  }\n\n  if (!elementRegistry.get(shape.id)) {\n    if (isHorizontal(axis)) {\n      snapOffset[axis] += shape[axis] + shape.width / 2;\n    } else {\n      snapOffset[axis] += shape[axis] + shape.height / 2;\n    }\n  }\n\n  if (!snapLocation) {\n    return snapOffset[axis];\n  }\n\n  if (axis === 'x') {\n    if (/left/.test(snapLocation)) {\n      snapOffset[axis] -= shape.width / 2;\n    } else if (/right/.test(snapLocation)) {\n      snapOffset[axis] += shape.width / 2;\n    }\n  } else {\n    if (/top/.test(snapLocation)) {\n      snapOffset[axis] -= shape.height / 2;\n    } else if (/bottom/.test(snapLocation)) {\n      snapOffset[axis] += shape.height / 2;\n    }\n  }\n\n  return snapOffset[axis];\n}\n\nfunction isHorizontal(axis) {\n  return axis === 'x';\n}\n\nfunction isNorth(direction) {\n  return direction.indexOf('n') !== -1;\n}\n\nfunction isWest(direction) {\n  return direction.indexOf('w') !== -1;\n}","map":{"version":3,"names":["setSnapped","isSnapped","isCmd","assign","isNumber","SPACING","quantize","LOWER_PRIORITY","LOW_PRIORITY","GridSnapping","elementRegistry","eventBus","config","active","_eventBus","self","on","setActive","event","originalEvent","context","gridSnappingContext","forEach","axis","options","snapOffset","getSnapOffset","offset","snapConstraints","getSnapConstraints","snapEvent","prototype","snappedValue","snapValue","getGridSpacing","value","min","max","Math","isActive","fire","toggleActive","$inject","createConstraints","resizeConstraints","direction","isHorizontal","x","left","right","y","top","bottom","minResizeConstraints","maxResizeConstraints","isWest","isNorth","shape","snapLocation","get","id","width","height","test","indexOf"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/grid-snapping/GridSnapping.js"],"sourcesContent":["import {\r\n  setSnapped,\r\n  isSnapped\r\n} from '../snapping/SnapUtil';\r\n\r\nimport { isCmd } from '../keyboard/KeyboardUtil';\r\n\r\nimport {\r\n  assign,\r\n  isNumber\r\n} from 'min-dash';\r\n\r\nimport {\r\n  SPACING,\r\n  quantize\r\n} from './GridUtil';\r\n\r\nvar LOWER_PRIORITY = 1200;\r\nvar LOW_PRIORITY = 800;\r\n\r\n/**\r\n * Basic grid snapping that covers connecting, creating, moving, resizing shapes, moving bendpoints\r\n * and connection segments.\r\n */\r\nexport default function GridSnapping(elementRegistry, eventBus, config) {\r\n\r\n  var active = !config || config.active !== false;\r\n\r\n  this._eventBus = eventBus;\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('diagram.init', LOW_PRIORITY, function() {\r\n    self.setActive(active);\r\n  });\r\n\r\n  eventBus.on([\r\n    'create.move',\r\n    'create.end',\r\n    'bendpoint.move.move',\r\n    'bendpoint.move.end',\r\n    'connect.move',\r\n    'connect.end',\r\n    'connectionSegment.move.move',\r\n    'connectionSegment.move.end',\r\n    'resize.move',\r\n    'resize.end',\r\n    'shape.move.move',\r\n    'shape.move.end'\r\n  ], LOWER_PRIORITY, function(event) {\r\n    var originalEvent = event.originalEvent;\r\n\r\n    if (!self.active || (originalEvent && isCmd(originalEvent))) {\r\n      return;\r\n    }\r\n\r\n    var context = event.context,\r\n        gridSnappingContext = context.gridSnappingContext;\r\n\r\n    if (!gridSnappingContext) {\r\n      gridSnappingContext = context.gridSnappingContext = {};\r\n    }\r\n\r\n    [ 'x', 'y' ].forEach(function(axis) {\r\n      var options = {};\r\n\r\n      // allow snapping with offset\r\n      var snapOffset = getSnapOffset(event, axis, elementRegistry);\r\n\r\n      if (snapOffset) {\r\n        options.offset = snapOffset;\r\n      }\r\n\r\n      // allow snapping with min and max\r\n      var snapConstraints = getSnapConstraints(event, axis);\r\n\r\n      if (snapConstraints) {\r\n        assign(options, snapConstraints);\r\n      }\r\n\r\n      if (!isSnapped(event, axis)) {\r\n        self.snapEvent(event, axis, options);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Snap an events x or y with optional min, max and offset.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\r\nGridSnapping.prototype.snapEvent = function(event, axis, options) {\r\n  var snappedValue = this.snapValue(event[ axis ], options);\r\n\r\n  setSnapped(event, axis, snappedValue);\r\n};\r\n\r\n/**\r\n * Expose grid spacing for third parties (i.e. extensions).\r\n *\r\n * @return {number} spacing of grid dots\r\n */\r\nGridSnapping.prototype.getGridSpacing = function() {\r\n  return SPACING;\r\n};\r\n\r\n/**\r\n * Snap value with optional min, max and offset.\r\n *\r\n * @param {number} value\r\n * @param {Object} options\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\r\nGridSnapping.prototype.snapValue = function(value, options) {\r\n  var offset = 0;\r\n\r\n  if (options && options.offset) {\r\n    offset = options.offset;\r\n  }\r\n\r\n  value += offset;\r\n\r\n  value = quantize(value, SPACING);\r\n\r\n  var min, max;\r\n\r\n  if (options && options.min) {\r\n    min = options.min;\r\n\r\n    if (isNumber(min)) {\r\n      min = quantize(min + offset, SPACING, 'ceil');\r\n\r\n      value = Math.max(value, min);\r\n    }\r\n  }\r\n\r\n  if (options && options.max) {\r\n    max = options.max;\r\n\r\n    if (isNumber(max)) {\r\n      max = quantize(max + offset, SPACING, 'floor');\r\n\r\n      value = Math.min(value, max);\r\n    }\r\n  }\r\n\r\n  value -= offset;\r\n\r\n  return value;\r\n};\r\n\r\nGridSnapping.prototype.isActive = function() {\r\n  return this.active;\r\n};\r\n\r\nGridSnapping.prototype.setActive = function(active) {\r\n  this.active = active;\r\n\r\n  this._eventBus.fire('gridSnapping.toggle', { active: active });\r\n};\r\n\r\nGridSnapping.prototype.toggleActive = function() {\r\n  this.setActive(!this.active);\r\n};\r\n\r\nGridSnapping.$inject = [\r\n  'elementRegistry',\r\n  'eventBus',\r\n  'config.gridSnapping'\r\n];\r\n\r\n// helpers //////////\r\n\r\n/**\r\n * Get minimum and maximum snap constraints.\r\n * Constraints are cached.\r\n *\r\n * @param {Object} event\r\n * @param {Object} event.context\r\n * @param {string} axis\r\n *\r\n * @returns {boolean|Object}\r\n */\r\nfunction getSnapConstraints(event, axis) {\r\n  var context = event.context,\r\n      createConstraints = context.createConstraints,\r\n      resizeConstraints = context.resizeConstraints || {},\r\n      gridSnappingContext = context.gridSnappingContext,\r\n      snapConstraints = gridSnappingContext.snapConstraints;\r\n\r\n  // cache snap constraints\r\n  if (snapConstraints && snapConstraints[ axis ]) {\r\n    return snapConstraints[ axis ];\r\n  }\r\n\r\n  if (!snapConstraints) {\r\n    snapConstraints = gridSnappingContext.snapConstraints = {};\r\n  }\r\n\r\n  if (!snapConstraints[ axis ]) {\r\n    snapConstraints[ axis ] = {};\r\n  }\r\n\r\n  var direction = context.direction;\r\n\r\n  // create\r\n  if (createConstraints) {\r\n    if (isHorizontal(axis)) {\r\n      snapConstraints.x.min = createConstraints.left;\r\n      snapConstraints.x.max = createConstraints.right;\r\n    } else {\r\n      snapConstraints.y.min = createConstraints.top;\r\n      snapConstraints.y.max = createConstraints.bottom;\r\n    }\r\n  }\r\n\r\n  // resize\r\n  var minResizeConstraints = resizeConstraints.min,\r\n      maxResizeConstraints = resizeConstraints.max;\r\n\r\n  if (minResizeConstraints) {\r\n    if (isHorizontal(axis)) {\r\n\r\n      if (isWest(direction)) {\r\n        snapConstraints.x.max = minResizeConstraints.left;\r\n      } else {\r\n        snapConstraints.x.min = minResizeConstraints.right;\r\n      }\r\n\r\n    } else {\r\n\r\n      if (isNorth(direction)) {\r\n        snapConstraints.y.max = minResizeConstraints.top;\r\n      } else {\r\n        snapConstraints.y.min = minResizeConstraints.bottom;\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  if (maxResizeConstraints) {\r\n    if (isHorizontal(axis)) {\r\n\r\n      if (isWest(direction)) {\r\n        snapConstraints.x.min = maxResizeConstraints.left;\r\n      } else {\r\n        snapConstraints.x.max = maxResizeConstraints.right;\r\n      }\r\n\r\n    } else {\r\n\r\n      if (isNorth(direction)) {\r\n        snapConstraints.y.min = maxResizeConstraints.top;\r\n      } else {\r\n        snapConstraints.y.max = maxResizeConstraints.bottom;\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  return snapConstraints[ axis ];\r\n}\r\n\r\n/**\r\n * Get snap offset.\r\n * Offset is cached.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {ElementRegistry} elementRegistry\r\n *\r\n * @returns {number}\r\n */\r\nfunction getSnapOffset(event, axis, elementRegistry) {\r\n  var context = event.context,\r\n      shape = event.shape,\r\n      gridSnappingContext = context.gridSnappingContext,\r\n      snapLocation = gridSnappingContext.snapLocation,\r\n      snapOffset = gridSnappingContext.snapOffset;\r\n\r\n  // cache snap offset\r\n  if (snapOffset && isNumber(snapOffset[ axis ])) {\r\n    return snapOffset[ axis ];\r\n  }\r\n\r\n  if (!snapOffset) {\r\n    snapOffset = gridSnappingContext.snapOffset = {};\r\n  }\r\n\r\n  if (!isNumber(snapOffset[ axis ])) {\r\n    snapOffset[ axis ] = 0;\r\n  }\r\n\r\n  if (!shape) {\r\n    return snapOffset[ axis ];\r\n  }\r\n\r\n  if (!elementRegistry.get(shape.id)) {\r\n\r\n    if (isHorizontal(axis)) {\r\n      snapOffset[ axis ] += shape[ axis ] + shape.width / 2;\r\n    } else {\r\n      snapOffset[ axis ] += shape[ axis ] + shape.height / 2;\r\n    }\r\n  }\r\n\r\n  if (!snapLocation) {\r\n    return snapOffset[ axis ];\r\n  }\r\n\r\n  if (axis === 'x') {\r\n    if (/left/.test(snapLocation)) {\r\n      snapOffset[ axis ] -= shape.width / 2;\r\n    } else if (/right/.test(snapLocation)) {\r\n      snapOffset[ axis ] += shape.width / 2;\r\n    }\r\n  } else {\r\n    if (/top/.test(snapLocation)) {\r\n      snapOffset[ axis ] -= shape.height / 2;\r\n    } else if (/bottom/.test(snapLocation)) {\r\n      snapOffset[ axis ] += shape.height / 2;\r\n    }\r\n  }\r\n\r\n  return snapOffset[ axis ];\r\n}\r\n\r\nfunction isHorizontal(axis) {\r\n  return axis === 'x';\r\n}\r\n\r\nfunction isNorth(direction) {\r\n  return direction.indexOf('n') !== -1;\r\n}\r\n\r\nfunction isWest(direction) {\r\n  return direction.indexOf('w') !== -1;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}