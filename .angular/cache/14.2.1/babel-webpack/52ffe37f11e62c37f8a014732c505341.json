{"ast":null,"code":"import { pick, assign } from 'min-dash';\nimport { resizeBounds, ensureConstraints, computeChildrenBBox, getMinResizeBounds } from './ResizeUtil';\nimport { asTRBL, getMid, roundBounds } from '../../layout/LayoutUtil';\nvar DEFAULT_MIN_WIDTH = 10;\n/**\n * A component that provides resizing of shapes on the canvas.\n *\n * The following components are part of shape resize:\n *\n *  * adding resize handles,\n *  * creating a visual during resize\n *  * checking resize rules\n *  * committing a change once finished\n *\n *\n * ## Customizing\n *\n * It's possible to customize the resizing behaviour by intercepting 'resize.start'\n * and providing the following parameters through the 'context':\n *\n *   * minDimensions ({ width, height }): minimum shape dimensions\n *\n *   * childrenBoxPadding ({ left, top, bottom, right } || number):\n *     gap between the minimum bounding box and the container\n *\n * f.ex:\n *\n * ```javascript\n * eventBus.on('resize.start', 1500, function(event) {\n *   var context = event.context,\n *\n *  context.minDimensions = { width: 140, height: 120 };\n *\n *  // Passing general padding\n *  context.childrenBoxPadding = 30;\n *\n *  // Passing padding to a specific side\n *  context.childrenBoxPadding.left = 20;\n * });\n * ```\n */\n\nexport default function Resize(eventBus, rules, modeling, dragging) {\n  this._dragging = dragging;\n  this._rules = rules;\n  var self = this;\n  /**\n   * Handle resize move by specified delta.\n   *\n   * @param {Object} context\n   * @param {Point} delta\n   */\n\n  function handleMove(context, delta) {\n    var shape = context.shape,\n        direction = context.direction,\n        resizeConstraints = context.resizeConstraints,\n        newBounds;\n    context.delta = delta;\n    newBounds = resizeBounds(shape, direction, delta); // ensure constraints during resize\n\n    context.newBounds = ensureConstraints(newBounds, resizeConstraints); // update + cache executable state\n\n    context.canExecute = self.canResize(context);\n  }\n  /**\n   * Handle resize start.\n   *\n   * @param  {Object} context\n   */\n\n\n  function handleStart(context) {\n    var resizeConstraints = context.resizeConstraints,\n        // evaluate minBounds for backwards compatibility\n    minBounds = context.minBounds;\n\n    if (resizeConstraints !== undefined) {\n      return;\n    }\n\n    if (minBounds === undefined) {\n      minBounds = self.computeMinResizeBox(context);\n    }\n\n    context.resizeConstraints = {\n      min: asTRBL(minBounds)\n    };\n  }\n  /**\n   * Handle resize end.\n   *\n   * @param  {Object} context\n   */\n\n\n  function handleEnd(context) {\n    var shape = context.shape,\n        canExecute = context.canExecute,\n        newBounds = context.newBounds;\n\n    if (canExecute) {\n      // ensure we have actual pixel values for new bounds\n      // (important when zoom level was > 1 during move)\n      newBounds = roundBounds(newBounds);\n\n      if (!boundsChanged(shape, newBounds)) {\n        // no resize necessary\n        return;\n      } // perform the actual resize\n\n\n      modeling.resizeShape(shape, newBounds);\n    }\n  }\n\n  eventBus.on('resize.start', function (event) {\n    handleStart(event.context);\n  });\n  eventBus.on('resize.move', function (event) {\n    var delta = {\n      x: event.dx,\n      y: event.dy\n    };\n    handleMove(event.context, delta);\n  });\n  eventBus.on('resize.end', function (event) {\n    handleEnd(event.context);\n  });\n}\n\nResize.prototype.canResize = function (context) {\n  var rules = this._rules;\n  var ctx = pick(context, ['newBounds', 'shape', 'delta', 'direction']);\n  return rules.allowed('shape.resize', ctx);\n};\n/**\n * Activate a resize operation.\n *\n * You may specify additional contextual information and must specify a\n * resize direction during activation of the resize event.\n *\n * @param {MouseEvent} event\n * @param {djs.model.Shape} shape\n * @param {Object|string} contextOrDirection\n */\n\n\nResize.prototype.activate = function (event, shape, contextOrDirection) {\n  var dragging = this._dragging,\n      context,\n      direction;\n\n  if (typeof contextOrDirection === 'string') {\n    contextOrDirection = {\n      direction: contextOrDirection\n    };\n  }\n\n  context = assign({\n    shape: shape\n  }, contextOrDirection);\n  direction = context.direction;\n\n  if (!direction) {\n    throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)');\n  }\n\n  dragging.init(event, getReferencePoint(shape, direction), 'resize', {\n    autoActivate: true,\n    cursor: getCursor(direction),\n    data: {\n      shape: shape,\n      context: context\n    }\n  });\n};\n\nResize.prototype.computeMinResizeBox = function (context) {\n  var shape = context.shape,\n      direction = context.direction,\n      minDimensions,\n      childrenBounds;\n  minDimensions = context.minDimensions || {\n    width: DEFAULT_MIN_WIDTH,\n    height: DEFAULT_MIN_WIDTH\n  }; // get children bounds\n\n  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding); // get correct minimum bounds from given resize direction\n  // basically ensures that the minBounds is max(childrenBounds, minDimensions)\n\n  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);\n};\n\nResize.$inject = ['eventBus', 'rules', 'modeling', 'dragging']; // helpers //////////\n\nfunction boundsChanged(shape, newBounds) {\n  return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;\n}\n\nexport function getReferencePoint(shape, direction) {\n  var mid = getMid(shape),\n      trbl = asTRBL(shape);\n  var referencePoint = {\n    x: mid.x,\n    y: mid.y\n  };\n\n  if (direction.indexOf('n') !== -1) {\n    referencePoint.y = trbl.top;\n  } else if (direction.indexOf('s') !== -1) {\n    referencePoint.y = trbl.bottom;\n  }\n\n  if (direction.indexOf('e') !== -1) {\n    referencePoint.x = trbl.right;\n  } else if (direction.indexOf('w') !== -1) {\n    referencePoint.x = trbl.left;\n  }\n\n  return referencePoint;\n}\n\nfunction getCursor(direction) {\n  var prefix = 'resize-';\n\n  if (direction === 'n' || direction === 's') {\n    return prefix + 'ns';\n  } else if (direction === 'e' || direction === 'w') {\n    return prefix + 'ew';\n  } else if (direction === 'nw' || direction === 'se') {\n    return prefix + 'nwse';\n  } else {\n    return prefix + 'nesw';\n  }\n}","map":{"version":3,"names":["pick","assign","resizeBounds","ensureConstraints","computeChildrenBBox","getMinResizeBounds","asTRBL","getMid","roundBounds","DEFAULT_MIN_WIDTH","Resize","eventBus","rules","modeling","dragging","_dragging","_rules","self","handleMove","context","delta","shape","direction","resizeConstraints","newBounds","canExecute","canResize","handleStart","minBounds","undefined","computeMinResizeBox","min","handleEnd","boundsChanged","resizeShape","on","event","x","dx","y","dy","prototype","ctx","allowed","activate","contextOrDirection","Error","init","getReferencePoint","autoActivate","cursor","getCursor","data","minDimensions","childrenBounds","width","height","childrenBoxPadding","$inject","mid","trbl","referencePoint","indexOf","top","bottom","right","left","prefix"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/resize/Resize.js"],"sourcesContent":["import {\n  pick,\n  assign\n} from 'min-dash';\n\nimport {\n  resizeBounds,\n  ensureConstraints,\n  computeChildrenBBox,\n  getMinResizeBounds\n} from './ResizeUtil';\n\nimport {\n  asTRBL,\n  getMid,\n  roundBounds\n} from '../../layout/LayoutUtil';\n\nvar DEFAULT_MIN_WIDTH = 10;\n\n\n/**\n * A component that provides resizing of shapes on the canvas.\n *\n * The following components are part of shape resize:\n *\n *  * adding resize handles,\n *  * creating a visual during resize\n *  * checking resize rules\n *  * committing a change once finished\n *\n *\n * ## Customizing\n *\n * It's possible to customize the resizing behaviour by intercepting 'resize.start'\n * and providing the following parameters through the 'context':\n *\n *   * minDimensions ({ width, height }): minimum shape dimensions\n *\n *   * childrenBoxPadding ({ left, top, bottom, right } || number):\n *     gap between the minimum bounding box and the container\n *\n * f.ex:\n *\n * ```javascript\n * eventBus.on('resize.start', 1500, function(event) {\n *   var context = event.context,\n *\n *  context.minDimensions = { width: 140, height: 120 };\n *\n *  // Passing general padding\n *  context.childrenBoxPadding = 30;\n *\n *  // Passing padding to a specific side\n *  context.childrenBoxPadding.left = 20;\n * });\n * ```\n */\nexport default function Resize(eventBus, rules, modeling, dragging) {\n\n  this._dragging = dragging;\n  this._rules = rules;\n\n  var self = this;\n\n\n  /**\n   * Handle resize move by specified delta.\n   *\n   * @param {Object} context\n   * @param {Point} delta\n   */\n  function handleMove(context, delta) {\n\n    var shape = context.shape,\n        direction = context.direction,\n        resizeConstraints = context.resizeConstraints,\n        newBounds;\n\n    context.delta = delta;\n\n    newBounds = resizeBounds(shape, direction, delta);\n\n    // ensure constraints during resize\n    context.newBounds = ensureConstraints(newBounds, resizeConstraints);\n\n    // update + cache executable state\n    context.canExecute = self.canResize(context);\n  }\n\n  /**\n   * Handle resize start.\n   *\n   * @param  {Object} context\n   */\n  function handleStart(context) {\n\n    var resizeConstraints = context.resizeConstraints,\n\n        // evaluate minBounds for backwards compatibility\n        minBounds = context.minBounds;\n\n    if (resizeConstraints !== undefined) {\n      return;\n    }\n\n    if (minBounds === undefined) {\n      minBounds = self.computeMinResizeBox(context);\n    }\n\n    context.resizeConstraints = {\n      min: asTRBL(minBounds)\n    };\n  }\n\n  /**\n   * Handle resize end.\n   *\n   * @param  {Object} context\n   */\n  function handleEnd(context) {\n    var shape = context.shape,\n        canExecute = context.canExecute,\n        newBounds = context.newBounds;\n\n    if (canExecute) {\n\n      // ensure we have actual pixel values for new bounds\n      // (important when zoom level was > 1 during move)\n      newBounds = roundBounds(newBounds);\n\n      if (!boundsChanged(shape, newBounds)) {\n\n        // no resize necessary\n        return;\n      }\n\n      // perform the actual resize\n      modeling.resizeShape(shape, newBounds);\n    }\n  }\n\n\n  eventBus.on('resize.start', function(event) {\n    handleStart(event.context);\n  });\n\n  eventBus.on('resize.move', function(event) {\n    var delta = {\n      x: event.dx,\n      y: event.dy\n    };\n\n    handleMove(event.context, delta);\n  });\n\n  eventBus.on('resize.end', function(event) {\n    handleEnd(event.context);\n  });\n\n}\n\n\nResize.prototype.canResize = function(context) {\n  var rules = this._rules;\n\n  var ctx = pick(context, [ 'newBounds', 'shape', 'delta', 'direction' ]);\n\n  return rules.allowed('shape.resize', ctx);\n};\n\n/**\n * Activate a resize operation.\n *\n * You may specify additional contextual information and must specify a\n * resize direction during activation of the resize event.\n *\n * @param {MouseEvent} event\n * @param {djs.model.Shape} shape\n * @param {Object|string} contextOrDirection\n */\nResize.prototype.activate = function(event, shape, contextOrDirection) {\n  var dragging = this._dragging,\n      context,\n      direction;\n\n  if (typeof contextOrDirection === 'string') {\n    contextOrDirection = {\n      direction: contextOrDirection\n    };\n  }\n\n  context = assign({ shape: shape }, contextOrDirection);\n\n  direction = context.direction;\n\n  if (!direction) {\n    throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)');\n  }\n\n  dragging.init(event, getReferencePoint(shape, direction), 'resize', {\n    autoActivate: true,\n    cursor: getCursor(direction),\n    data: {\n      shape: shape,\n      context: context\n    }\n  });\n};\n\nResize.prototype.computeMinResizeBox = function(context) {\n  var shape = context.shape,\n      direction = context.direction,\n      minDimensions,\n      childrenBounds;\n\n  minDimensions = context.minDimensions || {\n    width: DEFAULT_MIN_WIDTH,\n    height: DEFAULT_MIN_WIDTH\n  };\n\n  // get children bounds\n  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);\n\n  // get correct minimum bounds from given resize direction\n  // basically ensures that the minBounds is max(childrenBounds, minDimensions)\n  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);\n};\n\n\nResize.$inject = [\n  'eventBus',\n  'rules',\n  'modeling',\n  'dragging'\n];\n\n// helpers //////////\n\nfunction boundsChanged(shape, newBounds) {\n  return shape.x !== newBounds.x ||\n    shape.y !== newBounds.y ||\n    shape.width !== newBounds.width ||\n    shape.height !== newBounds.height;\n}\n\nexport function getReferencePoint(shape, direction) {\n  var mid = getMid(shape),\n      trbl = asTRBL(shape);\n\n  var referencePoint = {\n    x: mid.x,\n    y: mid.y\n  };\n\n  if (direction.indexOf('n') !== -1) {\n    referencePoint.y = trbl.top;\n  } else if (direction.indexOf('s') !== -1) {\n    referencePoint.y = trbl.bottom;\n  }\n\n  if (direction.indexOf('e') !== -1) {\n    referencePoint.x = trbl.right;\n  } else if (direction.indexOf('w') !== -1) {\n    referencePoint.x = trbl.left;\n  }\n\n  return referencePoint;\n}\n\nfunction getCursor(direction) {\n  var prefix = 'resize-';\n\n  if (direction === 'n' || direction === 's') {\n    return prefix + 'ns';\n  } else if (direction === 'e' || direction === 'w') {\n    return prefix + 'ew';\n  } else if (direction === 'nw' || direction === 'se') {\n    return prefix + 'nwse';\n  } else {\n    return prefix + 'nesw';\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}