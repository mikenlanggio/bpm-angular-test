{"ast":null,"code":"import inherits from 'inherits-browser';\nimport { getBBox as getBoundingBox } from '../../util/Elements';\nimport { asTRBL, asBounds } from '../../layout/LayoutUtil';\nimport { assign, flatten, find, forEach, groupBy, isArray, matchPattern, pick, values } from 'min-dash';\nimport CommandInterceptor from '../../command/CommandInterceptor';\n/**\n * An auto resize component that takes care of expanding a parent element\n * if child elements are created or moved close the parents edge.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\n\nexport default function AutoResize(eventBus, elementRegistry, modeling, rules) {\n  CommandInterceptor.call(this, eventBus);\n  this._elementRegistry = elementRegistry;\n  this._modeling = modeling;\n  this._rules = rules;\n  var self = this;\n  this.postExecuted(['shape.create'], function (event) {\n    var context = event.context,\n        hints = context.hints || {},\n        shape = context.shape,\n        parent = context.parent || context.newParent;\n\n    if (hints.autoResize === false) {\n      return;\n    }\n\n    self._expand([shape], parent);\n  });\n  this.postExecuted(['elements.move'], function (event) {\n    var context = event.context,\n        elements = flatten(values(context.closure.topLevel)),\n        hints = context.hints;\n    var autoResize = hints ? hints.autoResize : true;\n\n    if (autoResize === false) {\n      return;\n    }\n\n    var expandings = groupBy(elements, function (element) {\n      return element.parent.id;\n    });\n    forEach(expandings, function (elements, parentId) {\n      // optionally filter elements to be considered when resizing\n      if (isArray(autoResize)) {\n        elements = elements.filter(function (element) {\n          return find(autoResize, matchPattern({\n            id: element.id\n          }));\n        });\n      }\n\n      self._expand(elements, parentId);\n    });\n  });\n  this.postExecuted(['shape.toggleCollapse'], function (event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape;\n\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n\n    if (shape.collapsed) {\n      return;\n    }\n\n    self._expand(shape.children || [], shape);\n  });\n  this.postExecuted(['shape.resize'], function (event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        parent = shape.parent;\n\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n\n    if (parent) {\n      self._expand([shape], parent);\n    }\n  });\n}\nAutoResize.$inject = ['eventBus', 'elementRegistry', 'modeling', 'rules'];\ninherits(AutoResize, CommandInterceptor);\n/**\n * Calculate the new bounds of the target shape, given\n * a number of elements have been moved or added into the parent.\n *\n * This method considers the current size, the added elements as well as\n * the provided padding for the new bounds.\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape} target\n */\n\nAutoResize.prototype._getOptimalBounds = function (elements, target) {\n  var offset = this.getOffset(target),\n      padding = this.getPadding(target);\n  var elementsTrbl = asTRBL(getBoundingBox(elements)),\n      targetTrbl = asTRBL(target);\n  var newTrbl = {};\n\n  if (elementsTrbl.top - targetTrbl.top < padding.top) {\n    newTrbl.top = elementsTrbl.top - offset.top;\n  }\n\n  if (elementsTrbl.left - targetTrbl.left < padding.left) {\n    newTrbl.left = elementsTrbl.left - offset.left;\n  }\n\n  if (targetTrbl.right - elementsTrbl.right < padding.right) {\n    newTrbl.right = elementsTrbl.right + offset.right;\n  }\n\n  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {\n    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;\n  }\n\n  return asBounds(assign({}, targetTrbl, newTrbl));\n};\n/**\n * Expand the target shape respecting rules, offset and padding\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape|string} target|targetId\n */\n\n\nAutoResize.prototype._expand = function (elements, target) {\n  if (typeof target === 'string') {\n    target = this._elementRegistry.get(target);\n  }\n\n  var allowed = this._rules.allowed('element.autoResize', {\n    elements: elements,\n    target: target\n  });\n\n  if (!allowed) {\n    return;\n  } // calculate the new bounds\n\n\n  var newBounds = this._getOptimalBounds(elements, target);\n\n  if (!boundsChanged(newBounds, target)) {\n    return;\n  }\n\n  var resizeDirections = getResizeDirections(pick(target, ['x', 'y', 'width', 'height']), newBounds); // resize the parent shape\n\n  this.resize(target, newBounds, {\n    autoResize: resizeDirections\n  });\n  var parent = target.parent; // recursively expand parent elements\n\n  if (parent) {\n    this._expand([target], parent);\n  }\n};\n/**\n * Get the amount to expand the given shape in each direction.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {TRBL}\n */\n\n\nAutoResize.prototype.getOffset = function (shape) {\n  return {\n    top: 60,\n    bottom: 60,\n    left: 100,\n    right: 100\n  };\n};\n/**\n * Get the activation threshold for each side for which\n * resize triggers.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {TRBL}\n */\n\n\nAutoResize.prototype.getPadding = function (shape) {\n  return {\n    top: 2,\n    bottom: 2,\n    left: 15,\n    right: 15\n  };\n};\n/**\n * Perform the actual resize operation.\n *\n * @param {djs.model.Shape} shape\n * @param {Bounds} newBounds\n * @param {Object} [hints]\n * @param {string} [hints.autoResize]\n */\n\n\nAutoResize.prototype.resize = function (shape, newBounds, hints) {\n  this._modeling.resizeShape(shape, newBounds, null, hints);\n};\n\nfunction boundsChanged(newBounds, oldBounds) {\n  return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;\n}\n/**\n * Get directions of resize as {n|w|s|e} e.g. \"nw\".\n *\n * @param {Bounds} oldBounds\n * @param {Bounds} newBounds\n *\n * @returns {string} Resize directions as {n|w|s|e}.\n */\n\n\nfunction getResizeDirections(oldBounds, newBounds) {\n  var directions = '';\n  oldBounds = asTRBL(oldBounds);\n  newBounds = asTRBL(newBounds);\n\n  if (oldBounds.top > newBounds.top) {\n    directions = directions.concat('n');\n  }\n\n  if (oldBounds.right < newBounds.right) {\n    directions = directions.concat('w');\n  }\n\n  if (oldBounds.bottom < newBounds.bottom) {\n    directions = directions.concat('s');\n  }\n\n  if (oldBounds.left > newBounds.left) {\n    directions = directions.concat('e');\n  }\n\n  return directions;\n}","map":{"version":3,"names":["inherits","getBBox","getBoundingBox","asTRBL","asBounds","assign","flatten","find","forEach","groupBy","isArray","matchPattern","pick","values","CommandInterceptor","AutoResize","eventBus","elementRegistry","modeling","rules","call","_elementRegistry","_modeling","_rules","self","postExecuted","event","context","hints","shape","parent","newParent","autoResize","_expand","elements","closure","topLevel","expandings","element","id","parentId","filter","collapsed","children","$inject","prototype","_getOptimalBounds","target","offset","getOffset","padding","getPadding","elementsTrbl","targetTrbl","newTrbl","top","left","right","bottom","get","allowed","newBounds","boundsChanged","resizeDirections","getResizeDirections","resize","resizeShape","oldBounds","x","y","width","height","directions","concat"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/auto-resize/AutoResize.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport { getBBox as getBoundingBox } from '../../util/Elements';\n\nimport {\n  asTRBL,\n  asBounds\n} from '../../layout/LayoutUtil';\n\nimport {\n  assign,\n  flatten,\n  find,\n  forEach,\n  groupBy,\n  isArray,\n  matchPattern,\n  pick,\n  values\n} from 'min-dash';\n\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n\n/**\n * An auto resize component that takes care of expanding a parent element\n * if child elements are created or moved close the parents edge.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function AutoResize(eventBus, elementRegistry, modeling, rules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._elementRegistry = elementRegistry;\n  this._modeling = modeling;\n  this._rules = rules;\n\n  var self = this;\n\n  this.postExecuted([ 'shape.create' ], function(event) {\n    var context = event.context,\n        hints = context.hints || {},\n        shape = context.shape,\n        parent = context.parent || context.newParent;\n\n    if (hints.autoResize === false) {\n      return;\n    }\n\n    self._expand([ shape ], parent);\n  });\n\n  this.postExecuted([ 'elements.move' ], function(event) {\n    var context = event.context,\n        elements = flatten(values(context.closure.topLevel)),\n        hints = context.hints;\n\n    var autoResize = hints ? hints.autoResize : true;\n\n    if (autoResize === false) {\n      return;\n    }\n\n    var expandings = groupBy(elements, function(element) {\n      return element.parent.id;\n    });\n\n    forEach(expandings, function(elements, parentId) {\n\n      // optionally filter elements to be considered when resizing\n      if (isArray(autoResize)) {\n        elements = elements.filter(function(element) {\n          return find(autoResize, matchPattern({ id: element.id }));\n        });\n      }\n\n      self._expand(elements, parentId);\n    });\n  });\n\n  this.postExecuted([ 'shape.toggleCollapse' ], function(event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape;\n\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n\n    if (shape.collapsed) {\n      return;\n    }\n\n    self._expand(shape.children || [], shape);\n  });\n\n  this.postExecuted([ 'shape.resize' ], function(event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        parent = shape.parent;\n\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n\n    if (parent) {\n      self._expand([ shape ], parent);\n    }\n  });\n\n}\n\nAutoResize.$inject = [\n  'eventBus',\n  'elementRegistry',\n  'modeling',\n  'rules'\n];\n\ninherits(AutoResize, CommandInterceptor);\n\n\n/**\n * Calculate the new bounds of the target shape, given\n * a number of elements have been moved or added into the parent.\n *\n * This method considers the current size, the added elements as well as\n * the provided padding for the new bounds.\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape} target\n */\nAutoResize.prototype._getOptimalBounds = function(elements, target) {\n\n  var offset = this.getOffset(target),\n      padding = this.getPadding(target);\n\n  var elementsTrbl = asTRBL(getBoundingBox(elements)),\n      targetTrbl = asTRBL(target);\n\n  var newTrbl = {};\n\n  if (elementsTrbl.top - targetTrbl.top < padding.top) {\n    newTrbl.top = elementsTrbl.top - offset.top;\n  }\n\n  if (elementsTrbl.left - targetTrbl.left < padding.left) {\n    newTrbl.left = elementsTrbl.left - offset.left;\n  }\n\n  if (targetTrbl.right - elementsTrbl.right < padding.right) {\n    newTrbl.right = elementsTrbl.right + offset.right;\n  }\n\n  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {\n    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;\n  }\n\n  return asBounds(assign({}, targetTrbl, newTrbl));\n};\n\n\n/**\n * Expand the target shape respecting rules, offset and padding\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape|string} target|targetId\n */\nAutoResize.prototype._expand = function(elements, target) {\n\n  if (typeof target === 'string') {\n    target = this._elementRegistry.get(target);\n  }\n\n  var allowed = this._rules.allowed('element.autoResize', {\n    elements: elements,\n    target: target\n  });\n\n  if (!allowed) {\n    return;\n  }\n\n  // calculate the new bounds\n  var newBounds = this._getOptimalBounds(elements, target);\n\n  if (!boundsChanged(newBounds, target)) {\n    return;\n  }\n\n  var resizeDirections = getResizeDirections(pick(target, [ 'x', 'y', 'width', 'height' ]), newBounds);\n\n  // resize the parent shape\n  this.resize(target, newBounds, {\n    autoResize: resizeDirections\n  });\n\n  var parent = target.parent;\n\n  // recursively expand parent elements\n  if (parent) {\n    this._expand([ target ], parent);\n  }\n};\n\n\n/**\n * Get the amount to expand the given shape in each direction.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {TRBL}\n */\nAutoResize.prototype.getOffset = function(shape) {\n  return { top: 60, bottom: 60, left: 100, right: 100 };\n};\n\n\n/**\n * Get the activation threshold for each side for which\n * resize triggers.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {TRBL}\n */\nAutoResize.prototype.getPadding = function(shape) {\n  return { top: 2, bottom: 2, left: 15, right: 15 };\n};\n\n\n/**\n * Perform the actual resize operation.\n *\n * @param {djs.model.Shape} shape\n * @param {Bounds} newBounds\n * @param {Object} [hints]\n * @param {string} [hints.autoResize]\n */\nAutoResize.prototype.resize = function(shape, newBounds, hints) {\n  this._modeling.resizeShape(shape, newBounds, null, hints);\n};\n\n\nfunction boundsChanged(newBounds, oldBounds) {\n  return (\n    newBounds.x !== oldBounds.x ||\n    newBounds.y !== oldBounds.y ||\n    newBounds.width !== oldBounds.width ||\n    newBounds.height !== oldBounds.height\n  );\n}\n\n/**\n * Get directions of resize as {n|w|s|e} e.g. \"nw\".\n *\n * @param {Bounds} oldBounds\n * @param {Bounds} newBounds\n *\n * @returns {string} Resize directions as {n|w|s|e}.\n */\nfunction getResizeDirections(oldBounds, newBounds) {\n  var directions = '';\n\n  oldBounds = asTRBL(oldBounds);\n  newBounds = asTRBL(newBounds);\n\n  if (oldBounds.top > newBounds.top) {\n    directions = directions.concat('n');\n  }\n\n  if (oldBounds.right < newBounds.right) {\n    directions = directions.concat('w');\n  }\n\n  if (oldBounds.bottom < newBounds.bottom) {\n    directions = directions.concat('s');\n  }\n\n  if (oldBounds.left > newBounds.left) {\n    directions = directions.concat('e');\n  }\n\n  return directions;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}