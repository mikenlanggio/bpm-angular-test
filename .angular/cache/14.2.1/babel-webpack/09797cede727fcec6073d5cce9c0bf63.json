{"ast":null,"code":"import { pointDistance } from './Geometry';\nimport intersectPaths from 'path-intersection';\nvar round = Math.round,\n    max = Math.max;\n\nfunction circlePath(center, r) {\n  var x = center.x,\n      y = center.y;\n  return [['M', x, y], ['m', 0, -r], ['a', r, r, 0, 1, 1, 0, 2 * r], ['a', r, r, 0, 1, 1, 0, -2 * r], ['z']];\n}\n\nfunction linePath(points) {\n  var segments = [];\n  points.forEach(function (p, idx) {\n    segments.push([idx === 0 ? 'M' : 'L', p.x, p.y]);\n  });\n  return segments;\n}\n\nvar INTERSECTION_THRESHOLD = 10;\n\nfunction getBendpointIntersection(waypoints, reference) {\n  var i, w;\n\n  for (i = 0; w = waypoints[i]; i++) {\n    if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD) {\n      return {\n        point: waypoints[i],\n        bendpoint: true,\n        index: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction getPathIntersection(waypoints, reference) {\n  var intersections = intersectPaths(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));\n  var a = intersections[0],\n      b = intersections[intersections.length - 1],\n      idx;\n\n  if (!a) {\n    // no intersection\n    return null;\n  }\n\n  if (a !== b) {\n    if (a.segment2 !== b.segment2) {\n      // we use the bendpoint in between both segments\n      // as the intersection point\n      idx = max(a.segment2, b.segment2) - 1;\n      return {\n        point: waypoints[idx],\n        bendpoint: true,\n        index: idx\n      };\n    }\n\n    return {\n      point: {\n        x: round(a.x + b.x) / 2,\n        y: round(a.y + b.y) / 2\n      },\n      index: a.segment2\n    };\n  }\n\n  return {\n    point: {\n      x: round(a.x),\n      y: round(a.y)\n    },\n    index: a.segment2\n  };\n}\n/**\n * Returns the closest point on the connection towards a given reference point.\n *\n * @param  {Array<Point>} waypoints\n * @param  {Point} reference\n *\n * @return {Object} intersection data (segment, point)\n */\n\n\nexport function getApproxIntersection(waypoints, reference) {\n  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);\n}","map":{"version":3,"names":["pointDistance","intersectPaths","round","Math","max","circlePath","center","r","x","y","linePath","points","segments","forEach","p","idx","push","INTERSECTION_THRESHOLD","getBendpointIntersection","waypoints","reference","i","w","point","bendpoint","index","getPathIntersection","intersections","a","b","length","segment2","getApproxIntersection"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/util/LineIntersection.js"],"sourcesContent":["import {\n  pointDistance\n} from './Geometry';\n\nimport intersectPaths from 'path-intersection';\n\nvar round = Math.round,\n    max = Math.max;\n\n\nfunction circlePath(center, r) {\n  var x = center.x,\n      y = center.y;\n\n  return [\n    [ 'M', x, y ],\n    [ 'm', 0, -r ],\n    [ 'a', r, r, 0, 1, 1, 0, 2 * r ],\n    [ 'a', r, r, 0, 1, 1, 0, -2 * r ],\n    [ 'z' ]\n  ];\n}\n\nfunction linePath(points) {\n  var segments = [];\n\n  points.forEach(function(p, idx) {\n    segments.push([ idx === 0 ? 'M' : 'L', p.x, p.y ]);\n  });\n\n  return segments;\n}\n\n\nvar INTERSECTION_THRESHOLD = 10;\n\nfunction getBendpointIntersection(waypoints, reference) {\n\n  var i, w;\n\n  for (i = 0; (w = waypoints[i]); i++) {\n\n    if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD) {\n      return {\n        point: waypoints[i],\n        bendpoint: true,\n        index: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction getPathIntersection(waypoints, reference) {\n\n  var intersections = intersectPaths(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));\n\n  var a = intersections[0],\n      b = intersections[intersections.length - 1],\n      idx;\n\n  if (!a) {\n\n    // no intersection\n    return null;\n  }\n\n  if (a !== b) {\n\n    if (a.segment2 !== b.segment2) {\n\n      // we use the bendpoint in between both segments\n      // as the intersection point\n\n      idx = max(a.segment2, b.segment2) - 1;\n\n      return {\n        point: waypoints[idx],\n        bendpoint: true,\n        index: idx\n      };\n    }\n\n    return {\n      point: {\n        x: (round(a.x + b.x) / 2),\n        y: (round(a.y + b.y) / 2)\n      },\n      index: a.segment2\n    };\n  }\n\n  return {\n    point: {\n      x: round(a.x),\n      y: round(a.y)\n    },\n    index: a.segment2\n  };\n}\n\n/**\n * Returns the closest point on the connection towards a given reference point.\n *\n * @param  {Array<Point>} waypoints\n * @param  {Point} reference\n *\n * @return {Object} intersection data (segment, point)\n */\nexport function getApproxIntersection(waypoints, reference) {\n  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}