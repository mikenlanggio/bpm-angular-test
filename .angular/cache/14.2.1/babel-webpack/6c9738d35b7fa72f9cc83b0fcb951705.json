{"ast":null,"code":"var sqrt = Math.sqrt,\n    min = Math.min,\n    max = Math.max,\n    abs = Math.abs;\n/**\n * Calculate the square (power to two) of a number.\n *\n * @param {number} n\n *\n * @return {number}\n */\n\nfunction sq(n) {\n  return Math.pow(n, 2);\n}\n/**\n * Get distance between two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {number}\n */\n\n\nfunction getDistance(p1, p2) {\n  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));\n}\n/**\n * Return the attachment of the given point on the specified line.\n *\n * The attachment is either a bendpoint (attached to the given point)\n * or segment (attached to a location on a line segment) attachment:\n *\n * ```javascript\n * var pointAttachment = {\n *   type: 'bendpoint',\n *   bendpointIndex: 3,\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n *\n * var segmentAttachment = {\n *   type: 'segment',\n *   segmentIndex: 2,\n *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n * ```\n *\n * @param {Point} point\n * @param {Array<Point>} line\n *\n * @return {Object} attachment\n */\n\n\nexport function getAttachment(point, line) {\n  var idx = 0,\n      segmentStart,\n      segmentEnd,\n      segmentStartDistance,\n      segmentEndDistance,\n      attachmentPosition,\n      minDistance,\n      intersections,\n      attachment,\n      attachmentDistance,\n      closestAttachmentDistance,\n      closestAttachment;\n\n  for (idx = 0; idx < line.length - 1; idx++) {\n    segmentStart = line[idx];\n    segmentEnd = line[idx + 1];\n\n    if (pointsEqual(segmentStart, segmentEnd)) {\n      intersections = [segmentStart];\n    } else {\n      segmentStartDistance = getDistance(point, segmentStart);\n      segmentEndDistance = getDistance(point, segmentEnd);\n      minDistance = min(segmentStartDistance, segmentEndDistance);\n      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);\n    }\n\n    if (intersections.length < 1) {\n      throw new Error('expected between [1, 2] circle -> line intersections');\n    } // one intersection -> bendpoint attachment\n\n\n    if (intersections.length === 1) {\n      attachment = {\n        type: 'bendpoint',\n        position: intersections[0],\n        segmentIndex: idx,\n        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1\n      };\n    } // two intersections -> segment attachment\n\n\n    if (intersections.length === 2) {\n      attachmentPosition = mid(intersections[0], intersections[1]);\n      attachment = {\n        type: 'segment',\n        position: attachmentPosition,\n        segmentIndex: idx,\n        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)\n      };\n    }\n\n    attachmentDistance = getDistance(attachment.position, point);\n\n    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {\n      closestAttachment = attachment;\n      closestAttachmentDistance = attachmentDistance;\n    }\n  }\n\n  return closestAttachment;\n}\n/**\n * Gets the intersection between a circle and a line segment.\n *\n * @param {Point} s1 segment start\n * @param {Point} s2 segment end\n * @param {Point} cc circle center\n * @param {number} cr circle radius\n *\n * @return {Array<Point>} intersections\n */\n\nfunction getCircleSegmentIntersections(s1, s2, cc, cr) {\n  var baX = s2.x - s1.x;\n  var baY = s2.y - s1.y;\n  var caX = cc.x - s1.x;\n  var caY = cc.y - s1.y;\n  var a = baX * baX + baY * baY;\n  var bBy2 = baX * caX + baY * caY;\n  var c = caX * caX + caY * caY - cr * cr;\n  var pBy2 = bBy2 / a;\n  var q = c / a;\n  var disc = pBy2 * pBy2 - q; // check against negative value to work around\n  // negative, very close to zero results (-4e-15)\n  // being produced in some environments\n\n  if (disc < 0 && disc > -0.000001) {\n    disc = 0;\n  }\n\n  if (disc < 0) {\n    return [];\n  } // if disc == 0 ... dealt with later\n\n\n  var tmpSqrt = sqrt(disc);\n  var abScalingFactor1 = -pBy2 + tmpSqrt;\n  var abScalingFactor2 = -pBy2 - tmpSqrt;\n  var i1 = {\n    x: s1.x - baX * abScalingFactor1,\n    y: s1.y - baY * abScalingFactor1\n  };\n\n  if (disc === 0) {\n    // abScalingFactor1 == abScalingFactor2\n    return [i1];\n  }\n\n  var i2 = {\n    x: s1.x - baX * abScalingFactor2,\n    y: s1.y - baY * abScalingFactor2\n  }; // return only points on line segment\n\n  return [i1, i2].filter(function (p) {\n    return isPointInSegment(p, s1, s2);\n  });\n}\n\nfunction isPointInSegment(p, segmentStart, segmentEnd) {\n  return fenced(p.x, segmentStart.x, segmentEnd.x) && fenced(p.y, segmentStart.y, segmentEnd.y);\n}\n\nfunction fenced(n, rangeStart, rangeEnd) {\n  // use matching threshold to work around\n  // precision errors in intersection computation\n  return n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD && n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD;\n}\n/**\n * Calculate mid of two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Point}\n */\n\n\nfunction mid(p1, p2) {\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2\n  };\n}\n\nvar EQUAL_THRESHOLD = 0.1;\n\nfunction pointsEqual(p1, p2) {\n  return abs(p1.x - p2.x) <= EQUAL_THRESHOLD && abs(p1.y - p2.y) <= EQUAL_THRESHOLD;\n}","map":{"version":3,"names":["sqrt","Math","min","max","abs","sq","n","pow","getDistance","p1","p2","x","y","getAttachment","point","line","idx","segmentStart","segmentEnd","segmentStartDistance","segmentEndDistance","attachmentPosition","minDistance","intersections","attachment","attachmentDistance","closestAttachmentDistance","closestAttachment","length","pointsEqual","getCircleSegmentIntersections","Error","type","position","segmentIndex","bendpointIndex","mid","relativeLocation","s1","s2","cc","cr","baX","baY","caX","caY","a","bBy2","c","pBy2","q","disc","tmpSqrt","abScalingFactor1","abScalingFactor2","i1","i2","filter","p","isPointInSegment","fenced","rangeStart","rangeEnd","EQUAL_THRESHOLD"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/features/modeling/behavior/util/LineAttachmentUtil.js"],"sourcesContent":["var sqrt = Math.sqrt,\n    min = Math.min,\n    max = Math.max,\n    abs = Math.abs;\n\n/**\n * Calculate the square (power to two) of a number.\n *\n * @param {number} n\n *\n * @return {number}\n */\nfunction sq(n) {\n  return Math.pow(n, 2);\n}\n\n/**\n * Get distance between two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {number}\n */\nfunction getDistance(p1, p2) {\n  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));\n}\n\n/**\n * Return the attachment of the given point on the specified line.\n *\n * The attachment is either a bendpoint (attached to the given point)\n * or segment (attached to a location on a line segment) attachment:\n *\n * ```javascript\n * var pointAttachment = {\n *   type: 'bendpoint',\n *   bendpointIndex: 3,\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n *\n * var segmentAttachment = {\n *   type: 'segment',\n *   segmentIndex: 2,\n *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n * ```\n *\n * @param {Point} point\n * @param {Array<Point>} line\n *\n * @return {Object} attachment\n */\nexport function getAttachment(point, line) {\n\n  var idx = 0,\n      segmentStart,\n      segmentEnd,\n      segmentStartDistance,\n      segmentEndDistance,\n      attachmentPosition,\n      minDistance,\n      intersections,\n      attachment,\n      attachmentDistance,\n      closestAttachmentDistance,\n      closestAttachment;\n\n  for (idx = 0; idx < line.length - 1; idx++) {\n\n    segmentStart = line[idx];\n    segmentEnd = line[idx + 1];\n\n    if (pointsEqual(segmentStart, segmentEnd)) {\n      intersections = [ segmentStart ];\n    } else {\n      segmentStartDistance = getDistance(point, segmentStart);\n      segmentEndDistance = getDistance(point, segmentEnd);\n\n      minDistance = min(segmentStartDistance, segmentEndDistance);\n\n      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);\n    }\n\n    if (intersections.length < 1) {\n      throw new Error('expected between [1, 2] circle -> line intersections');\n    }\n\n    // one intersection -> bendpoint attachment\n    if (intersections.length === 1) {\n      attachment = {\n        type: 'bendpoint',\n        position: intersections[0],\n        segmentIndex: idx,\n        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1\n      };\n    }\n\n    // two intersections -> segment attachment\n    if (intersections.length === 2) {\n\n      attachmentPosition = mid(intersections[0], intersections[1]);\n\n      attachment = {\n        type: 'segment',\n        position: attachmentPosition,\n        segmentIndex: idx,\n        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)\n      };\n    }\n\n    attachmentDistance = getDistance(attachment.position, point);\n\n    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {\n      closestAttachment = attachment;\n      closestAttachmentDistance = attachmentDistance;\n    }\n  }\n\n  return closestAttachment;\n}\n\n/**\n * Gets the intersection between a circle and a line segment.\n *\n * @param {Point} s1 segment start\n * @param {Point} s2 segment end\n * @param {Point} cc circle center\n * @param {number} cr circle radius\n *\n * @return {Array<Point>} intersections\n */\nfunction getCircleSegmentIntersections(s1, s2, cc, cr) {\n\n  var baX = s2.x - s1.x;\n  var baY = s2.y - s1.y;\n  var caX = cc.x - s1.x;\n  var caY = cc.y - s1.y;\n\n  var a = baX * baX + baY * baY;\n  var bBy2 = baX * caX + baY * caY;\n  var c = caX * caX + caY * caY - cr * cr;\n\n  var pBy2 = bBy2 / a;\n  var q = c / a;\n\n  var disc = pBy2 * pBy2 - q;\n\n  // check against negative value to work around\n  // negative, very close to zero results (-4e-15)\n  // being produced in some environments\n  if (disc < 0 && disc > -0.000001) {\n    disc = 0;\n  }\n\n  if (disc < 0) {\n    return [];\n  }\n\n  // if disc == 0 ... dealt with later\n  var tmpSqrt = sqrt(disc);\n  var abScalingFactor1 = -pBy2 + tmpSqrt;\n  var abScalingFactor2 = -pBy2 - tmpSqrt;\n\n  var i1 = {\n    x: s1.x - baX * abScalingFactor1,\n    y: s1.y - baY * abScalingFactor1\n  };\n\n  if (disc === 0) { // abScalingFactor1 == abScalingFactor2\n    return [ i1 ];\n  }\n\n  var i2 = {\n    x: s1.x - baX * abScalingFactor2,\n    y: s1.y - baY * abScalingFactor2\n  };\n\n  // return only points on line segment\n  return [ i1, i2 ].filter(function(p) {\n    return isPointInSegment(p, s1, s2);\n  });\n}\n\n\nfunction isPointInSegment(p, segmentStart, segmentEnd) {\n  return (\n    fenced(p.x, segmentStart.x, segmentEnd.x) &&\n    fenced(p.y, segmentStart.y, segmentEnd.y)\n  );\n}\n\nfunction fenced(n, rangeStart, rangeEnd) {\n\n  // use matching threshold to work around\n  // precision errors in intersection computation\n\n  return (\n    n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD &&\n    n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD\n  );\n}\n\n/**\n * Calculate mid of two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Point}\n */\nfunction mid(p1, p2) {\n\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2\n  };\n}\n\nvar EQUAL_THRESHOLD = 0.1;\n\nfunction pointsEqual(p1, p2) {\n\n  return (\n    abs(p1.x - p2.x) <= EQUAL_THRESHOLD &&\n    abs(p1.y - p2.y) <= EQUAL_THRESHOLD\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}