{"ast":null,"code":"var CLASS_PATTERN = /^class /;\n/**\n * @param {function} fn\n *\n * @return {boolean}\n */\n\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\n\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n/**\n * @param {any} obj\n * @param {string} prop\n *\n * @return {boolean}\n */\n\n\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n/**\n * @typedef {import('./index').InjectAnnotated } InjectAnnotated\n */\n\n/**\n * @template T\n *\n * @params {[...string[], T] | ...string[], T} args\n *\n * @return {T & InjectAnnotated}\n */\n\n\nfunction annotate() {\n  var args = Array.prototype.slice.call(arguments);\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n  fn.$inject = args;\n  return fn;\n} // Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\n\nvar CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARGS = /^(?:async\\s+)?(?:function\\s*[^(]*)?(?:\\(\\s*([^)]*)\\)|(\\w+))/m;\nvar FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n/**\n * @param {unknown} fn\n *\n * @return {string[]}\n */\n\nfunction parseAnnotations(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS); // may parse class without constructor\n\n  if (!match) {\n    return [];\n  }\n\n  var args = match[1] || match[2];\n  return args && args.split(',').map(function (arg) {\n    var argMatch = arg.match(FN_ARG);\n    return (argMatch && argMatch[1] || arg).trim();\n  }) || [];\n}\n/**\n * @typedef { import('./index').ModuleDeclaration } ModuleDeclaration\n * @typedef { import('./index').ModuleDefinition } ModuleDefinition\n * @typedef { import('./index').InjectorContext } InjectorContext\n */\n\n/**\n * Create a new injector with the given modules.\n *\n * @param {ModuleDefinition[]} modules\n * @param {InjectorContext} [parent]\n */\n\n\nfunction Injector(modules, parent) {\n  parent = parent || {\n    get: function (name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n  var self = instances.injector = this;\n\n  var error = function (msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n  /**\n   * Return a named service.\n   *\n   * @param {string} name\n   * @param {boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {any}\n   */\n\n\n  function get(name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  }\n\n  function fnDef(fn, locals) {\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject || parseAnnotations(fn);\n    var dependencies = inject.map(function (dep) {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n    return {\n      fn: fn,\n      dependencies: dependencies\n    };\n  }\n\n  function instantiate(Type) {\n    var def = fnDef(Type);\n    var fn = def.fn,\n        dependencies = def.dependencies; // instantiate var args constructor\n\n    var Constructor = Function.prototype.bind.apply(fn, [null].concat(dependencies));\n    return new Constructor();\n  }\n\n  function invoke(func, context, locals) {\n    var def = fnDef(func, locals);\n    var fn = def.fn,\n        dependencies = def.dependencies;\n    return fn.apply(context, dependencies);\n  }\n  /**\n   * @param {Injector} childInjector\n   *\n   * @return {Function}\n   */\n\n\n  function createPrivateInjectorFactory(childInjector) {\n    return annotate(function (key) {\n      return childInjector.get(key);\n    });\n  }\n  /**\n   * @param {ModuleDefinition[]} modules\n   * @param {string[]} [forceNewInstances]\n   *\n   * @return {Injector}\n   */\n\n\n  function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(function (scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function (scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  }\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function (value) {\n      return value;\n    }\n  };\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   * @param {Injector} injector\n   */\n\n  function createInitializer(moduleDefinition, injector) {\n    var initializers = moduleDefinition.__init__ || [];\n    return function () {\n      initializers.forEach(function (initializer) {\n        // eagerly resolve component (fn or string)\n        if (typeof initializer === 'string') {\n          injector.get(initializer);\n        } else {\n          injector.invoke(initializer);\n        }\n      });\n    };\n  }\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   */\n\n\n  function loadModule(moduleDefinition) {\n    var moduleExports = moduleDefinition.__exports__; // private module\n\n    if (moduleExports) {\n      var nestedModules = moduleDefinition.__modules__;\n      var clonedModule = Object.keys(moduleDefinition).reduce(function (clonedModule, key) {\n        if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {\n          clonedModule[key] = moduleDefinition[key];\n        }\n\n        return clonedModule;\n      }, Object.create(null));\n      var childModules = (nestedModules || []).concat(clonedModule);\n      var privateInjector = createChild(childModules);\n      var getFromPrivateInjector = annotate(function (key) {\n        return privateInjector.get(key);\n      });\n      moduleExports.forEach(function (key) {\n        providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n      }); // ensure child injector initializes\n\n      var initializers = (moduleDefinition.__init__ || []).slice();\n      initializers.unshift(function () {\n        privateInjector.init();\n      });\n      moduleDefinition = Object.assign({}, moduleDefinition, {\n        __init__: initializers\n      });\n      return createInitializer(moduleDefinition, privateInjector);\n    } // normal module\n\n\n    Object.keys(moduleDefinition).forEach(function (key) {\n      if (key === '__init__' || key === '__depends__') {\n        return;\n      }\n\n      if (moduleDefinition[key][2] === 'private') {\n        providers[key] = moduleDefinition[key];\n        return;\n      }\n\n      var type = moduleDefinition[key][0];\n      var value = moduleDefinition[key][1];\n      providers[key] = [factoryMap[type], arrayUnwrap(type, value), type];\n    });\n    return createInitializer(moduleDefinition, self);\n  }\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   * @param {ModuleDefinition} moduleDefinition\n   *\n   * @return {ModuleDefinition[]}\n   */\n\n\n  function resolveDependencies(moduleDefinitions, moduleDefinition) {\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    return moduleDefinitions.concat(moduleDefinition);\n  }\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   *\n   * @return { () => void } initializerFn\n   */\n\n\n  function bootstrap(moduleDefinitions) {\n    var initializers = moduleDefinitions.reduce(resolveDependencies, []).map(loadModule);\n    var initialized = false;\n    return function () {\n      if (initialized) {\n        return;\n      }\n\n      initialized = true;\n      initializers.forEach(function (initializer) {\n        return initializer();\n      });\n    };\n  } // public API\n\n\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild; // setup\n\n  this.init = bootstrap(modules);\n} // helpers ///////////////\n\n\nfunction arrayUnwrap(type, value) {\n  if (type !== 'value' && isArray(value)) {\n    value = annotate(value.slice());\n  }\n\n  return value;\n}\n\nexport { Injector, annotate, parseAnnotations };","map":{"version":3,"names":["CLASS_PATTERN","isClass","fn","test","toString","isArray","obj","Object","prototype","call","hasOwnProp","prop","hasOwnProperty","annotate","args","Array","slice","arguments","length","pop","$inject","CONSTRUCTOR_ARGS","FN_ARGS","FN_ARG","parseAnnotations","Error","match","split","map","arg","argMatch","trim","Injector","modules","parent","get","name","strict","currentlyResolving","push","error","providers","_providers","create","instances","_instances","self","injector","msg","stack","join","indexOf","parts","pivot","shift","fnDef","locals","inject","dependencies","dep","instantiate","Type","def","Constructor","Function","bind","apply","concat","invoke","func","context","createPrivateInjectorFactory","childInjector","key","createChild","forceNewInstances","fromParentModule","matchedScopes","privateInjectorsCache","privateChildInjectors","privateChildFactories","provider","cacheIdx","privateChildInjector","privateChildInjectorFactory","$scope","forEach","scope","unshift","factoryMap","factory","type","value","createInitializer","moduleDefinition","initializers","__init__","initializer","loadModule","moduleExports","__exports__","nestedModules","__modules__","clonedModule","keys","reduce","childModules","privateInjector","getFromPrivateInjector","init","assign","arrayUnwrap","resolveDependencies","moduleDefinitions","__depends__","bootstrap","initialized"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/didi/dist/index.esm.js"],"sourcesContent":["var CLASS_PATTERN = /^class /;\n\n\n/**\n * @param {function} fn\n *\n * @return {boolean}\n */\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\n/**\n * @param {any} obj\n * @param {string} prop\n *\n * @return {boolean}\n */\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/**\n * @typedef {import('./index').InjectAnnotated } InjectAnnotated\n */\n\n/**\n * @template T\n *\n * @params {[...string[], T] | ...string[], T} args\n *\n * @return {T & InjectAnnotated}\n */\nfunction annotate() {\n  var args = Array.prototype.slice.call(arguments);\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nvar CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARGS = /^(?:async\\s+)?(?:function\\s*[^(]*)?(?:\\(\\s*([^)]*)\\)|(\\w+))/m;\nvar FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\n/**\n * @param {unknown} fn\n *\n * @return {string[]}\n */\nfunction parseAnnotations(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  var args = match[1] || match[2];\n\n  return args && args.split(',').map(function(arg) {\n    var argMatch = arg.match(FN_ARG);\n    return (argMatch && argMatch[1] || arg).trim();\n  }) || [];\n}\n\n/**\n * @typedef { import('./index').ModuleDeclaration } ModuleDeclaration\n * @typedef { import('./index').ModuleDefinition } ModuleDefinition\n * @typedef { import('./index').InjectorContext } InjectorContext\n */\n\n/**\n * Create a new injector with the given modules.\n *\n * @param {ModuleDefinition[]} modules\n * @param {InjectorContext} [parent]\n */\nfunction Injector(modules, parent) {\n  parent = parent || {\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  var self = instances.injector = this;\n\n  var error = function(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {string} name\n   * @param {boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {any}\n   */\n  function get(name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  }\n\n  function fnDef(fn, locals) {\n\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject || parseAnnotations(fn);\n    var dependencies = inject.map(function(dep) {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies: dependencies\n    };\n  }\n\n  function instantiate(Type) {\n    var def = fnDef(Type);\n\n    var fn = def.fn,\n        dependencies = def.dependencies;\n\n    // instantiate var args constructor\n    var Constructor = Function.prototype.bind.apply(fn, [ null ].concat(dependencies));\n\n    return new Constructor();\n  }\n\n  function invoke(func, context, locals) {\n    var def = fnDef(func, locals);\n\n    var fn = def.fn,\n        dependencies = def.dependencies;\n\n    return fn.apply(context, dependencies);\n  }\n\n  /**\n   * @param {Injector} childInjector\n   *\n   * @return {Function}\n   */\n  function createPrivateInjectorFactory(childInjector) {\n    return annotate(function(key) {\n      return childInjector.get(key);\n    });\n  }\n\n  /**\n   * @param {ModuleDefinition[]} modules\n   * @param {string[]} [forceNewInstances]\n   *\n   * @return {Injector}\n   */\n  function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [ privateChildInjectorFactory, name, 'private', privateChildInjector ];\n            } else {\n              fromParentModule[name] = [ privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx] ];\n            }\n          } else {\n            fromParentModule[name] = [ provider[2], provider[1] ];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(function(scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [ provider[2], provider[1] ];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function(scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  }\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   * @param {Injector} injector\n   */\n  function createInitializer(moduleDefinition, injector) {\n\n    var initializers = moduleDefinition.__init__ || [];\n\n    return function() {\n      initializers.forEach(function(initializer) {\n\n        // eagerly resolve component (fn or string)\n        if (typeof initializer === 'string') {\n          injector.get(initializer);\n        } else {\n          injector.invoke(initializer);\n        }\n      });\n    };\n  }\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   */\n  function loadModule(moduleDefinition) {\n\n    var moduleExports = moduleDefinition.__exports__;\n\n    // private module\n    if (moduleExports) {\n      var nestedModules = moduleDefinition.__modules__;\n\n      var clonedModule = Object.keys(moduleDefinition).reduce(function(clonedModule, key) {\n\n        if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {\n          clonedModule[key] = moduleDefinition[key];\n        }\n\n        return clonedModule;\n      }, Object.create(null));\n\n      var childModules = (nestedModules || []).concat(clonedModule);\n\n      var privateInjector = createChild(childModules);\n      var getFromPrivateInjector = annotate(function(key) {\n        return privateInjector.get(key);\n      });\n\n      moduleExports.forEach(function(key) {\n        providers[key] = [ getFromPrivateInjector, key, 'private', privateInjector ];\n      });\n\n      // ensure child injector initializes\n      var initializers = (moduleDefinition.__init__ || []).slice();\n\n      initializers.unshift(function() {\n        privateInjector.init();\n      });\n\n      moduleDefinition = Object.assign({}, moduleDefinition, {\n        __init__: initializers\n      });\n\n      return createInitializer(moduleDefinition, privateInjector);\n    }\n\n    // normal module\n    Object.keys(moduleDefinition).forEach(function(key) {\n\n      if (key === '__init__' || key === '__depends__') {\n        return;\n      }\n\n      if (moduleDefinition[key][2] === 'private') {\n        providers[key] = moduleDefinition[key];\n        return;\n      }\n\n      var type = moduleDefinition[key][0];\n      var value = moduleDefinition[key][1];\n\n      providers[key] = [ factoryMap[type], arrayUnwrap(type, value), type ];\n    });\n\n    return createInitializer(moduleDefinition, self);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   * @param {ModuleDefinition} moduleDefinition\n   *\n   * @return {ModuleDefinition[]}\n   */\n  function resolveDependencies(moduleDefinitions, moduleDefinition) {\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    return moduleDefinitions.concat(moduleDefinition);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   *\n   * @return { () => void } initializerFn\n   */\n  function bootstrap(moduleDefinitions) {\n\n    var initializers = moduleDefinitions\n      .reduce(resolveDependencies, [])\n      .map(loadModule);\n\n    var initialized = false;\n\n    return function() {\n\n      if (initialized) {\n        return;\n      }\n\n      initialized = true;\n\n      initializers.forEach(function(initializer) {\n        return initializer();\n      });\n    };\n  }\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n\n  // setup\n  this.init = bootstrap(modules);\n}\n\n\n// helpers ///////////////\n\nfunction arrayUnwrap(type, value) {\n  if (type !== 'value' && isArray(value)) {\n    value = annotate(value.slice());\n  }\n\n  return value;\n}\n\nexport { Injector, annotate, parseAnnotations };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}