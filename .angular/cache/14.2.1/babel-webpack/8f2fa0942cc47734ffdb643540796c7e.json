{"ast":null,"code":"import { assign, find, forEach, isArray, isNumber, map, matchPattern, omit, sortBy } from 'min-dash';\nimport { getBBox, getParents } from '../../util/Elements';\nimport { eachElement } from '../../util/Elements';\n/**\n * @typedef {Function} <copyPaste.canCopyElements> listener\n *\n * @param {Object} context\n * @param {Array<djs.model.Base>} context.elements\n *\n * @returns {Array<djs.model.Base>|boolean} - Return elements to be copied or false to disallow\n * copying.\n */\n\n/**\n * @typedef {Function} <copyPaste.copyElement> listener\n *\n * @param {Object} context\n * @param {Object} context.descriptor\n * @param {djs.model.Base} context.element\n * @param {Array<djs.model.Base>} context.elements\n */\n\n/**\n * @typedef {Function} <copyPaste.createTree> listener\n *\n * @param {Object} context\n * @param {djs.model.Base} context.element\n * @param {Array<djs.model.Base>} context.children - Add children to be added to tree.\n */\n\n/**\n * @typedef {Function} <copyPaste.elementsCopied> listener\n *\n * @param {Object} context\n * @param {Object} context.elements\n * @param {Object} context.tree\n */\n\n/**\n * @typedef {Function} <copyPaste.pasteElement> listener\n *\n * @param {Object} context\n * @param {Object} context.cache - Already created elements.\n * @param {Object} context.descriptor\n */\n\n/**\n * @typedef {Function} <copyPaste.pasteElements> listener\n *\n * @param {Object} context\n * @param {Object} context.hints - Add hints before pasting.\n */\n\n/**\n * Copy and paste elements.\n *\n * @param {Canvas} canvas\n * @param {Create} create\n * @param {Clipboard} clipboard\n * @param {ElementFactory} elementFactory\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Mouse} mouse\n * @param {Rules} rules\n */\n\nexport default function CopyPaste(canvas, create, clipboard, elementFactory, eventBus, modeling, mouse, rules) {\n  this._canvas = canvas;\n  this._create = create;\n  this._clipboard = clipboard;\n  this._elementFactory = elementFactory;\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._mouse = mouse;\n  this._rules = rules;\n  eventBus.on('copyPaste.copyElement', function (context) {\n    var descriptor = context.descriptor,\n        element = context.element,\n        elements = context.elements; // default priority (priority = 1)\n\n    descriptor.priority = 1;\n    descriptor.id = element.id;\n    var parentCopied = find(elements, function (e) {\n      return e === element.parent;\n    }); // do NOT reference parent if parent wasn't copied\n\n    if (parentCopied) {\n      descriptor.parent = element.parent.id;\n    } // attachers (priority = 2)\n\n\n    if (isAttacher(element)) {\n      descriptor.priority = 2;\n      descriptor.host = element.host.id;\n    } // connections (priority = 3)\n\n\n    if (isConnection(element)) {\n      descriptor.priority = 3;\n      descriptor.source = element.source.id;\n      descriptor.target = element.target.id;\n      descriptor.waypoints = copyWaypoints(element);\n    } // labels (priority = 4)\n\n\n    if (isLabel(element)) {\n      descriptor.priority = 4;\n      descriptor.labelTarget = element.labelTarget.id;\n    }\n\n    forEach(['x', 'y', 'width', 'height'], function (property) {\n      if (isNumber(element[property])) {\n        descriptor[property] = element[property];\n      }\n    });\n    descriptor.hidden = element.hidden;\n    descriptor.collapsed = element.collapsed;\n  });\n  eventBus.on('copyPaste.pasteElements', function (context) {\n    var hints = context.hints;\n    assign(hints, {\n      createElementsBehavior: false\n    });\n  });\n}\nCopyPaste.$inject = ['canvas', 'create', 'clipboard', 'elementFactory', 'eventBus', 'modeling', 'mouse', 'rules'];\n/**\n * Copy elements.\n *\n * @param {Array<djs.model.Base>} elements\n *\n * @returns {Object}\n */\n\nCopyPaste.prototype.copy = function (elements) {\n  var allowed, tree;\n\n  if (!isArray(elements)) {\n    elements = elements ? [elements] : [];\n  }\n\n  allowed = this._eventBus.fire('copyPaste.canCopyElements', {\n    elements: elements\n  });\n\n  if (allowed === false) {\n    tree = {};\n  } else {\n    tree = this.createTree(isArray(allowed) ? allowed : elements);\n  } // we set an empty tree, selection of elements\n  // to copy was empty.\n\n\n  this._clipboard.set(tree);\n\n  this._eventBus.fire('copyPaste.elementsCopied', {\n    elements: elements,\n    tree: tree\n  });\n\n  return tree;\n};\n/**\n * Paste elements.\n *\n * @param {Object} [context]\n * @param {djs.model.base} [context.element] - Parent.\n * @param {Point} [context.point] - Position.\n * @param {Object} [context.hints] - Hints.\n */\n\n\nCopyPaste.prototype.paste = function (context) {\n  var tree = this._clipboard.get();\n\n  if (this._clipboard.isEmpty()) {\n    return;\n  }\n\n  var hints = context && context.hints || {};\n\n  this._eventBus.fire('copyPaste.pasteElements', {\n    hints: hints\n  });\n\n  var elements = this._createElements(tree); // paste directly\n\n\n  if (context && context.element && context.point) {\n    return this._paste(elements, context.element, context.point, hints);\n  }\n\n  this._create.start(this._mouse.getLastMoveEvent(), elements, {\n    hints: hints || {}\n  });\n};\n/**\n * Paste elements directly.\n *\n * @param {Array<djs.model.Base>} elements\n * @param {djs.model.base} target\n * @param {Point} position\n * @param {Object} [hints]\n */\n\n\nCopyPaste.prototype._paste = function (elements, target, position, hints) {\n  // make sure each element has x and y\n  forEach(elements, function (element) {\n    if (!isNumber(element.x)) {\n      element.x = 0;\n    }\n\n    if (!isNumber(element.y)) {\n      element.y = 0;\n    }\n  });\n  var bbox = getBBox(elements); // center elements around cursor\n\n  forEach(elements, function (element) {\n    if (isConnection(element)) {\n      element.waypoints = map(element.waypoints, function (waypoint) {\n        return {\n          x: waypoint.x - bbox.x - bbox.width / 2,\n          y: waypoint.y - bbox.y - bbox.height / 2\n        };\n      });\n    }\n\n    assign(element, {\n      x: element.x - bbox.x - bbox.width / 2,\n      y: element.y - bbox.y - bbox.height / 2\n    });\n  });\n  return this._modeling.createElements(elements, position, target, assign({}, hints));\n};\n/**\n * Create elements from tree.\n */\n\n\nCopyPaste.prototype._createElements = function (tree) {\n  var self = this;\n  var eventBus = this._eventBus;\n  var cache = {};\n  var elements = [];\n  forEach(tree, function (branch, depth) {\n    depth = parseInt(depth, 10); // sort by priority\n\n    branch = sortBy(branch, 'priority');\n    forEach(branch, function (descriptor) {\n      // remove priority\n      var attrs = assign({}, omit(descriptor, ['priority']));\n\n      if (cache[descriptor.parent]) {\n        attrs.parent = cache[descriptor.parent];\n      } else {\n        delete attrs.parent;\n      }\n\n      eventBus.fire('copyPaste.pasteElement', {\n        cache: cache,\n        descriptor: attrs\n      });\n      var element;\n\n      if (isConnection(attrs)) {\n        attrs.source = cache[descriptor.source];\n        attrs.target = cache[descriptor.target];\n        element = cache[descriptor.id] = self.createConnection(attrs);\n        elements.push(element);\n        return;\n      }\n\n      if (isLabel(attrs)) {\n        attrs.labelTarget = cache[attrs.labelTarget];\n        element = cache[descriptor.id] = self.createLabel(attrs);\n        elements.push(element);\n        return;\n      }\n\n      if (attrs.host) {\n        attrs.host = cache[attrs.host];\n      }\n\n      element = cache[descriptor.id] = self.createShape(attrs);\n      elements.push(element);\n    });\n  });\n  return elements;\n};\n\nCopyPaste.prototype.createConnection = function (attrs) {\n  var connection = this._elementFactory.createConnection(omit(attrs, ['id']));\n\n  return connection;\n};\n\nCopyPaste.prototype.createLabel = function (attrs) {\n  var label = this._elementFactory.createLabel(omit(attrs, ['id']));\n\n  return label;\n};\n\nCopyPaste.prototype.createShape = function (attrs) {\n  var shape = this._elementFactory.createShape(omit(attrs, ['id']));\n\n  return shape;\n};\n/**\n * Check wether element has relations to other elements e.g. attachers, labels and connections.\n *\n * @param  {Object} element\n * @param  {Array<djs.model.Base>} elements\n *\n * @returns {boolean}\n */\n\n\nCopyPaste.prototype.hasRelations = function (element, elements) {\n  var labelTarget, source, target;\n\n  if (isConnection(element)) {\n    source = find(elements, matchPattern({\n      id: element.source.id\n    }));\n    target = find(elements, matchPattern({\n      id: element.target.id\n    }));\n\n    if (!source || !target) {\n      return false;\n    }\n  }\n\n  if (isLabel(element)) {\n    labelTarget = find(elements, matchPattern({\n      id: element.labelTarget.id\n    }));\n\n    if (!labelTarget) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Create a tree-like structure from elements.\n *\n * @example\n * tree: {\n  *  0: [\n  *    { id: 'Shape_1', priority: 1, ... },\n  *    { id: 'Shape_2', priority: 1, ... },\n  *    { id: 'Connection_1', source: 'Shape_1', target: 'Shape_2', priority: 3, ... },\n  *    ...\n  *  ],\n  *  1: [\n  *    { id: 'Shape_3', parent: 'Shape1', priority: 1, ... },\n  *    ...\n  *  ]\n  * };\n  *\n  * @param  {Array<djs.model.base>} elements\n  *\n  * @return {Object}\n  */\n\n\nCopyPaste.prototype.createTree = function (elements) {\n  var rules = this._rules,\n      self = this;\n  var tree = {},\n      elementsData = [];\n  var parents = getParents(elements);\n\n  function canCopy(element, elements) {\n    return rules.allowed('element.copy', {\n      element: element,\n      elements: elements\n    });\n  }\n\n  function addElementData(element, depth) {\n    // (1) check wether element has already been added\n    var foundElementData = find(elementsData, function (elementsData) {\n      return element === elementsData.element;\n    }); // (2) add element if not already added\n\n    if (!foundElementData) {\n      elementsData.push({\n        element: element,\n        depth: depth\n      });\n      return;\n    } // (3) update depth\n\n\n    if (foundElementData.depth < depth) {\n      elementsData = removeElementData(foundElementData, elementsData);\n      elementsData.push({\n        element: foundElementData.element,\n        depth: depth\n      });\n    }\n  }\n\n  function removeElementData(elementData, elementsData) {\n    var index = elementsData.indexOf(elementData);\n\n    if (index !== -1) {\n      elementsData.splice(index, 1);\n    }\n\n    return elementsData;\n  } // (1) add elements\n\n\n  eachElement(parents, function (element, _index, depth) {\n    // do NOT add external labels directly\n    if (isLabel(element)) {\n      return;\n    } // always copy external labels\n\n\n    forEach(element.labels, function (label) {\n      addElementData(label, depth);\n    });\n\n    function addRelatedElements(elements) {\n      elements && elements.length && forEach(elements, function (element) {\n        // add external labels\n        forEach(element.labels, function (label) {\n          addElementData(label, depth);\n        });\n        addElementData(element, depth);\n      });\n    }\n\n    forEach([element.attachers, element.incoming, element.outgoing], addRelatedElements);\n    addElementData(element, depth);\n    var children = [];\n\n    if (element.children) {\n      children = element.children.slice();\n    } // allow others to add children to tree\n\n\n    self._eventBus.fire('copyPaste.createTree', {\n      element: element,\n      children: children\n    });\n\n    return children;\n  });\n  elements = map(elementsData, function (elementData) {\n    return elementData.element;\n  }); // (2) copy elements\n\n  elementsData = map(elementsData, function (elementData) {\n    elementData.descriptor = {};\n\n    self._eventBus.fire('copyPaste.copyElement', {\n      descriptor: elementData.descriptor,\n      element: elementData.element,\n      elements: elements\n    });\n\n    return elementData;\n  }); // (3) sort elements by priority\n\n  elementsData = sortBy(elementsData, function (elementData) {\n    return elementData.descriptor.priority;\n  });\n  elements = map(elementsData, function (elementData) {\n    return elementData.element;\n  }); // (4) create tree\n\n  forEach(elementsData, function (elementData) {\n    var depth = elementData.depth;\n\n    if (!self.hasRelations(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n      return;\n    }\n\n    if (!canCopy(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n      return;\n    }\n\n    if (!tree[depth]) {\n      tree[depth] = [];\n    }\n\n    tree[depth].push(elementData.descriptor);\n  });\n  return tree;\n}; // helpers //////////\n\n\nfunction isAttacher(element) {\n  return !!element.host;\n}\n\nfunction isConnection(element) {\n  return !!element.waypoints;\n}\n\nfunction isLabel(element) {\n  return !!element.labelTarget;\n}\n\nfunction copyWaypoints(element) {\n  return map(element.waypoints, function (waypoint) {\n    waypoint = copyWaypoint(waypoint);\n\n    if (waypoint.original) {\n      waypoint.original = copyWaypoint(waypoint.original);\n    }\n\n    return waypoint;\n  });\n}\n\nfunction copyWaypoint(waypoint) {\n  return assign({}, waypoint);\n}\n\nfunction removeElement(element, elements) {\n  var index = elements.indexOf(element);\n\n  if (index === -1) {\n    return elements;\n  }\n\n  return elements.splice(index, 1);\n}","map":{"version":3,"names":["assign","find","forEach","isArray","isNumber","map","matchPattern","omit","sortBy","getBBox","getParents","eachElement","CopyPaste","canvas","create","clipboard","elementFactory","eventBus","modeling","mouse","rules","_canvas","_create","_clipboard","_elementFactory","_eventBus","_modeling","_mouse","_rules","on","context","descriptor","element","elements","priority","id","parentCopied","e","parent","isAttacher","host","isConnection","source","target","waypoints","copyWaypoints","isLabel","labelTarget","property","hidden","collapsed","hints","createElementsBehavior","$inject","prototype","copy","allowed","tree","fire","createTree","set","paste","get","isEmpty","_createElements","point","_paste","start","getLastMoveEvent","position","x","y","bbox","waypoint","width","height","createElements","self","cache","branch","depth","parseInt","attrs","createConnection","push","createLabel","createShape","connection","label","shape","hasRelations","elementsData","parents","canCopy","addElementData","foundElementData","removeElementData","elementData","index","indexOf","splice","_index","labels","addRelatedElements","length","attachers","incoming","outgoing","children","slice","removeElement","copyWaypoint","original"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js"],"sourcesContent":["import {\n  assign,\n  find,\n  forEach,\n  isArray,\n  isNumber,\n  map,\n  matchPattern,\n  omit,\n  sortBy\n} from 'min-dash';\n\nimport {\n  getBBox,\n  getParents\n} from '../../util/Elements';\n\nimport { eachElement } from '../../util/Elements';\n\n/**\n * @typedef {Function} <copyPaste.canCopyElements> listener\n *\n * @param {Object} context\n * @param {Array<djs.model.Base>} context.elements\n *\n * @returns {Array<djs.model.Base>|boolean} - Return elements to be copied or false to disallow\n * copying.\n */\n\n/**\n * @typedef {Function} <copyPaste.copyElement> listener\n *\n * @param {Object} context\n * @param {Object} context.descriptor\n * @param {djs.model.Base} context.element\n * @param {Array<djs.model.Base>} context.elements\n */\n\n/**\n * @typedef {Function} <copyPaste.createTree> listener\n *\n * @param {Object} context\n * @param {djs.model.Base} context.element\n * @param {Array<djs.model.Base>} context.children - Add children to be added to tree.\n */\n\n/**\n * @typedef {Function} <copyPaste.elementsCopied> listener\n *\n * @param {Object} context\n * @param {Object} context.elements\n * @param {Object} context.tree\n */\n\n/**\n * @typedef {Function} <copyPaste.pasteElement> listener\n *\n * @param {Object} context\n * @param {Object} context.cache - Already created elements.\n * @param {Object} context.descriptor\n */\n\n/**\n * @typedef {Function} <copyPaste.pasteElements> listener\n *\n * @param {Object} context\n * @param {Object} context.hints - Add hints before pasting.\n */\n\n/**\n * Copy and paste elements.\n *\n * @param {Canvas} canvas\n * @param {Create} create\n * @param {Clipboard} clipboard\n * @param {ElementFactory} elementFactory\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Mouse} mouse\n * @param {Rules} rules\n */\nexport default function CopyPaste(\n    canvas,\n    create,\n    clipboard,\n    elementFactory,\n    eventBus,\n    modeling,\n    mouse,\n    rules\n) {\n\n  this._canvas = canvas;\n  this._create = create;\n  this._clipboard = clipboard;\n  this._elementFactory = elementFactory;\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._mouse = mouse;\n  this._rules = rules;\n\n  eventBus.on('copyPaste.copyElement', function(context) {\n    var descriptor = context.descriptor,\n        element = context.element,\n        elements = context.elements;\n\n    // default priority (priority = 1)\n    descriptor.priority = 1;\n\n    descriptor.id = element.id;\n\n    var parentCopied = find(elements, function(e) {\n      return e === element.parent;\n    });\n\n    // do NOT reference parent if parent wasn't copied\n    if (parentCopied) {\n      descriptor.parent = element.parent.id;\n    }\n\n    // attachers (priority = 2)\n    if (isAttacher(element)) {\n      descriptor.priority = 2;\n\n      descriptor.host = element.host.id;\n    }\n\n    // connections (priority = 3)\n    if (isConnection(element)) {\n      descriptor.priority = 3;\n\n      descriptor.source = element.source.id;\n      descriptor.target = element.target.id;\n\n      descriptor.waypoints = copyWaypoints(element);\n    }\n\n    // labels (priority = 4)\n    if (isLabel(element)) {\n      descriptor.priority = 4;\n\n      descriptor.labelTarget = element.labelTarget.id;\n    }\n\n    forEach([ 'x', 'y', 'width', 'height' ], function(property) {\n      if (isNumber(element[ property ])) {\n        descriptor[ property ] = element[ property ];\n      }\n    });\n\n    descriptor.hidden = element.hidden;\n    descriptor.collapsed = element.collapsed;\n\n  });\n\n  eventBus.on('copyPaste.pasteElements', function(context) {\n    var hints = context.hints;\n\n    assign(hints, {\n      createElementsBehavior: false\n    });\n  });\n}\n\nCopyPaste.$inject = [\n  'canvas',\n  'create',\n  'clipboard',\n  'elementFactory',\n  'eventBus',\n  'modeling',\n  'mouse',\n  'rules'\n];\n\n\n/**\n * Copy elements.\n *\n * @param {Array<djs.model.Base>} elements\n *\n * @returns {Object}\n */\nCopyPaste.prototype.copy = function(elements) {\n  var allowed,\n      tree;\n\n  if (!isArray(elements)) {\n    elements = elements ? [ elements ] : [];\n  }\n\n  allowed = this._eventBus.fire('copyPaste.canCopyElements', {\n    elements: elements\n  });\n\n  if (allowed === false) {\n    tree = {};\n  } else {\n    tree = this.createTree(isArray(allowed) ? allowed : elements);\n  }\n\n  // we set an empty tree, selection of elements\n  // to copy was empty.\n  this._clipboard.set(tree);\n\n  this._eventBus.fire('copyPaste.elementsCopied', {\n    elements: elements,\n    tree: tree\n  });\n\n  return tree;\n};\n\n/**\n * Paste elements.\n *\n * @param {Object} [context]\n * @param {djs.model.base} [context.element] - Parent.\n * @param {Point} [context.point] - Position.\n * @param {Object} [context.hints] - Hints.\n */\nCopyPaste.prototype.paste = function(context) {\n  var tree = this._clipboard.get();\n\n  if (this._clipboard.isEmpty()) {\n    return;\n  }\n\n  var hints = context && context.hints || {};\n\n  this._eventBus.fire('copyPaste.pasteElements', {\n    hints: hints\n  });\n\n  var elements = this._createElements(tree);\n\n  // paste directly\n  if (context && context.element && context.point) {\n    return this._paste(elements, context.element, context.point, hints);\n  }\n\n  this._create.start(this._mouse.getLastMoveEvent(), elements, {\n    hints: hints || {}\n  });\n};\n\n/**\n * Paste elements directly.\n *\n * @param {Array<djs.model.Base>} elements\n * @param {djs.model.base} target\n * @param {Point} position\n * @param {Object} [hints]\n */\nCopyPaste.prototype._paste = function(elements, target, position, hints) {\n\n  // make sure each element has x and y\n  forEach(elements, function(element) {\n    if (!isNumber(element.x)) {\n      element.x = 0;\n    }\n\n    if (!isNumber(element.y)) {\n      element.y = 0;\n    }\n  });\n\n  var bbox = getBBox(elements);\n\n  // center elements around cursor\n  forEach(elements, function(element) {\n    if (isConnection(element)) {\n      element.waypoints = map(element.waypoints, function(waypoint) {\n        return {\n          x: waypoint.x - bbox.x - bbox.width / 2,\n          y: waypoint.y - bbox.y - bbox.height / 2\n        };\n      });\n    }\n\n    assign(element, {\n      x: element.x - bbox.x - bbox.width / 2,\n      y: element.y - bbox.y - bbox.height / 2\n    });\n  });\n\n  return this._modeling.createElements(elements, position, target, assign({}, hints));\n};\n\n/**\n * Create elements from tree.\n */\nCopyPaste.prototype._createElements = function(tree) {\n  var self = this;\n\n  var eventBus = this._eventBus;\n\n  var cache = {};\n\n  var elements = [];\n\n  forEach(tree, function(branch, depth) {\n\n    depth = parseInt(depth, 10);\n\n    // sort by priority\n    branch = sortBy(branch, 'priority');\n\n    forEach(branch, function(descriptor) {\n\n      // remove priority\n      var attrs = assign({}, omit(descriptor, [ 'priority' ]));\n\n      if (cache[ descriptor.parent ]) {\n        attrs.parent = cache[ descriptor.parent ];\n      } else {\n        delete attrs.parent;\n      }\n\n      eventBus.fire('copyPaste.pasteElement', {\n        cache: cache,\n        descriptor: attrs\n      });\n\n      var element;\n\n      if (isConnection(attrs)) {\n        attrs.source = cache[ descriptor.source ];\n        attrs.target = cache[ descriptor.target ];\n\n        element = cache[ descriptor.id ] = self.createConnection(attrs);\n\n        elements.push(element);\n\n        return;\n      }\n\n      if (isLabel(attrs)) {\n        attrs.labelTarget = cache[ attrs.labelTarget ];\n\n        element = cache[ descriptor.id ] = self.createLabel(attrs);\n\n        elements.push(element);\n\n        return;\n      }\n\n      if (attrs.host) {\n        attrs.host = cache[ attrs.host ];\n      }\n\n      element = cache[ descriptor.id ] = self.createShape(attrs);\n\n      elements.push(element);\n    });\n\n  });\n\n  return elements;\n};\n\nCopyPaste.prototype.createConnection = function(attrs) {\n  var connection = this._elementFactory.createConnection(omit(attrs, [ 'id' ]));\n\n  return connection;\n};\n\nCopyPaste.prototype.createLabel = function(attrs) {\n  var label = this._elementFactory.createLabel(omit(attrs, [ 'id' ]));\n\n  return label;\n};\n\nCopyPaste.prototype.createShape = function(attrs) {\n  var shape = this._elementFactory.createShape(omit(attrs, [ 'id' ]));\n\n  return shape;\n};\n\n/**\n * Check wether element has relations to other elements e.g. attachers, labels and connections.\n *\n * @param  {Object} element\n * @param  {Array<djs.model.Base>} elements\n *\n * @returns {boolean}\n */\nCopyPaste.prototype.hasRelations = function(element, elements) {\n  var labelTarget,\n      source,\n      target;\n\n  if (isConnection(element)) {\n    source = find(elements, matchPattern({ id: element.source.id }));\n    target = find(elements, matchPattern({ id: element.target.id }));\n\n    if (!source || !target) {\n      return false;\n    }\n  }\n\n  if (isLabel(element)) {\n    labelTarget = find(elements, matchPattern({ id: element.labelTarget.id }));\n\n    if (!labelTarget) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Create a tree-like structure from elements.\n *\n * @example\n * tree: {\n  *  0: [\n  *    { id: 'Shape_1', priority: 1, ... },\n  *    { id: 'Shape_2', priority: 1, ... },\n  *    { id: 'Connection_1', source: 'Shape_1', target: 'Shape_2', priority: 3, ... },\n  *    ...\n  *  ],\n  *  1: [\n  *    { id: 'Shape_3', parent: 'Shape1', priority: 1, ... },\n  *    ...\n  *  ]\n  * };\n  *\n  * @param  {Array<djs.model.base>} elements\n  *\n  * @return {Object}\n  */\nCopyPaste.prototype.createTree = function(elements) {\n  var rules = this._rules,\n      self = this;\n\n  var tree = {},\n      elementsData = [];\n\n  var parents = getParents(elements);\n\n  function canCopy(element, elements) {\n    return rules.allowed('element.copy', {\n      element: element,\n      elements: elements\n    });\n  }\n\n  function addElementData(element, depth) {\n\n    // (1) check wether element has already been added\n    var foundElementData = find(elementsData, function(elementsData) {\n      return element === elementsData.element;\n    });\n\n    // (2) add element if not already added\n    if (!foundElementData) {\n      elementsData.push({\n        element: element,\n        depth: depth\n      });\n\n      return;\n    }\n\n    // (3) update depth\n    if (foundElementData.depth < depth) {\n      elementsData = removeElementData(foundElementData, elementsData);\n\n      elementsData.push({\n        element: foundElementData.element,\n        depth: depth\n      });\n    }\n  }\n\n  function removeElementData(elementData, elementsData) {\n    var index = elementsData.indexOf(elementData);\n\n    if (index !== -1) {\n      elementsData.splice(index, 1);\n    }\n\n    return elementsData;\n  }\n\n  // (1) add elements\n  eachElement(parents, function(element, _index, depth) {\n\n    // do NOT add external labels directly\n    if (isLabel(element)) {\n      return;\n    }\n\n    // always copy external labels\n    forEach(element.labels, function(label) {\n      addElementData(label, depth);\n    });\n\n    function addRelatedElements(elements) {\n      elements && elements.length && forEach(elements, function(element) {\n\n        // add external labels\n        forEach(element.labels, function(label) {\n          addElementData(label, depth);\n        });\n\n        addElementData(element, depth);\n      });\n    }\n\n    forEach([ element.attachers, element.incoming, element.outgoing ], addRelatedElements);\n\n    addElementData(element, depth);\n\n    var children = [];\n\n    if (element.children) {\n      children = element.children.slice();\n    }\n\n    // allow others to add children to tree\n    self._eventBus.fire('copyPaste.createTree', {\n      element: element,\n      children: children\n    });\n\n    return children;\n  });\n\n  elements = map(elementsData, function(elementData) {\n    return elementData.element;\n  });\n\n  // (2) copy elements\n  elementsData = map(elementsData, function(elementData) {\n    elementData.descriptor = {};\n\n    self._eventBus.fire('copyPaste.copyElement', {\n      descriptor: elementData.descriptor,\n      element: elementData.element,\n      elements: elements\n    });\n\n    return elementData;\n  });\n\n  // (3) sort elements by priority\n  elementsData = sortBy(elementsData, function(elementData) {\n    return elementData.descriptor.priority;\n  });\n\n  elements = map(elementsData, function(elementData) {\n    return elementData.element;\n  });\n\n  // (4) create tree\n  forEach(elementsData, function(elementData) {\n    var depth = elementData.depth;\n\n    if (!self.hasRelations(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n\n      return;\n    }\n\n    if (!canCopy(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n\n      return;\n    }\n\n    if (!tree[depth]) {\n      tree[depth] = [];\n    }\n\n    tree[depth].push(elementData.descriptor);\n  });\n\n  return tree;\n};\n\n// helpers //////////\n\nfunction isAttacher(element) {\n  return !!element.host;\n}\n\nfunction isConnection(element) {\n  return !!element.waypoints;\n}\n\nfunction isLabel(element) {\n  return !!element.labelTarget;\n}\n\nfunction copyWaypoints(element) {\n  return map(element.waypoints, function(waypoint) {\n\n    waypoint = copyWaypoint(waypoint);\n\n    if (waypoint.original) {\n      waypoint.original = copyWaypoint(waypoint.original);\n    }\n\n    return waypoint;\n  });\n}\n\nfunction copyWaypoint(waypoint) {\n  return assign({}, waypoint);\n}\n\nfunction removeElement(element, elements) {\n  var index = elements.indexOf(element);\n\n  if (index === -1) {\n    return elements;\n  }\n\n  return elements.splice(index, 1);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}