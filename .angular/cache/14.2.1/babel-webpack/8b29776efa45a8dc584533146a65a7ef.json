{"ast":null,"code":"import { pointsAligned, pointsOnLine } from '../../util/Geometry';\nimport { addSegmentDragger, getConnectionIntersection } from './BendpointUtil';\nimport { getMid, getOrientation } from '../../layout/LayoutUtil';\nvar MARKER_CONNECT_HOVER = 'connect-hover',\n    MARKER_CONNECT_UPDATING = 'djs-updating';\nimport { classes as svgClasses, remove as svgRemove } from 'tiny-svg';\nimport { translate } from '../../util/SvgTransformUtil';\n\nfunction axisAdd(point, axis, delta) {\n  return axisSet(point, axis, point[axis] + delta);\n}\n\nfunction axisSet(point, axis, value) {\n  return {\n    x: axis === 'x' ? value : point.x,\n    y: axis === 'y' ? value : point.y\n  };\n}\n\nfunction axisFenced(position, segmentStart, segmentEnd, axis) {\n  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),\n      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);\n  var padding = 20;\n  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);\n  return axisSet(segmentStart, axis, fencedValue);\n}\n\nfunction flipAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n/**\n * Get the docking point on the given element.\n *\n * Compute a reasonable docking, if non exists.\n *\n * @param  {Point} point\n * @param  {djs.model.Shape} referenceElement\n * @param  {string} moveAxis (x|y)\n *\n * @return {Point}\n */\n\n\nfunction getDocking(point, referenceElement, moveAxis) {\n  var referenceMid, inverseAxis;\n\n  if (point.original) {\n    return point.original;\n  } else {\n    referenceMid = getMid(referenceElement);\n    inverseAxis = flipAxis(moveAxis);\n    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);\n  }\n}\n/**\n * A component that implements moving of bendpoints\n */\n\n\nexport default function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {\n  // optional connection docking integration\n  var connectionDocking = injector.get('connectionDocking', false); // API\n\n  this.start = function (event, connection, idx) {\n    var context,\n        gfx = canvas.getGraphics(connection),\n        segmentStartIndex = idx - 1,\n        segmentEndIndex = idx,\n        waypoints = connection.waypoints,\n        segmentStart = waypoints[segmentStartIndex],\n        segmentEnd = waypoints[segmentEndIndex],\n        intersection = getConnectionIntersection(canvas, waypoints, event),\n        direction,\n        axis,\n        dragPosition;\n    direction = pointsAligned(segmentStart, segmentEnd); // do not move diagonal connection\n\n    if (!direction) {\n      return;\n    } // the axis where we are going to move things\n\n\n    axis = direction === 'v' ? 'x' : 'y';\n\n    if (segmentStartIndex === 0) {\n      segmentStart = getDocking(segmentStart, connection.source, axis);\n    }\n\n    if (segmentEndIndex === waypoints.length - 1) {\n      segmentEnd = getDocking(segmentEnd, connection.target, axis);\n    }\n\n    if (intersection) {\n      dragPosition = intersection.point;\n    } else {\n      // set to segment center as default\n      dragPosition = {\n        x: (segmentStart.x + segmentEnd.x) / 2,\n        y: (segmentStart.y + segmentEnd.y) / 2\n      };\n    }\n\n    context = {\n      connection: connection,\n      segmentStartIndex: segmentStartIndex,\n      segmentEndIndex: segmentEndIndex,\n      segmentStart: segmentStart,\n      segmentEnd: segmentEnd,\n      axis: axis,\n      dragPosition: dragPosition\n    };\n    dragging.init(event, dragPosition, 'connectionSegment.move', {\n      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: context\n      }\n    });\n  };\n  /**\n   * Crop connection if connection cropping is provided.\n   *\n   * @param {Connection} connection\n   * @param {Array<Point>} newWaypoints\n   *\n   * @return {Array<Point>} cropped connection waypoints\n   */\n\n\n  function cropConnection(connection, newWaypoints) {\n    // crop connection, if docking service is provided only\n    if (!connectionDocking) {\n      return newWaypoints;\n    }\n\n    var oldWaypoints = connection.waypoints,\n        croppedWaypoints; // temporary set new waypoints\n\n    connection.waypoints = newWaypoints;\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection); // restore old waypoints\n\n    connection.waypoints = oldWaypoints;\n    return croppedWaypoints;\n  } // DRAGGING IMPLEMENTATION\n\n\n  function redrawConnection(data) {\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\n  }\n\n  function updateDragger(context, segmentOffset, event) {\n    var newWaypoints = context.newWaypoints,\n        segmentStartIndex = context.segmentStartIndex + segmentOffset,\n        segmentStart = newWaypoints[segmentStartIndex],\n        segmentEndIndex = context.segmentEndIndex + segmentOffset,\n        segmentEnd = newWaypoints[segmentEndIndex],\n        axis = flipAxis(context.axis); // make sure the dragger does not move\n    // outside the connection\n\n    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis); // update dragger\n\n    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);\n  }\n  /**\n   * Filter waypoints for redundant ones (i.e. on the same axis).\n   * Returns the filtered waypoints and the offset related to the segment move.\n   *\n   * @param {Array<Point>} waypoints\n   * @param {Integer} segmentStartIndex of moved segment start\n   *\n   * @return {Object} { filteredWaypoints, segmentOffset }\n   */\n\n\n  function filterRedundantWaypoints(waypoints, segmentStartIndex) {\n    var segmentOffset = 0;\n    var filteredWaypoints = waypoints.filter(function (r, idx) {\n      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {\n        // remove point and increment offset\n        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;\n        return false;\n      } // dont remove point\n\n\n      return true;\n    });\n    return {\n      waypoints: filteredWaypoints,\n      segmentOffset: segmentOffset\n    };\n  }\n\n  eventBus.on('connectionSegment.move.start', function (event) {\n    var context = event.context,\n        connection = event.connection,\n        layer = canvas.getLayer('overlays');\n    context.originalWaypoints = connection.waypoints.slice(); // add dragger gfx\n\n    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);\n    svgClasses(context.draggerGfx).add('djs-dragging');\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n  eventBus.on('connectionSegment.move.move', function (event) {\n    var context = event.context,\n        connection = context.connection,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEndIndex = context.segmentEndIndex,\n        segmentStart = context.segmentStart,\n        segmentEnd = context.segmentEnd,\n        axis = context.axis;\n    var newWaypoints = context.originalWaypoints.slice(),\n        newSegmentStart = axisAdd(segmentStart, axis, event['d' + axis]),\n        newSegmentEnd = axisAdd(segmentEnd, axis, event['d' + axis]); // original waypoint count and added / removed\n    // from start waypoint delta. We use the later\n    // to retrieve the updated segmentStartIndex / segmentEndIndex\n\n    var waypointCount = newWaypoints.length,\n        segmentOffset = 0; // move segment start / end by axis delta\n\n    newWaypoints[segmentStartIndex] = newSegmentStart;\n    newWaypoints[segmentEndIndex] = newSegmentEnd;\n    var sourceToSegmentOrientation, targetToSegmentOrientation; // handle first segment\n\n    if (segmentStartIndex < 2) {\n      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart); // first bendpoint, remove first segment if intersecting\n\n      if (segmentStartIndex === 1) {\n        if (sourceToSegmentOrientation === 'intersect') {\n          newWaypoints.shift();\n          newWaypoints[0] = newSegmentStart;\n          segmentOffset--;\n        }\n      } // docking point, add segment if not intersecting anymore\n      else {\n        if (sourceToSegmentOrientation !== 'intersect') {\n          newWaypoints.unshift(segmentStart);\n          segmentOffset++;\n        }\n      }\n    } // handle last segment\n\n\n    if (segmentEndIndex > waypointCount - 3) {\n      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd); // last bendpoint, remove last segment if intersecting\n\n      if (segmentEndIndex === waypointCount - 2) {\n        if (targetToSegmentOrientation === 'intersect') {\n          newWaypoints.pop();\n          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;\n        }\n      } // last bendpoint, remove last segment if intersecting\n      else {\n        if (targetToSegmentOrientation !== 'intersect') {\n          newWaypoints.push(segmentEnd);\n        }\n      }\n    } // update connection waypoints\n\n\n    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints); // update dragger position\n\n    updateDragger(context, segmentOffset, event); // save segmentOffset in context\n\n    context.newSegmentStartIndex = segmentStartIndex + segmentOffset; // redraw connection\n\n    redrawConnection(event);\n  });\n  eventBus.on('connectionSegment.move.hover', function (event) {\n    event.context.hover = event.hover;\n    canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);\n  });\n  eventBus.on(['connectionSegment.move.out', 'connectionSegment.move.cleanup'], function (event) {\n    // remove connect marker\n    // if it was added\n    var hover = event.context.hover;\n\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n    }\n  });\n  eventBus.on('connectionSegment.move.cleanup', function (event) {\n    var context = event.context,\n        connection = context.connection; // remove dragger gfx\n\n    if (context.draggerGfx) {\n      svgRemove(context.draggerGfx);\n    }\n\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n  eventBus.on(['connectionSegment.move.cancel', 'connectionSegment.move.end'], function (event) {\n    var context = event.context,\n        connection = context.connection;\n    connection.waypoints = context.originalWaypoints;\n    redrawConnection(event);\n  });\n  eventBus.on('connectionSegment.move.end', function (event) {\n    var context = event.context,\n        connection = context.connection,\n        newWaypoints = context.newWaypoints,\n        newSegmentStartIndex = context.newSegmentStartIndex; // ensure we have actual pixel values bendpoint\n    // coordinates (important when zoom level was > 1 during move)\n\n    newWaypoints = newWaypoints.map(function (p) {\n      return {\n        original: p.original,\n        x: Math.round(p.x),\n        y: Math.round(p.y)\n      };\n    }); // apply filter redunant waypoints\n\n    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex); // get filtered waypoints\n\n    var filteredWaypoints = filtered.waypoints,\n        croppedWaypoints = cropConnection(connection, filteredWaypoints),\n        segmentOffset = filtered.segmentOffset;\n    var hints = {\n      segmentMove: {\n        segmentStartIndex: context.segmentStartIndex,\n        newSegmentStartIndex: newSegmentStartIndex + segmentOffset\n      }\n    };\n    modeling.updateWaypoints(connection, croppedWaypoints, hints);\n  });\n}\nConnectionSegmentMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'modeling'];","map":{"version":3,"names":["pointsAligned","pointsOnLine","addSegmentDragger","getConnectionIntersection","getMid","getOrientation","MARKER_CONNECT_HOVER","MARKER_CONNECT_UPDATING","classes","svgClasses","remove","svgRemove","translate","axisAdd","point","axis","delta","axisSet","value","x","y","axisFenced","position","segmentStart","segmentEnd","maxValue","Math","max","minValue","min","padding","fencedValue","flipAxis","getDocking","referenceElement","moveAxis","referenceMid","inverseAxis","original","ConnectionSegmentMove","injector","eventBus","canvas","dragging","graphicsFactory","modeling","connectionDocking","get","start","event","connection","idx","context","gfx","getGraphics","segmentStartIndex","segmentEndIndex","waypoints","intersection","direction","dragPosition","source","length","target","init","cursor","data","connectionGfx","cropConnection","newWaypoints","oldWaypoints","croppedWaypoints","getCroppedWaypoints","redrawConnection","update","updateDragger","segmentOffset","draggerPosition","draggerGfx","filterRedundantWaypoints","filteredWaypoints","filter","r","on","layer","getLayer","originalWaypoints","slice","add","addMarker","newSegmentStart","newSegmentEnd","waypointCount","sourceToSegmentOrientation","targetToSegmentOrientation","shift","unshift","pop","push","newSegmentStartIndex","hover","removeMarker","map","p","round","filtered","hints","segmentMove","updateWaypoints","$inject"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js"],"sourcesContent":["import {\n  pointsAligned,\n  pointsOnLine\n} from '../../util/Geometry';\n\nimport {\n  addSegmentDragger,\n  getConnectionIntersection\n} from './BendpointUtil';\n\nimport {\n  getMid,\n  getOrientation\n} from '../../layout/LayoutUtil';\n\nvar MARKER_CONNECT_HOVER = 'connect-hover',\n    MARKER_CONNECT_UPDATING = 'djs-updating';\n\nimport {\n  classes as svgClasses,\n  remove as svgRemove\n} from 'tiny-svg';\n\nimport {\n  translate\n} from '../../util/SvgTransformUtil';\n\n\nfunction axisAdd(point, axis, delta) {\n  return axisSet(point, axis, point[axis] + delta);\n}\n\nfunction axisSet(point, axis, value) {\n  return {\n    x: (axis === 'x' ? value : point.x),\n    y: (axis === 'y' ? value : point.y)\n  };\n}\n\nfunction axisFenced(position, segmentStart, segmentEnd, axis) {\n\n  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),\n      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);\n\n  var padding = 20;\n\n  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);\n\n  return axisSet(segmentStart, axis, fencedValue);\n}\n\nfunction flipAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Get the docking point on the given element.\n *\n * Compute a reasonable docking, if non exists.\n *\n * @param  {Point} point\n * @param  {djs.model.Shape} referenceElement\n * @param  {string} moveAxis (x|y)\n *\n * @return {Point}\n */\nfunction getDocking(point, referenceElement, moveAxis) {\n\n  var referenceMid,\n      inverseAxis;\n\n  if (point.original) {\n    return point.original;\n  } else {\n    referenceMid = getMid(referenceElement);\n    inverseAxis = flipAxis(moveAxis);\n\n    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);\n  }\n}\n\n/**\n * A component that implements moving of bendpoints\n */\nexport default function ConnectionSegmentMove(\n    injector, eventBus, canvas,\n    dragging, graphicsFactory, modeling) {\n\n  // optional connection docking integration\n  var connectionDocking = injector.get('connectionDocking', false);\n\n\n  // API\n\n  this.start = function(event, connection, idx) {\n\n    var context,\n        gfx = canvas.getGraphics(connection),\n        segmentStartIndex = idx - 1,\n        segmentEndIndex = idx,\n        waypoints = connection.waypoints,\n        segmentStart = waypoints[segmentStartIndex],\n        segmentEnd = waypoints[segmentEndIndex],\n        intersection = getConnectionIntersection(canvas, waypoints, event),\n        direction, axis, dragPosition;\n\n    direction = pointsAligned(segmentStart, segmentEnd);\n\n    // do not move diagonal connection\n    if (!direction) {\n      return;\n    }\n\n    // the axis where we are going to move things\n    axis = direction === 'v' ? 'x' : 'y';\n\n    if (segmentStartIndex === 0) {\n      segmentStart = getDocking(segmentStart, connection.source, axis);\n    }\n\n    if (segmentEndIndex === waypoints.length - 1) {\n      segmentEnd = getDocking(segmentEnd, connection.target, axis);\n    }\n\n    if (intersection) {\n      dragPosition = intersection.point;\n    } else {\n\n      // set to segment center as default\n      dragPosition = {\n        x: (segmentStart.x + segmentEnd.x) / 2,\n        y: (segmentStart.y + segmentEnd.y) / 2\n      };\n    }\n\n    context = {\n      connection: connection,\n      segmentStartIndex: segmentStartIndex,\n      segmentEndIndex: segmentEndIndex,\n      segmentStart: segmentStart,\n      segmentEnd: segmentEnd,\n      axis: axis,\n      dragPosition: dragPosition\n    };\n\n    dragging.init(event, dragPosition, 'connectionSegment.move', {\n      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: context\n      }\n    });\n  };\n\n  /**\n   * Crop connection if connection cropping is provided.\n   *\n   * @param {Connection} connection\n   * @param {Array<Point>} newWaypoints\n   *\n   * @return {Array<Point>} cropped connection waypoints\n   */\n  function cropConnection(connection, newWaypoints) {\n\n    // crop connection, if docking service is provided only\n    if (!connectionDocking) {\n      return newWaypoints;\n    }\n\n    var oldWaypoints = connection.waypoints,\n        croppedWaypoints;\n\n    // temporary set new waypoints\n    connection.waypoints = newWaypoints;\n\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);\n\n    // restore old waypoints\n    connection.waypoints = oldWaypoints;\n\n    return croppedWaypoints;\n  }\n\n  // DRAGGING IMPLEMENTATION\n\n  function redrawConnection(data) {\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\n  }\n\n  function updateDragger(context, segmentOffset, event) {\n\n    var newWaypoints = context.newWaypoints,\n        segmentStartIndex = context.segmentStartIndex + segmentOffset,\n        segmentStart = newWaypoints[segmentStartIndex],\n        segmentEndIndex = context.segmentEndIndex + segmentOffset,\n        segmentEnd = newWaypoints[segmentEndIndex],\n        axis = flipAxis(context.axis);\n\n    // make sure the dragger does not move\n    // outside the connection\n    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);\n\n    // update dragger\n    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);\n  }\n\n  /**\n   * Filter waypoints for redundant ones (i.e. on the same axis).\n   * Returns the filtered waypoints and the offset related to the segment move.\n   *\n   * @param {Array<Point>} waypoints\n   * @param {Integer} segmentStartIndex of moved segment start\n   *\n   * @return {Object} { filteredWaypoints, segmentOffset }\n   */\n  function filterRedundantWaypoints(waypoints, segmentStartIndex) {\n\n    var segmentOffset = 0;\n\n    var filteredWaypoints = waypoints.filter(function(r, idx) {\n      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {\n\n        // remove point and increment offset\n        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;\n        return false;\n      }\n\n      // dont remove point\n      return true;\n    });\n\n    return {\n      waypoints: filteredWaypoints,\n      segmentOffset: segmentOffset\n    };\n  }\n\n  eventBus.on('connectionSegment.move.start', function(event) {\n\n    var context = event.context,\n        connection = event.connection,\n        layer = canvas.getLayer('overlays');\n\n    context.originalWaypoints = connection.waypoints.slice();\n\n    // add dragger gfx\n    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);\n    svgClasses(context.draggerGfx).add('djs-dragging');\n\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n\n  eventBus.on('connectionSegment.move.move', function(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEndIndex = context.segmentEndIndex,\n        segmentStart = context.segmentStart,\n        segmentEnd = context.segmentEnd,\n        axis = context.axis;\n\n    var newWaypoints = context.originalWaypoints.slice(),\n        newSegmentStart = axisAdd(segmentStart, axis, event['d' + axis]),\n        newSegmentEnd = axisAdd(segmentEnd, axis, event['d' + axis]);\n\n    // original waypoint count and added / removed\n    // from start waypoint delta. We use the later\n    // to retrieve the updated segmentStartIndex / segmentEndIndex\n    var waypointCount = newWaypoints.length,\n        segmentOffset = 0;\n\n    // move segment start / end by axis delta\n    newWaypoints[segmentStartIndex] = newSegmentStart;\n    newWaypoints[segmentEndIndex] = newSegmentEnd;\n\n    var sourceToSegmentOrientation,\n        targetToSegmentOrientation;\n\n    // handle first segment\n    if (segmentStartIndex < 2) {\n      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);\n\n      // first bendpoint, remove first segment if intersecting\n      if (segmentStartIndex === 1) {\n\n        if (sourceToSegmentOrientation === 'intersect') {\n          newWaypoints.shift();\n          newWaypoints[0] = newSegmentStart;\n          segmentOffset--;\n        }\n      }\n\n      // docking point, add segment if not intersecting anymore\n      else {\n        if (sourceToSegmentOrientation !== 'intersect') {\n          newWaypoints.unshift(segmentStart);\n          segmentOffset++;\n        }\n      }\n    }\n\n    // handle last segment\n    if (segmentEndIndex > waypointCount - 3) {\n      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);\n\n      // last bendpoint, remove last segment if intersecting\n      if (segmentEndIndex === waypointCount - 2) {\n\n        if (targetToSegmentOrientation === 'intersect') {\n          newWaypoints.pop();\n          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;\n        }\n      }\n\n      // last bendpoint, remove last segment if intersecting\n      else {\n        if (targetToSegmentOrientation !== 'intersect') {\n          newWaypoints.push(segmentEnd);\n        }\n      }\n    }\n\n    // update connection waypoints\n    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);\n\n    // update dragger position\n    updateDragger(context, segmentOffset, event);\n\n    // save segmentOffset in context\n    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;\n\n    // redraw connection\n    redrawConnection(event);\n  });\n\n  eventBus.on('connectionSegment.move.hover', function(event) {\n\n    event.context.hover = event.hover;\n    canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);\n  });\n\n  eventBus.on([\n    'connectionSegment.move.out',\n    'connectionSegment.move.cleanup'\n  ], function(event) {\n\n    // remove connect marker\n    // if it was added\n    var hover = event.context.hover;\n\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n    }\n  });\n\n  eventBus.on('connectionSegment.move.cleanup', function(event) {\n\n    var context = event.context,\n        connection = context.connection;\n\n    // remove dragger gfx\n    if (context.draggerGfx) {\n      svgRemove(context.draggerGfx);\n    }\n\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n\n  eventBus.on([\n    'connectionSegment.move.cancel',\n    'connectionSegment.move.end'\n  ], function(event) {\n    var context = event.context,\n        connection = context.connection;\n\n    connection.waypoints = context.originalWaypoints;\n\n    redrawConnection(event);\n  });\n\n  eventBus.on('connectionSegment.move.end', function(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        newWaypoints = context.newWaypoints,\n        newSegmentStartIndex = context.newSegmentStartIndex;\n\n    // ensure we have actual pixel values bendpoint\n    // coordinates (important when zoom level was > 1 during move)\n    newWaypoints = newWaypoints.map(function(p) {\n      return {\n        original: p.original,\n        x: Math.round(p.x),\n        y: Math.round(p.y)\n      };\n    });\n\n    // apply filter redunant waypoints\n    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);\n\n    // get filtered waypoints\n    var filteredWaypoints = filtered.waypoints,\n        croppedWaypoints = cropConnection(connection, filteredWaypoints),\n        segmentOffset = filtered.segmentOffset;\n\n    var hints = {\n      segmentMove: {\n        segmentStartIndex: context.segmentStartIndex,\n        newSegmentStartIndex: newSegmentStartIndex + segmentOffset\n      }\n    };\n\n    modeling.updateWaypoints(connection, croppedWaypoints, hints);\n  });\n}\n\nConnectionSegmentMove.$inject = [\n  'injector',\n  'eventBus',\n  'canvas',\n  'dragging',\n  'graphicsFactory',\n  'modeling'\n];\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}