{"ast":null,"code":"import inherits from 'inherits-browser';\nimport { assign, filter, find, isNumber } from 'min-dash';\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { getApproxIntersection } from 'diagram-js/lib/util/LineIntersection';\nexport default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, positionOrBounds) {\n    var waypoints = targetFlow.waypoints,\n        waypointsBefore,\n        waypointsAfter,\n        dockingPoint,\n        source,\n        target,\n        incomingConnection,\n        outgoingConnection,\n        oldOutgoing = shape.outgoing.slice(),\n        oldIncoming = shape.incoming.slice();\n    var mid;\n\n    if (isNumber(positionOrBounds.width)) {\n      mid = getMid(positionOrBounds);\n    } else {\n      mid = positionOrBounds;\n    }\n\n    var intersection = getApproxIntersection(waypoints, mid);\n\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0)); // due to inaccuracy intersection might have been found\n\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid; // if last waypointBefore is inside shape's bounds, ignore docking point\n\n      if (waypointsBefore.length === 1 || !isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      } // if first waypointAfter is inside shape's bounds, ignore docking point\n\n\n      if (waypointsAfter.length === 1 || !isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n\n    source = targetFlow.source;\n    target = targetFlow.target;\n\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);\n      incomingConnection = targetFlow;\n    }\n\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n      if (!incomingConnection) {\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(shape, target, {\n          type: targetFlow.type,\n          waypoints: waypointsAfter\n        });\n      }\n    }\n\n    var duplicateConnections = [].concat(incomingConnection && filter(oldIncoming, function (connection) {\n      return connection.source === incomingConnection.source;\n    }) || [], outgoingConnection && filter(oldOutgoing, function (connection) {\n      return connection.target === outgoingConnection.target;\n    }) || []);\n\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n\n  this.preExecute('elements.move', function (context) {\n    var newParent = context.newParent,\n        shapes = context.shapes,\n        delta = context.delta,\n        shape = shapes[0];\n\n    if (!shape || !newParent) {\n      return;\n    } // if the new parent is a connection,\n    // change it to the new parent's parent\n\n\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    }; // find a connection which intersects with the\n    // element's mid point\n\n    var connection = find(newParent.children, function (element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n  }, true);\n  this.postExecuted('elements.move', function (context) {\n    var shapes = context.shapes,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n  }, true);\n  this.preExecute('shape.create', function (context) {\n    var parent = context.parent,\n        shape = context.shape;\n\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n  this.postExecuted('shape.create', function (context) {\n    var shape = context.shape,\n        targetFlow = context.targetFlow,\n        positionOrBounds = context.position;\n\n    if (targetFlow) {\n      insertShape(shape, targetFlow, positionOrBounds);\n    }\n  }, true);\n}\ninherits(DropOnFlowBehavior, CommandInterceptor);\nDropOnFlowBehavior.$inject = ['eventBus', 'bpmnRules', 'modeling']; // helpers /////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n}\n\nfunction copy(obj) {\n  return assign({}, obj);\n}","map":{"version":3,"names":["inherits","assign","filter","find","isNumber","getMid","CommandInterceptor","getApproxIntersection","DropOnFlowBehavior","eventBus","bpmnRules","modeling","call","insertShape","shape","targetFlow","positionOrBounds","waypoints","waypointsBefore","waypointsAfter","dockingPoint","source","target","incomingConnection","outgoingConnection","oldOutgoing","outgoing","slice","oldIncoming","incoming","mid","width","intersection","index","bendpoint","length","isPointInsideBBox","push","copy","unshift","canConnect","reconnectEnd","reconnectStart","connect","type","duplicateConnections","concat","connection","removeElements","preExecute","context","newParent","shapes","delta","parent","shapeMid","newShapeMid","x","y","children","element","canInsert","position","postExecuted","$inject","bbox","point","height","obj"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/features/modeling/behavior/DropOnFlowBehavior.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport {\n  assign,\n  filter,\n  find,\n  isNumber\n} from 'min-dash';\n\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport {\n  getApproxIntersection\n} from 'diagram-js/lib/util/LineIntersection';\n\n\nexport default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, positionOrBounds) {\n    var waypoints = targetFlow.waypoints,\n        waypointsBefore,\n        waypointsAfter,\n        dockingPoint,\n        source,\n        target,\n        incomingConnection,\n        outgoingConnection,\n        oldOutgoing = shape.outgoing.slice(),\n        oldIncoming = shape.incoming.slice();\n\n    var mid;\n\n    if (isNumber(positionOrBounds.width)) {\n      mid = getMid(positionOrBounds);\n    } else {\n      mid = positionOrBounds;\n    }\n\n    var intersection = getApproxIntersection(waypoints, mid);\n\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));\n\n      // due to inaccuracy intersection might have been found\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid;\n\n      // if last waypointBefore is inside shape's bounds, ignore docking point\n      if (waypointsBefore.length === 1 || !isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      }\n\n      // if first waypointAfter is inside shape's bounds, ignore docking point\n      if (waypointsAfter.length === 1 || !isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n\n    source = targetFlow.source;\n    target = targetFlow.target;\n\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);\n\n      incomingConnection = targetFlow;\n    }\n\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n\n      if (!incomingConnection) {\n\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);\n\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(\n          shape, target, { type: targetFlow.type, waypoints: waypointsAfter }\n        );\n      }\n    }\n\n    var duplicateConnections = [].concat(\n\n      incomingConnection && filter(oldIncoming, function(connection) {\n        return connection.source === incomingConnection.source;\n      }) || [],\n\n      outgoingConnection && filter(oldOutgoing, function(connection) {\n        return connection.target === outgoingConnection.target;\n      }) || []\n    );\n\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n\n  this.preExecute('elements.move', function(context) {\n\n    var newParent = context.newParent,\n        shapes = context.shapes,\n        delta = context.delta,\n        shape = shapes[0];\n\n    if (!shape || !newParent) {\n      return;\n    }\n\n    // if the new parent is a connection,\n    // change it to the new parent's parent\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    };\n\n    // find a connection which intersects with the\n    // element's mid point\n    var connection = find(newParent.children, function(element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n\n  }, true);\n\n  this.postExecuted('elements.move', function(context) {\n\n    var shapes = context.shapes,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n\n  }, true);\n\n  this.preExecute('shape.create', function(context) {\n\n    var parent = context.parent,\n        shape = context.shape;\n\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n\n  this.postExecuted('shape.create', function(context) {\n\n    var shape = context.shape,\n        targetFlow = context.targetFlow,\n        positionOrBounds = context.position;\n\n    if (targetFlow) {\n      insertShape(shape, targetFlow, positionOrBounds);\n    }\n  }, true);\n}\n\ninherits(DropOnFlowBehavior, CommandInterceptor);\n\nDropOnFlowBehavior.$inject = [\n  'eventBus',\n  'bpmnRules',\n  'modeling'\n];\n\n\n// helpers /////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n\n  return x >= bbox.x &&\n    x <= bbox.x + bbox.width &&\n    y >= bbox.y &&\n    y <= bbox.y + bbox.height;\n}\n\nfunction copy(obj) {\n  return assign({}, obj);\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}