{"ast":null,"code":"import { filter, forEach, isArray, sortBy } from 'min-dash';\n\nfunction last(arr) {\n  return arr && arr[arr.length - 1];\n}\n\nfunction sortTopOrMiddle(element) {\n  return element.y;\n}\n\nfunction sortLeftOrCenter(element) {\n  return element.x;\n}\n/**\n * Sorting functions for different types of alignment\n *\n * @type {Object}\n *\n * @return {Function}\n */\n\n\nvar ALIGNMENT_SORTING = {\n  left: sortLeftOrCenter,\n  center: sortLeftOrCenter,\n  right: function (element) {\n    return element.x + element.width;\n  },\n  top: sortTopOrMiddle,\n  middle: sortTopOrMiddle,\n  bottom: function (element) {\n    return element.y + element.height;\n  }\n};\nexport default function AlignElements(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\nAlignElements.$inject = ['modeling', 'rules'];\n/**\n * Get the relevant \"axis\" and \"dimension\" related to the current type of alignment\n *\n * @param  {string} type left|right|center|top|bottom|middle\n *\n * @return {Object} { axis, dimension }\n */\n\nAlignElements.prototype._getOrientationDetails = function (type) {\n  var vertical = ['top', 'bottom', 'middle'],\n      axis = 'x',\n      dimension = 'width';\n\n  if (vertical.indexOf(type) !== -1) {\n    axis = 'y';\n    dimension = 'height';\n  }\n\n  return {\n    axis: axis,\n    dimension: dimension\n  };\n};\n\nAlignElements.prototype._isType = function (type, types) {\n  return types.indexOf(type) !== -1;\n};\n/**\n * Get a point on the relevant axis where elements should align to\n *\n * @param  {string} type left|right|center|top|bottom|middle\n * @param  {Array} sortedElements\n *\n * @return {Object}\n */\n\n\nAlignElements.prototype._alignmentPosition = function (type, sortedElements) {\n  var orientation = this._getOrientationDetails(type),\n      axis = orientation.axis,\n      dimension = orientation.dimension,\n      alignment = {},\n      centers = {},\n      hasSharedCenters = false,\n      centeredElements,\n      firstElement,\n      lastElement;\n\n  function getMiddleOrTop(first, last) {\n    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);\n  }\n\n  if (this._isType(type, ['left', 'top'])) {\n    alignment[type] = sortedElements[0][axis];\n  } else if (this._isType(type, ['right', 'bottom'])) {\n    lastElement = last(sortedElements);\n    alignment[type] = lastElement[axis] + lastElement[dimension];\n  } else if (this._isType(type, ['center', 'middle'])) {\n    // check if there is a center shared by more than one shape\n    // if not, just take the middle of the range\n    forEach(sortedElements, function (element) {\n      var center = element[axis] + Math.round(element[dimension] / 2);\n\n      if (centers[center]) {\n        centers[center].elements.push(element);\n      } else {\n        centers[center] = {\n          elements: [element],\n          center: center\n        };\n      }\n    });\n    centeredElements = sortBy(centers, function (center) {\n      if (center.elements.length > 1) {\n        hasSharedCenters = true;\n      }\n\n      return center.elements.length;\n    });\n\n    if (hasSharedCenters) {\n      alignment[type] = last(centeredElements).center;\n      return alignment;\n    }\n\n    firstElement = sortedElements[0];\n    sortedElements = sortBy(sortedElements, function (element) {\n      return element[axis] + element[dimension];\n    });\n    lastElement = last(sortedElements);\n    alignment[type] = getMiddleOrTop(firstElement, lastElement);\n  }\n\n  return alignment;\n};\n/**\n * Executes the alignment of a selection of elements\n *\n * @param  {Array} elements\n * @param  {string} type left|right|center|top|bottom|middle\n */\n\n\nAlignElements.prototype.trigger = function (elements, type) {\n  var modeling = this._modeling,\n      allowed; // filter out elements which cannot be aligned\n\n  var filteredElements = filter(elements, function (element) {\n    return !(element.waypoints || element.host || element.labelTarget);\n  }); // filter out elements via rules\n\n  allowed = this._rules.allowed('elements.align', {\n    elements: filteredElements\n  });\n\n  if (isArray(allowed)) {\n    filteredElements = allowed;\n  }\n\n  if (filteredElements.length < 2 || !allowed) {\n    return;\n  }\n\n  var sortFn = ALIGNMENT_SORTING[type];\n  var sortedElements = sortBy(filteredElements, sortFn);\n\n  var alignment = this._alignmentPosition(type, sortedElements);\n\n  modeling.alignElements(sortedElements, alignment);\n};","map":{"version":3,"names":["filter","forEach","isArray","sortBy","last","arr","length","sortTopOrMiddle","element","y","sortLeftOrCenter","x","ALIGNMENT_SORTING","left","center","right","width","top","middle","bottom","height","AlignElements","modeling","rules","_modeling","_rules","$inject","prototype","_getOrientationDetails","type","vertical","axis","dimension","indexOf","_isType","types","_alignmentPosition","sortedElements","orientation","alignment","centers","hasSharedCenters","centeredElements","firstElement","lastElement","getMiddleOrTop","first","Math","round","elements","push","trigger","allowed","filteredElements","waypoints","host","labelTarget","sortFn","alignElements"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/align-elements/AlignElements.js"],"sourcesContent":["import {\n  filter,\n  forEach,\n  isArray,\n  sortBy\n} from 'min-dash';\n\nfunction last(arr) {\n  return arr && arr[arr.length - 1];\n}\n\nfunction sortTopOrMiddle(element) {\n  return element.y;\n}\n\nfunction sortLeftOrCenter(element) {\n  return element.x;\n}\n\n/**\n * Sorting functions for different types of alignment\n *\n * @type {Object}\n *\n * @return {Function}\n */\nvar ALIGNMENT_SORTING = {\n  left: sortLeftOrCenter,\n  center: sortLeftOrCenter,\n  right: function(element) {\n    return element.x + element.width;\n  },\n  top: sortTopOrMiddle,\n  middle: sortTopOrMiddle,\n  bottom: function(element) {\n    return element.y + element.height;\n  }\n};\n\n\nexport default function AlignElements(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\n\nAlignElements.$inject = [ 'modeling', 'rules' ];\n\n\n/**\n * Get the relevant \"axis\" and \"dimension\" related to the current type of alignment\n *\n * @param  {string} type left|right|center|top|bottom|middle\n *\n * @return {Object} { axis, dimension }\n */\nAlignElements.prototype._getOrientationDetails = function(type) {\n  var vertical = [ 'top', 'bottom', 'middle' ],\n      axis = 'x',\n      dimension = 'width';\n\n  if (vertical.indexOf(type) !== -1) {\n    axis = 'y';\n    dimension = 'height';\n  }\n\n  return {\n    axis: axis,\n    dimension: dimension\n  };\n};\n\nAlignElements.prototype._isType = function(type, types) {\n  return types.indexOf(type) !== -1;\n};\n\n/**\n * Get a point on the relevant axis where elements should align to\n *\n * @param  {string} type left|right|center|top|bottom|middle\n * @param  {Array} sortedElements\n *\n * @return {Object}\n */\nAlignElements.prototype._alignmentPosition = function(type, sortedElements) {\n  var orientation = this._getOrientationDetails(type),\n      axis = orientation.axis,\n      dimension = orientation.dimension,\n      alignment = {},\n      centers = {},\n      hasSharedCenters = false,\n      centeredElements,\n      firstElement,\n      lastElement;\n\n  function getMiddleOrTop(first, last) {\n    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);\n  }\n\n  if (this._isType(type, [ 'left', 'top' ])) {\n    alignment[type] = sortedElements[0][axis];\n\n  } else if (this._isType(type, [ 'right', 'bottom' ])) {\n    lastElement = last(sortedElements);\n\n    alignment[type] = lastElement[axis] + lastElement[dimension];\n\n  } else if (this._isType(type, [ 'center', 'middle' ])) {\n\n    // check if there is a center shared by more than one shape\n    // if not, just take the middle of the range\n    forEach(sortedElements, function(element) {\n      var center = element[axis] + Math.round(element[dimension] / 2);\n\n      if (centers[center]) {\n        centers[center].elements.push(element);\n      } else {\n        centers[center] = {\n          elements: [ element ],\n          center: center\n        };\n      }\n    });\n\n    centeredElements = sortBy(centers, function(center) {\n      if (center.elements.length > 1) {\n        hasSharedCenters = true;\n      }\n\n      return center.elements.length;\n    });\n\n    if (hasSharedCenters) {\n      alignment[type] = last(centeredElements).center;\n\n      return alignment;\n    }\n\n    firstElement = sortedElements[0];\n\n    sortedElements = sortBy(sortedElements, function(element) {\n      return element[axis] + element[dimension];\n    });\n\n    lastElement = last(sortedElements);\n\n    alignment[type] = getMiddleOrTop(firstElement, lastElement);\n  }\n\n  return alignment;\n};\n\n/**\n * Executes the alignment of a selection of elements\n *\n * @param  {Array} elements\n * @param  {string} type left|right|center|top|bottom|middle\n */\nAlignElements.prototype.trigger = function(elements, type) {\n  var modeling = this._modeling,\n      allowed;\n\n  // filter out elements which cannot be aligned\n  var filteredElements = filter(elements, function(element) {\n    return !(element.waypoints || element.host || element.labelTarget);\n  });\n\n  // filter out elements via rules\n  allowed = this._rules.allowed('elements.align', { elements: filteredElements });\n  if (isArray(allowed)) {\n    filteredElements = allowed;\n  }\n\n  if (filteredElements.length < 2 || !allowed) {\n    return;\n  }\n\n  var sortFn = ALIGNMENT_SORTING[type];\n\n  var sortedElements = sortBy(filteredElements, sortFn);\n\n  var alignment = this._alignmentPosition(type, sortedElements);\n\n  modeling.alignElements(sortedElements, alignment);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}