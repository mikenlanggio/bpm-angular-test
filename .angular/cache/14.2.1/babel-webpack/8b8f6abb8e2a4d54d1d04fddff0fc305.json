{"ast":null,"code":"import { getDistancePointPoint, rotateVector, getAngle } from './GeometricUtil';\nimport { getAttachment } from './LineAttachmentUtil';\nimport { roundPoint } from 'diagram-js/lib/layout/LayoutUtil';\nexport function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {\n  var index = attachment.segmentIndex;\n  var offset = newWaypoints.length - oldWaypoints.length; // segmentMove happened\n\n  if (hints.segmentMove) {\n    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,\n        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex; // if point was on moved segment return new segment index\n\n    if (index === oldSegmentStartIndex) {\n      return newSegmentStartIndex;\n    } // point is after new segment index\n\n\n    if (index >= newSegmentStartIndex) {\n      return index + offset < newSegmentStartIndex ? newSegmentStartIndex : index + offset;\n    } // if point is before new segment index\n\n\n    return index;\n  } // bendpointMove happened\n\n\n  if (hints.bendpointMove) {\n    var insert = hints.bendpointMove.insert,\n        bendpointIndex = hints.bendpointMove.bendpointIndex,\n        newIndex; // waypoints length didnt change\n\n    if (offset === 0) {\n      return index;\n    } // point behind new/removed bendpoint\n\n\n    if (index >= bendpointIndex) {\n      newIndex = insert ? index + 1 : index - 1;\n    } // point before new/removed bendpoint\n\n\n    if (index < bendpointIndex) {\n      newIndex = index; // decide point should take right or left segment\n\n      if (insert && attachment.type !== 'bendpoint' && bendpointIndex - 1 === index) {\n        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);\n\n        if (rel < attachment.relativeLocation) {\n          newIndex++;\n        }\n      }\n    }\n\n    return newIndex;\n  } // start/end changed\n\n\n  if (offset === 0) {\n    return index;\n  }\n\n  if (hints.connectionStart && index === 0) {\n    return 0;\n  }\n\n  if (hints.connectionEnd && index === oldWaypoints.length - 2) {\n    return newWaypoints.length - 2;\n  } // if nothing fits, take the middle segment\n\n\n  return Math.floor((newWaypoints.length - 2) / 2);\n}\n/**\n * Calculate the required adjustment (move delta) for the given point\n * after the connection waypoints got updated.\n *\n * @param {Point} position\n * @param {Array<Point>} newWaypoints\n * @param {Array<Point>} oldWaypoints\n * @param {Object} hints\n *\n * @return {Object} result\n * @return {Point} result.point\n * @return {Point} result.delta\n */\n\nexport function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {\n  var dx = 0,\n      dy = 0;\n  var oldPosition = {\n    point: position,\n    delta: {\n      x: 0,\n      y: 0\n    }\n  }; // get closest attachment\n\n  var attachment = getAttachment(position, oldWaypoints),\n      oldLabelLineIndex = attachment.segmentIndex,\n      newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints); // should never happen\n  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored\n\n  if (newLabelLineIndex < 0 || newLabelLineIndex > newWaypoints.length - 2 || newLabelLineIndex === null) {\n    return oldPosition;\n  }\n\n  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),\n      newLabelLine = getLine(newWaypoints, newLabelLineIndex),\n      oldFoot = attachment.position;\n  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),\n      angleDelta = getAngleDelta(oldLabelLine, newLabelLine); // special rule if label on bendpoint\n\n  if (attachment.type === 'bendpoint') {\n    var offset = newWaypoints.length - oldWaypoints.length,\n        oldBendpointIndex = attachment.bendpointIndex,\n        oldBendpoint = oldWaypoints[oldBendpointIndex]; // bendpoint position hasn't changed, return same position\n\n    if (newWaypoints.indexOf(oldBendpoint) !== -1) {\n      return oldPosition;\n    } // new bendpoint and old bendpoint have same index, then just return the offset\n\n\n    if (offset === 0) {\n      var newBendpoint = newWaypoints[oldBendpointIndex];\n      dx = newBendpoint.x - attachment.position.x, dy = newBendpoint.y - attachment.position.y;\n      return {\n        delta: {\n          x: dx,\n          y: dy\n        },\n        point: {\n          x: position.x + dx,\n          y: position.y + dy\n        }\n      };\n    } // if bendpoints get removed\n\n\n    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {\n      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);\n    }\n  }\n\n  var newFoot = {\n    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,\n    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y\n  }; // the rotated vector to label\n\n  var newLabelVector = rotateVector({\n    x: position.x - oldFoot.x,\n    y: position.y - oldFoot.y\n  }, angleDelta); // the new relative position\n\n  dx = newFoot.x + newLabelVector.x - position.x;\n  dy = newFoot.y + newLabelVector.y - position.y;\n  return {\n    point: roundPoint(newFoot),\n    delta: roundPoint({\n      x: dx,\n      y: dy\n    })\n  };\n} // HELPERS //////////////////////\n\nfunction relativePositionMidWaypoint(waypoints, idx) {\n  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]),\n      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);\n  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);\n  return relativePosition;\n}\n\nfunction getAngleDelta(l1, l2) {\n  var a1 = getAngle(l1),\n      a2 = getAngle(l2);\n  return a2 - a1;\n}\n\nfunction getLine(waypoints, idx) {\n  return [waypoints[idx], waypoints[idx + 1]];\n}\n\nfunction getRelativeFootPosition(line, foot) {\n  var length = getDistancePointPoint(line[0], line[1]),\n      lengthToFoot = getDistancePointPoint(line[0], foot);\n  return length === 0 ? 0 : lengthToFoot / length;\n}","map":{"version":3,"names":["getDistancePointPoint","rotateVector","getAngle","getAttachment","roundPoint","findNewLineStartIndex","oldWaypoints","newWaypoints","attachment","hints","index","segmentIndex","offset","length","segmentMove","oldSegmentStartIndex","segmentStartIndex","newSegmentStartIndex","bendpointMove","insert","bendpointIndex","newIndex","type","rel","relativePositionMidWaypoint","relativeLocation","connectionStart","connectionEnd","Math","floor","getAnchorPointAdjustment","position","dx","dy","oldPosition","point","delta","x","y","oldLabelLineIndex","newLabelLineIndex","oldLabelLine","getLine","newLabelLine","oldFoot","relativeFootPosition","getRelativeFootPosition","angleDelta","getAngleDelta","oldBendpointIndex","oldBendpoint","indexOf","newBendpoint","newFoot","newLabelVector","waypoints","idx","distanceSegment1","distanceSegment2","relativePosition","l1","l2","a1","a2","line","foot","lengthToFoot"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/features/modeling/behavior/util/LayoutUtil.js"],"sourcesContent":["import {\n  getDistancePointPoint,\n  rotateVector,\n  getAngle\n} from './GeometricUtil';\n\nimport {\n  getAttachment\n} from './LineAttachmentUtil';\n\nimport {\n  roundPoint\n} from 'diagram-js/lib/layout/LayoutUtil';\n\n\nexport function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {\n\n  var index = attachment.segmentIndex;\n\n  var offset = newWaypoints.length - oldWaypoints.length;\n\n  // segmentMove happened\n  if (hints.segmentMove) {\n\n    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,\n        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;\n\n    // if point was on moved segment return new segment index\n    if (index === oldSegmentStartIndex) {\n      return newSegmentStartIndex;\n    }\n\n    // point is after new segment index\n    if (index >= newSegmentStartIndex) {\n      return (index + offset < newSegmentStartIndex) ? newSegmentStartIndex : index + offset;\n    }\n\n    // if point is before new segment index\n    return index;\n  }\n\n  // bendpointMove happened\n  if (hints.bendpointMove) {\n\n    var insert = hints.bendpointMove.insert,\n        bendpointIndex = hints.bendpointMove.bendpointIndex,\n        newIndex;\n\n    // waypoints length didnt change\n    if (offset === 0) {\n      return index;\n    }\n\n    // point behind new/removed bendpoint\n    if (index >= bendpointIndex) {\n      newIndex = insert ? index + 1 : index - 1;\n    }\n\n    // point before new/removed bendpoint\n    if (index < bendpointIndex) {\n\n      newIndex = index;\n\n      // decide point should take right or left segment\n      if (insert && attachment.type !== 'bendpoint' && bendpointIndex - 1 === index) {\n\n        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);\n\n        if (rel < attachment.relativeLocation) {\n          newIndex++;\n        }\n      }\n    }\n\n    return newIndex;\n  }\n\n  // start/end changed\n  if (offset === 0) {\n    return index;\n  }\n\n  if (hints.connectionStart && index === 0) {\n    return 0;\n  }\n\n  if (hints.connectionEnd && index === oldWaypoints.length - 2) {\n    return newWaypoints.length - 2;\n  }\n\n  // if nothing fits, take the middle segment\n  return Math.floor((newWaypoints.length - 2) / 2);\n}\n\n\n/**\n * Calculate the required adjustment (move delta) for the given point\n * after the connection waypoints got updated.\n *\n * @param {Point} position\n * @param {Array<Point>} newWaypoints\n * @param {Array<Point>} oldWaypoints\n * @param {Object} hints\n *\n * @return {Object} result\n * @return {Point} result.point\n * @return {Point} result.delta\n */\nexport function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {\n\n  var dx = 0,\n      dy = 0;\n\n  var oldPosition = {\n    point: position,\n    delta: { x: 0, y: 0 }\n  };\n\n  // get closest attachment\n  var attachment = getAttachment(position, oldWaypoints),\n      oldLabelLineIndex = attachment.segmentIndex,\n      newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);\n\n\n  // should never happen\n  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored\n  if (newLabelLineIndex < 0 ||\n      newLabelLineIndex > newWaypoints.length - 2 ||\n      newLabelLineIndex === null) {\n    return oldPosition;\n  }\n\n  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),\n      newLabelLine = getLine(newWaypoints, newLabelLineIndex),\n      oldFoot = attachment.position;\n\n  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),\n      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);\n\n  // special rule if label on bendpoint\n  if (attachment.type === 'bendpoint') {\n\n    var offset = newWaypoints.length - oldWaypoints.length,\n        oldBendpointIndex = attachment.bendpointIndex,\n        oldBendpoint = oldWaypoints[oldBendpointIndex];\n\n    // bendpoint position hasn't changed, return same position\n    if (newWaypoints.indexOf(oldBendpoint) !== -1) {\n      return oldPosition;\n    }\n\n    // new bendpoint and old bendpoint have same index, then just return the offset\n    if (offset === 0) {\n      var newBendpoint = newWaypoints[oldBendpointIndex];\n\n      dx = newBendpoint.x - attachment.position.x,\n      dy = newBendpoint.y - attachment.position.y;\n\n      return {\n        delta: {\n          x: dx,\n          y: dy\n        },\n        point: {\n          x: position.x + dx,\n          y: position.y + dy\n        }\n      };\n    }\n\n    // if bendpoints get removed\n    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {\n      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);\n    }\n  }\n\n  var newFoot = {\n    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,\n    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y\n  };\n\n  // the rotated vector to label\n  var newLabelVector = rotateVector({\n    x: position.x - oldFoot.x,\n    y: position.y - oldFoot.y\n  }, angleDelta);\n\n  // the new relative position\n  dx = newFoot.x + newLabelVector.x - position.x;\n  dy = newFoot.y + newLabelVector.y - position.y;\n\n  return {\n    point: roundPoint(newFoot),\n    delta: roundPoint({\n      x: dx,\n      y: dy\n    })\n  };\n}\n\n\n// HELPERS //////////////////////\n\nfunction relativePositionMidWaypoint(waypoints, idx) {\n\n  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]),\n      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);\n\n  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);\n\n  return relativePosition;\n}\n\nfunction getAngleDelta(l1, l2) {\n  var a1 = getAngle(l1),\n      a2 = getAngle(l2);\n  return a2 - a1;\n}\n\nfunction getLine(waypoints, idx) {\n  return [ waypoints[idx], waypoints[idx + 1] ];\n}\n\nfunction getRelativeFootPosition(line, foot) {\n\n  var length = getDistancePointPoint(line[0], line[1]),\n      lengthToFoot = getDistancePointPoint(line[0], foot);\n\n  return length === 0 ? 0 : lengthToFoot / length;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}