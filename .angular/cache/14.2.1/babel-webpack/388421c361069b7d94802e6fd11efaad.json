{"ast":null,"code":"import { sortBy, forEach, isArray } from 'min-dash';\nvar AXIS_DIMENSIONS = {\n  horizontal: ['x', 'width'],\n  vertical: ['y', 'height']\n};\nvar THRESHOLD = 5;\n/**\n * Groups and filters elements and then trigger even distribution.\n */\n\nexport default function DistributeElements(modeling, rules) {\n  this._modeling = modeling;\n  this._filters = [];\n  this.registerFilter(function (elements) {\n    var allowed = rules.allowed('elements.distribute', {\n      elements: elements\n    });\n\n    if (isArray(allowed)) {\n      return allowed;\n    }\n\n    return allowed ? elements : [];\n  });\n}\nDistributeElements.$inject = ['modeling', 'rules'];\n/**\n * Registers filter functions that allow external parties to filter\n * out certain elements.\n *\n * @param  {Function} filterFn\n */\n\nDistributeElements.prototype.registerFilter = function (filterFn) {\n  if (typeof filterFn !== 'function') {\n    throw new Error('the filter has to be a function');\n  }\n\n  this._filters.push(filterFn);\n};\n/**\n * Distributes the elements with a given orientation\n *\n * @param  {Array} elements\n * @param  {string} orientation\n */\n\n\nDistributeElements.prototype.trigger = function (elements, orientation) {\n  var modeling = this._modeling;\n  var groups, distributableElements;\n\n  if (elements.length < 3) {\n    return;\n  }\n\n  this._setOrientation(orientation);\n\n  distributableElements = this._filterElements(elements);\n  groups = this._createGroups(distributableElements); // nothing to distribute\n\n  if (groups.length <= 2) {\n    return;\n  }\n\n  modeling.distributeElements(groups, this._axis, this._dimension);\n  return groups;\n};\n/**\n * Filters the elements with provided filters by external parties\n *\n * @param  {Array[Elements]} elements\n *\n * @return {Array[Elements]}\n */\n\n\nDistributeElements.prototype._filterElements = function (elements) {\n  var filters = this._filters,\n      axis = this._axis,\n      dimension = this._dimension,\n      distributableElements = [].concat(elements);\n\n  if (!filters.length) {\n    return elements;\n  }\n\n  forEach(filters, function (filterFn) {\n    distributableElements = filterFn(distributableElements, axis, dimension);\n  });\n  return distributableElements;\n};\n/**\n * Create range (min, max) groups. Also tries to group elements\n * together that share the same range.\n *\n * @example\n * \tvar distributableElements = [\n * \t\t{\n * \t\t\trange: {\n * \t\t\t\tmin: 100,\n * \t\t\t\tmax: 200\n * \t\t\t},\n * \t\t\telements: [ { id: 'shape1', .. }]\n * \t\t}\n * \t]\n *\n * @param  {Array} elements\n *\n * @return {Array[Objects]}\n */\n\n\nDistributeElements.prototype._createGroups = function (elements) {\n  var rangeGroups = [],\n      self = this,\n      axis = this._axis,\n      dimension = this._dimension;\n\n  if (!axis) {\n    throw new Error('must have a defined \"axis\" and \"dimension\"');\n  } // sort by 'left->right' or 'top->bottom'\n\n\n  var sortedElements = sortBy(elements, axis);\n  forEach(sortedElements, function (element, idx) {\n    var elementRange = self._findRange(element, axis, dimension),\n        range;\n\n    var previous = rangeGroups[rangeGroups.length - 1];\n\n    if (previous && self._hasIntersection(previous.range, elementRange)) {\n      rangeGroups[rangeGroups.length - 1].elements.push(element);\n    } else {\n      range = {\n        range: elementRange,\n        elements: [element]\n      };\n      rangeGroups.push(range);\n    }\n  });\n  return rangeGroups;\n};\n/**\n * Maps a direction to the according axis and dimension\n *\n * @param  {string} direction 'horizontal' or 'vertical'\n */\n\n\nDistributeElements.prototype._setOrientation = function (direction) {\n  var orientation = AXIS_DIMENSIONS[direction];\n  this._axis = orientation[0];\n  this._dimension = orientation[1];\n};\n/**\n * Checks if the two ranges intercept each other\n *\n * @param  {Object} rangeA {min, max}\n * @param  {Object} rangeB {min, max}\n *\n * @return {boolean}\n */\n\n\nDistributeElements.prototype._hasIntersection = function (rangeA, rangeB) {\n  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);\n};\n/**\n * Returns the min and max values for an element\n *\n * @param  {Bounds} element\n * @param  {string} axis\n * @param  {string} dimension\n *\n * @return {{ min: number, max: number }}\n */\n\n\nDistributeElements.prototype._findRange = function (element) {\n  var axis = element[this._axis],\n      dimension = element[this._dimension];\n  return {\n    min: axis + THRESHOLD,\n    max: axis + dimension - THRESHOLD\n  };\n};","map":{"version":3,"names":["sortBy","forEach","isArray","AXIS_DIMENSIONS","horizontal","vertical","THRESHOLD","DistributeElements","modeling","rules","_modeling","_filters","registerFilter","elements","allowed","$inject","prototype","filterFn","Error","push","trigger","orientation","groups","distributableElements","length","_setOrientation","_filterElements","_createGroups","distributeElements","_axis","_dimension","filters","axis","dimension","concat","rangeGroups","self","sortedElements","element","idx","elementRange","_findRange","range","previous","_hasIntersection","direction","rangeA","rangeB","Math","max","min"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/distribute-elements/DistributeElements.js"],"sourcesContent":["import {\n  sortBy,\n  forEach,\n  isArray\n} from 'min-dash';\n\nvar AXIS_DIMENSIONS = {\n  horizontal: [ 'x', 'width' ],\n  vertical: [ 'y', 'height' ]\n};\n\nvar THRESHOLD = 5;\n\n\n/**\n * Groups and filters elements and then trigger even distribution.\n */\nexport default function DistributeElements(modeling, rules) {\n  this._modeling = modeling;\n\n  this._filters = [];\n\n  this.registerFilter(function(elements) {\n    var allowed = rules.allowed('elements.distribute', { elements: elements });\n\n    if (isArray(allowed)) {\n      return allowed;\n    }\n\n    return allowed ? elements : [];\n  });\n}\n\nDistributeElements.$inject = [ 'modeling', 'rules' ];\n\n\n/**\n * Registers filter functions that allow external parties to filter\n * out certain elements.\n *\n * @param  {Function} filterFn\n */\nDistributeElements.prototype.registerFilter = function(filterFn) {\n  if (typeof filterFn !== 'function') {\n    throw new Error('the filter has to be a function');\n  }\n\n  this._filters.push(filterFn);\n};\n\n/**\n * Distributes the elements with a given orientation\n *\n * @param  {Array} elements\n * @param  {string} orientation\n */\nDistributeElements.prototype.trigger = function(elements, orientation) {\n  var modeling = this._modeling;\n\n  var groups,\n      distributableElements;\n\n  if (elements.length < 3) {\n    return;\n  }\n\n  this._setOrientation(orientation);\n\n  distributableElements = this._filterElements(elements);\n\n  groups = this._createGroups(distributableElements);\n\n  // nothing to distribute\n  if (groups.length <= 2) {\n    return;\n  }\n\n  modeling.distributeElements(groups, this._axis, this._dimension);\n\n  return groups;\n};\n\n/**\n * Filters the elements with provided filters by external parties\n *\n * @param  {Array[Elements]} elements\n *\n * @return {Array[Elements]}\n */\nDistributeElements.prototype._filterElements = function(elements) {\n  var filters = this._filters,\n      axis = this._axis,\n      dimension = this._dimension,\n      distributableElements = [].concat(elements);\n\n  if (!filters.length) {\n    return elements;\n  }\n\n  forEach(filters, function(filterFn) {\n    distributableElements = filterFn(distributableElements, axis, dimension);\n  });\n\n  return distributableElements;\n};\n\n\n/**\n * Create range (min, max) groups. Also tries to group elements\n * together that share the same range.\n *\n * @example\n * \tvar distributableElements = [\n * \t\t{\n * \t\t\trange: {\n * \t\t\t\tmin: 100,\n * \t\t\t\tmax: 200\n * \t\t\t},\n * \t\t\telements: [ { id: 'shape1', .. }]\n * \t\t}\n * \t]\n *\n * @param  {Array} elements\n *\n * @return {Array[Objects]}\n */\nDistributeElements.prototype._createGroups = function(elements) {\n  var rangeGroups = [],\n      self = this,\n      axis = this._axis,\n      dimension = this._dimension;\n\n  if (!axis) {\n    throw new Error('must have a defined \"axis\" and \"dimension\"');\n  }\n\n  // sort by 'left->right' or 'top->bottom'\n  var sortedElements = sortBy(elements, axis);\n\n  forEach(sortedElements, function(element, idx) {\n    var elementRange = self._findRange(element, axis, dimension),\n        range;\n\n    var previous = rangeGroups[rangeGroups.length - 1];\n\n    if (previous && self._hasIntersection(previous.range, elementRange)) {\n      rangeGroups[rangeGroups.length - 1].elements.push(element);\n    } else {\n      range = { range: elementRange, elements: [ element ] };\n\n      rangeGroups.push(range);\n    }\n  });\n\n  return rangeGroups;\n};\n\n\n/**\n * Maps a direction to the according axis and dimension\n *\n * @param  {string} direction 'horizontal' or 'vertical'\n */\nDistributeElements.prototype._setOrientation = function(direction) {\n  var orientation = AXIS_DIMENSIONS[direction];\n\n  this._axis = orientation[0];\n  this._dimension = orientation[1];\n};\n\n\n/**\n * Checks if the two ranges intercept each other\n *\n * @param  {Object} rangeA {min, max}\n * @param  {Object} rangeB {min, max}\n *\n * @return {boolean}\n */\nDistributeElements.prototype._hasIntersection = function(rangeA, rangeB) {\n  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) &&\n         Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);\n};\n\n\n/**\n * Returns the min and max values for an element\n *\n * @param  {Bounds} element\n * @param  {string} axis\n * @param  {string} dimension\n *\n * @return {{ min: number, max: number }}\n */\nDistributeElements.prototype._findRange = function(element) {\n  var axis = element[this._axis],\n      dimension = element[this._dimension];\n\n  return {\n    min: axis + THRESHOLD,\n    max: axis + dimension - THRESHOLD\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}