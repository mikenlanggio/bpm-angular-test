{"ast":null,"code":"import { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate, remove as svgRemove, clear as svgClear } from 'tiny-svg';\nimport { isObject } from 'min-dash';\nimport { getElementLineIntersection, getMid } from '../../layout/LayoutUtil';\nvar MARKER_CONNECTION_PREVIEW = 'djs-connection-preview';\n/**\n * Draws connection preview. Optionally, this can use layouter and connection docking to draw\n * better looking previews.\n *\n * @param {didi.Injector} injector\n * @param {Canvas} canvas\n * @param {GraphicsFactory} graphicsFactory\n * @param {ElementFactory} elementFactory\n */\n\nexport default function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {\n  this._canvas = canvas;\n  this._graphicsFactory = graphicsFactory;\n  this._elementFactory = elementFactory; // optional components\n\n  this._connectionDocking = injector.get('connectionDocking', false);\n  this._layouter = injector.get('layouter', false);\n}\nConnectionPreview.$inject = ['injector', 'canvas', 'graphicsFactory', 'elementFactory'];\n/**\n * Draw connection preview.\n *\n * Provide at least one of <source, connectionStart> and <target, connectionEnd> to create a preview.\n * In the clean up stage, call `connectionPreview#cleanUp` with the context to remove preview.\n *\n * @param {Object} context\n * @param {Object|boolean} canConnect\n * @param {Object} hints\n * @param {djs.model.shape} [hints.source] source element\n * @param {djs.model.shape} [hints.target] target element\n * @param {Point} [hints.connectionStart] connection preview start\n * @param {Point} [hints.connectionEnd] connection preview end\n * @param {Array<Point>} [hints.waypoints] provided waypoints for preview\n * @param {boolean} [hints.noLayout] true if preview should not be laid out\n * @param {boolean} [hints.noCropping] true if preview should not be cropped\n * @param {boolean} [hints.noNoop] true if simple connection should not be drawn\n */\n\nConnectionPreview.prototype.drawPreview = function (context, canConnect, hints) {\n  hints = hints || {};\n  var connectionPreviewGfx = context.connectionPreviewGfx,\n      getConnection = context.getConnection,\n      source = hints.source,\n      target = hints.target,\n      waypoints = hints.waypoints,\n      connectionStart = hints.connectionStart,\n      connectionEnd = hints.connectionEnd,\n      noLayout = hints.noLayout,\n      noCropping = hints.noCropping,\n      noNoop = hints.noNoop,\n      connection;\n  var self = this;\n\n  if (!connectionPreviewGfx) {\n    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();\n  }\n\n  svgClear(connectionPreviewGfx);\n\n  if (!getConnection) {\n    getConnection = context.getConnection = cacheReturnValues(function (canConnect, source, target) {\n      return self.getConnection(canConnect, source, target);\n    });\n  }\n\n  if (canConnect) {\n    connection = getConnection(canConnect, source, target);\n  }\n\n  if (!connection) {\n    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);\n    return;\n  }\n\n  connection.waypoints = waypoints || []; // optional layout\n\n  if (this._layouter && !noLayout) {\n    connection.waypoints = this._layouter.layoutConnection(connection, {\n      source: source,\n      target: target,\n      connectionStart: connectionStart,\n      connectionEnd: connectionEnd,\n      waypoints: hints.waypoints || connection.waypoints\n    });\n  } // fallback if no waypoints were provided nor created with layouter\n\n\n  if (!connection.waypoints || !connection.waypoints.length) {\n    connection.waypoints = [source ? getMid(source) : connectionStart, target ? getMid(target) : connectionEnd];\n  } // optional cropping\n\n\n  if (this._connectionDocking && (source || target) && !noCropping) {\n    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);\n  }\n\n  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection);\n};\n/**\n * Draw simple connection between source and target or provided points.\n *\n * @param {SVGElement} connectionPreviewGfx container for the connection\n * @param {Object} hints\n * @param {djs.model.shape} [hints.source] source element\n * @param {djs.model.shape} [hints.target] target element\n * @param {Point} [hints.connectionStart] required if source is not provided\n * @param {Point} [hints.connectionEnd] required if target is not provided\n */\n\n\nConnectionPreview.prototype.drawNoopPreview = function (connectionPreviewGfx, hints) {\n  var source = hints.source,\n      target = hints.target,\n      start = hints.connectionStart || getMid(source),\n      end = hints.connectionEnd || getMid(target);\n  var waypoints = this.cropWaypoints(start, end, source, target);\n  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);\n  svgAppend(connectionPreviewGfx, connection);\n};\n/**\n * Return cropped waypoints.\n *\n * @param {Point} start\n * @param {Point} end\n * @param {djs.model.shape} source\n * @param {djs.model.shape} target\n *\n * @returns {Array}\n */\n\n\nConnectionPreview.prototype.cropWaypoints = function (start, end, source, target) {\n  var graphicsFactory = this._graphicsFactory,\n      sourcePath = source && graphicsFactory.getShapePath(source),\n      targetPath = target && graphicsFactory.getShapePath(target),\n      connectionPath = graphicsFactory.getConnectionPath({\n    waypoints: [start, end]\n  });\n  start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;\n  end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;\n  return [start, end];\n};\n/**\n * Remove connection preview container if it exists.\n *\n * @param {Object} [context]\n * @param {SVGElement} [context.connectionPreviewGfx] preview container\n */\n\n\nConnectionPreview.prototype.cleanUp = function (context) {\n  if (context && context.connectionPreviewGfx) {\n    svgRemove(context.connectionPreviewGfx);\n  }\n};\n/**\n * Get connection that connects source and target.\n *\n * @param {Object|boolean} canConnect\n *\n * @returns {djs.model.connection}\n */\n\n\nConnectionPreview.prototype.getConnection = function (canConnect) {\n  var attrs = ensureConnectionAttrs(canConnect);\n  return this._elementFactory.createConnection(attrs);\n};\n/**\n * Add and return preview graphics.\n *\n * @returns {SVGElement}\n */\n\n\nConnectionPreview.prototype.createConnectionPreviewGfx = function () {\n  var gfx = svgCreate('g');\n  svgAttr(gfx, {\n    pointerEvents: 'none'\n  });\n  svgClasses(gfx).add(MARKER_CONNECTION_PREVIEW);\n  svgAppend(this._canvas.getActiveLayer(), gfx);\n  return gfx;\n};\n/**\n * Create and return simple connection.\n *\n * @param {Point} start\n * @param {Point} end\n *\n * @returns {SVGElement}\n */\n\n\nConnectionPreview.prototype.createNoopConnection = function (start, end) {\n  var connection = svgCreate('polyline');\n  svgAttr(connection, {\n    'stroke': '#333',\n    'strokeDasharray': [1],\n    'strokeWidth': 2,\n    'pointer-events': 'none'\n  });\n  svgAttr(connection, {\n    'points': [start.x, start.y, end.x, end.y]\n  });\n  return connection;\n}; // helpers //////////\n\n/**\n * Returns function that returns cached return values referenced by stringified first argument.\n *\n * @param {Function} fn\n *\n * @return {Function}\n */\n\n\nfunction cacheReturnValues(fn) {\n  var returnValues = {};\n  /**\n   * Return cached return value referenced by stringified first argument.\n   *\n   * @returns {*}\n   */\n\n  return function (firstArgument) {\n    var key = JSON.stringify(firstArgument);\n    var returnValue = returnValues[key];\n\n    if (!returnValue) {\n      returnValue = returnValues[key] = fn.apply(null, arguments);\n    }\n\n    return returnValue;\n  };\n}\n/**\n * Ensure connection attributes is object.\n *\n * @param {Object|boolean} canConnect\n *\n * @returns {Object}\n */\n\n\nfunction ensureConnectionAttrs(canConnect) {\n  if (isObject(canConnect)) {\n    return canConnect;\n  } else {\n    return {};\n  }\n}","map":{"version":3,"names":["append","svgAppend","attr","svgAttr","classes","svgClasses","create","svgCreate","remove","svgRemove","clear","svgClear","isObject","getElementLineIntersection","getMid","MARKER_CONNECTION_PREVIEW","ConnectionPreview","injector","canvas","graphicsFactory","elementFactory","_canvas","_graphicsFactory","_elementFactory","_connectionDocking","get","_layouter","$inject","prototype","drawPreview","context","canConnect","hints","connectionPreviewGfx","getConnection","source","target","waypoints","connectionStart","connectionEnd","noLayout","noCropping","noNoop","connection","self","createConnectionPreviewGfx","cacheReturnValues","drawNoopPreview","layoutConnection","length","getCroppedWaypoints","drawConnection","start","end","cropWaypoints","createNoopConnection","sourcePath","getShapePath","targetPath","connectionPath","getConnectionPath","cleanUp","attrs","ensureConnectionAttrs","createConnection","gfx","pointerEvents","add","getActiveLayer","x","y","fn","returnValues","firstArgument","key","JSON","stringify","returnValue","apply","arguments"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js"],"sourcesContent":["import {\n  append as svgAppend,\n  attr as svgAttr,\n  classes as svgClasses,\n  create as svgCreate,\n  remove as svgRemove,\n  clear as svgClear\n} from 'tiny-svg';\n\nimport {\n  isObject\n} from 'min-dash';\n\nimport {\n  getElementLineIntersection,\n  getMid\n} from '../../layout/LayoutUtil';\n\n\nvar MARKER_CONNECTION_PREVIEW = 'djs-connection-preview';\n\n/**\n * Draws connection preview. Optionally, this can use layouter and connection docking to draw\n * better looking previews.\n *\n * @param {didi.Injector} injector\n * @param {Canvas} canvas\n * @param {GraphicsFactory} graphicsFactory\n * @param {ElementFactory} elementFactory\n */\nexport default function ConnectionPreview(\n    injector,\n    canvas,\n    graphicsFactory,\n    elementFactory\n) {\n  this._canvas = canvas;\n  this._graphicsFactory = graphicsFactory;\n  this._elementFactory = elementFactory;\n\n  // optional components\n  this._connectionDocking = injector.get('connectionDocking', false);\n  this._layouter = injector.get('layouter', false);\n}\n\nConnectionPreview.$inject = [\n  'injector',\n  'canvas',\n  'graphicsFactory',\n  'elementFactory'\n];\n\n/**\n * Draw connection preview.\n *\n * Provide at least one of <source, connectionStart> and <target, connectionEnd> to create a preview.\n * In the clean up stage, call `connectionPreview#cleanUp` with the context to remove preview.\n *\n * @param {Object} context\n * @param {Object|boolean} canConnect\n * @param {Object} hints\n * @param {djs.model.shape} [hints.source] source element\n * @param {djs.model.shape} [hints.target] target element\n * @param {Point} [hints.connectionStart] connection preview start\n * @param {Point} [hints.connectionEnd] connection preview end\n * @param {Array<Point>} [hints.waypoints] provided waypoints for preview\n * @param {boolean} [hints.noLayout] true if preview should not be laid out\n * @param {boolean} [hints.noCropping] true if preview should not be cropped\n * @param {boolean} [hints.noNoop] true if simple connection should not be drawn\n */\nConnectionPreview.prototype.drawPreview = function(context, canConnect, hints) {\n\n  hints = hints || {};\n\n  var connectionPreviewGfx = context.connectionPreviewGfx,\n      getConnection = context.getConnection,\n      source = hints.source,\n      target = hints.target,\n      waypoints = hints.waypoints,\n      connectionStart = hints.connectionStart,\n      connectionEnd = hints.connectionEnd,\n      noLayout = hints.noLayout,\n      noCropping = hints.noCropping,\n      noNoop = hints.noNoop,\n      connection;\n\n  var self = this;\n\n  if (!connectionPreviewGfx) {\n    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();\n  }\n\n  svgClear(connectionPreviewGfx);\n\n  if (!getConnection) {\n    getConnection = context.getConnection = cacheReturnValues(function(canConnect, source, target) {\n      return self.getConnection(canConnect, source, target);\n    });\n  }\n\n  if (canConnect) {\n    connection = getConnection(canConnect, source, target);\n  }\n\n  if (!connection) {\n    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);\n    return;\n  }\n\n  connection.waypoints = waypoints || [];\n\n  // optional layout\n  if (this._layouter && !noLayout) {\n    connection.waypoints = this._layouter.layoutConnection(connection, {\n      source: source,\n      target: target,\n      connectionStart: connectionStart,\n      connectionEnd: connectionEnd,\n      waypoints: hints.waypoints || connection.waypoints\n    });\n  }\n\n  // fallback if no waypoints were provided nor created with layouter\n  if (!connection.waypoints || !connection.waypoints.length) {\n    connection.waypoints = [\n      source ? getMid(source) : connectionStart,\n      target ? getMid(target) : connectionEnd\n    ];\n  }\n\n  // optional cropping\n  if (this._connectionDocking && (source || target) && !noCropping) {\n    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);\n  }\n\n  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection);\n};\n\n/**\n * Draw simple connection between source and target or provided points.\n *\n * @param {SVGElement} connectionPreviewGfx container for the connection\n * @param {Object} hints\n * @param {djs.model.shape} [hints.source] source element\n * @param {djs.model.shape} [hints.target] target element\n * @param {Point} [hints.connectionStart] required if source is not provided\n * @param {Point} [hints.connectionEnd] required if target is not provided\n */\nConnectionPreview.prototype.drawNoopPreview = function(connectionPreviewGfx, hints) {\n  var source = hints.source,\n      target = hints.target,\n      start = hints.connectionStart || getMid(source),\n      end = hints.connectionEnd || getMid(target);\n\n  var waypoints = this.cropWaypoints(start, end, source, target);\n\n  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);\n\n  svgAppend(connectionPreviewGfx, connection);\n};\n\n/**\n * Return cropped waypoints.\n *\n * @param {Point} start\n * @param {Point} end\n * @param {djs.model.shape} source\n * @param {djs.model.shape} target\n *\n * @returns {Array}\n */\nConnectionPreview.prototype.cropWaypoints = function(start, end, source, target) {\n  var graphicsFactory = this._graphicsFactory,\n      sourcePath = source && graphicsFactory.getShapePath(source),\n      targetPath = target && graphicsFactory.getShapePath(target),\n      connectionPath = graphicsFactory.getConnectionPath({ waypoints: [ start, end ] });\n\n  start = (source && getElementLineIntersection(sourcePath, connectionPath, true)) || start;\n  end = (target && getElementLineIntersection(targetPath, connectionPath, false)) || end;\n\n  return [ start, end ];\n};\n\n/**\n * Remove connection preview container if it exists.\n *\n * @param {Object} [context]\n * @param {SVGElement} [context.connectionPreviewGfx] preview container\n */\nConnectionPreview.prototype.cleanUp = function(context) {\n  if (context && context.connectionPreviewGfx) {\n    svgRemove(context.connectionPreviewGfx);\n  }\n};\n\n/**\n * Get connection that connects source and target.\n *\n * @param {Object|boolean} canConnect\n *\n * @returns {djs.model.connection}\n */\nConnectionPreview.prototype.getConnection = function(canConnect) {\n  var attrs = ensureConnectionAttrs(canConnect);\n\n  return this._elementFactory.createConnection(attrs);\n};\n\n\n/**\n * Add and return preview graphics.\n *\n * @returns {SVGElement}\n */\nConnectionPreview.prototype.createConnectionPreviewGfx = function() {\n  var gfx = svgCreate('g');\n\n  svgAttr(gfx, {\n    pointerEvents: 'none'\n  });\n\n  svgClasses(gfx).add(MARKER_CONNECTION_PREVIEW);\n\n  svgAppend(this._canvas.getActiveLayer(), gfx);\n\n  return gfx;\n};\n\n/**\n * Create and return simple connection.\n *\n * @param {Point} start\n * @param {Point} end\n *\n * @returns {SVGElement}\n */\nConnectionPreview.prototype.createNoopConnection = function(start, end) {\n  var connection = svgCreate('polyline');\n\n  svgAttr(connection, {\n    'stroke': '#333',\n    'strokeDasharray': [ 1 ],\n    'strokeWidth': 2,\n    'pointer-events': 'none'\n  });\n\n  svgAttr(connection, { 'points': [ start.x, start.y, end.x, end.y ] });\n\n  return connection;\n};\n\n// helpers //////////\n\n/**\n * Returns function that returns cached return values referenced by stringified first argument.\n *\n * @param {Function} fn\n *\n * @return {Function}\n */\nfunction cacheReturnValues(fn) {\n  var returnValues = {};\n\n  /**\n   * Return cached return value referenced by stringified first argument.\n   *\n   * @returns {*}\n   */\n  return function(firstArgument) {\n    var key = JSON.stringify(firstArgument);\n\n    var returnValue = returnValues[key];\n\n    if (!returnValue) {\n      returnValue = returnValues[key] = fn.apply(null, arguments);\n    }\n\n    return returnValue;\n  };\n}\n\n/**\n * Ensure connection attributes is object.\n *\n * @param {Object|boolean} canConnect\n *\n * @returns {Object}\n */\nfunction ensureConnectionAttrs(canConnect) {\n  if (isObject(canConnect)) {\n    return canConnect;\n  } else {\n    return {};\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}