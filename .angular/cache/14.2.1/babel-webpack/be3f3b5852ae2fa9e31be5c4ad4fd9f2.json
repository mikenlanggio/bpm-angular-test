{"ast":null,"code":"import { asTRBL, getOrientation, getMid } from '../../layout/LayoutUtil';\nimport { find, reduce } from 'min-dash'; // padding to detect element placement\n\nvar PLACEMENT_DETECTION_PAD = 10;\nexport var DEFAULT_DISTANCE = 50;\nvar DEFAULT_MAX_DISTANCE = 250;\n/**\n * Get free position starting from given position.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n * @param {Point} position\n * @param {Function} getNextPosition\n *\n * @return {Point}\n */\n\nexport function findFreePosition(source, element, position, getNextPosition) {\n  var connectedAtPosition;\n\n  while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {\n    position = getNextPosition(element, position, connectedAtPosition);\n  }\n\n  return position;\n}\n/**\n * Returns function that returns next position.\n *\n * @param {Object} nextPositionDirection\n * @param {Object} [nextPositionDirection.x]\n * @param {Object} [nextPositionDirection.y]\n *\n * @returns {Function}\n */\n\nexport function generateGetNextPosition(nextPositionDirection) {\n  return function (element, previousPosition, connectedAtPosition) {\n    var nextPosition = {\n      x: previousPosition.x,\n      y: previousPosition.y\n    };\n    ['x', 'y'].forEach(function (axis) {\n      var nextPositionDirectionForAxis = nextPositionDirection[axis];\n\n      if (!nextPositionDirectionForAxis) {\n        return;\n      }\n\n      var dimension = axis === 'x' ? 'width' : 'height';\n      var margin = nextPositionDirectionForAxis.margin,\n          minDistance = nextPositionDirectionForAxis.minDistance;\n\n      if (margin < 0) {\n        nextPosition[axis] = Math.min(connectedAtPosition[axis] + margin - element[dimension] / 2, previousPosition[axis] - minDistance + margin);\n      } else {\n        nextPosition[axis] = Math.max(connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2, previousPosition[axis] + minDistance + margin);\n      }\n    });\n    return nextPosition;\n  };\n}\n/**\n * Return target at given position, if defined.\n *\n * This takes connected elements from host and attachers\n * into account, too.\n */\n\nexport function getConnectedAtPosition(source, position, element) {\n  var bounds = {\n    x: position.x - element.width / 2,\n    y: position.y - element.height / 2,\n    width: element.width,\n    height: element.height\n  };\n  var closure = getAutoPlaceClosure(source, element);\n  return find(closure, function (target) {\n    if (target === element) {\n      return false;\n    }\n\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n    return orientation === 'intersect';\n  });\n}\n/**\n* Compute optimal distance between source and target based on existing connections to and from source.\n* Assumes left-to-right and top-to-down modeling.\n*\n* @param {djs.model.Shape} source\n* @param {Object} [hints]\n* @param {number} [hints.defaultDistance]\n* @param {string} [hints.direction]\n* @param {Function} [hints.filter]\n* @param {Function} [hints.getWeight]\n* @param {number} [hints.maxDistance]\n* @param {string} [hints.reference]\n*\n* @return {number}\n*/\n\nexport function getConnectedDistance(source, hints) {\n  if (!hints) {\n    hints = {};\n  } // targets > sources by default\n\n\n  function getDefaultWeight(connection) {\n    return connection.source === source ? 1 : -1;\n  }\n\n  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE,\n      direction = hints.direction || 'e',\n      filter = hints.filter,\n      getWeight = hints.getWeight || getDefaultWeight,\n      maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE,\n      reference = hints.reference || 'start';\n\n  if (!filter) {\n    filter = noneFilter;\n  }\n\n  function getDistance(a, b) {\n    if (direction === 'n') {\n      if (reference === 'start') {\n        return asTRBL(a).top - asTRBL(b).bottom;\n      } else if (reference === 'center') {\n        return asTRBL(a).top - getMid(b).y;\n      } else {\n        return asTRBL(a).top - asTRBL(b).top;\n      }\n    } else if (direction === 'w') {\n      if (reference === 'start') {\n        return asTRBL(a).left - asTRBL(b).right;\n      } else if (reference === 'center') {\n        return asTRBL(a).left - getMid(b).x;\n      } else {\n        return asTRBL(a).left - asTRBL(b).left;\n      }\n    } else if (direction === 's') {\n      if (reference === 'start') {\n        return asTRBL(b).top - asTRBL(a).bottom;\n      } else if (reference === 'center') {\n        return getMid(b).y - asTRBL(a).bottom;\n      } else {\n        return asTRBL(b).bottom - asTRBL(a).bottom;\n      }\n    } else {\n      if (reference === 'start') {\n        return asTRBL(b).left - asTRBL(a).right;\n      } else if (reference === 'center') {\n        return getMid(b).x - asTRBL(a).right;\n      } else {\n        return asTRBL(b).right - asTRBL(a).right;\n      }\n    }\n  }\n\n  var sourcesDistances = source.incoming.filter(filter).map(function (connection) {\n    var weight = getWeight(connection);\n    var distance = weight < 0 ? getDistance(connection.source, source) : getDistance(source, connection.source);\n    return {\n      id: connection.source.id,\n      distance: distance,\n      weight: weight\n    };\n  });\n  var targetsDistances = source.outgoing.filter(filter).map(function (connection) {\n    var weight = getWeight(connection);\n    var distance = weight > 0 ? getDistance(source, connection.target) : getDistance(connection.target, source);\n    return {\n      id: connection.target.id,\n      distance: distance,\n      weight: weight\n    };\n  });\n  var distances = sourcesDistances.concat(targetsDistances).reduce(function (accumulator, currentValue) {\n    accumulator[currentValue.id + '__weight_' + currentValue.weight] = currentValue;\n    return accumulator;\n  }, {});\n  var distancesGrouped = reduce(distances, function (accumulator, currentValue) {\n    var distance = currentValue.distance,\n        weight = currentValue.weight;\n\n    if (distance < 0 || distance > maxDistance) {\n      return accumulator;\n    }\n\n    if (!accumulator[String(distance)]) {\n      accumulator[String(distance)] = 0;\n    }\n\n    accumulator[String(distance)] += 1 * weight;\n\n    if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance)]) {\n      accumulator.distance = distance;\n    }\n\n    return accumulator;\n  }, {});\n  return distancesGrouped.distance || defaultDistance;\n}\n/**\n * Returns all connected elements around the given source.\n *\n * This includes:\n *\n *   - connected elements\n *   - host connected elements\n *   - attachers connected elements\n *\n * @param  {djs.model.Shape} source\n *\n * @return {Array<djs.model.Shape>}\n */\n\nfunction getAutoPlaceClosure(source) {\n  var allConnected = getConnected(source);\n\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function (shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n\n  return allConnected;\n}\n\nfunction getConnected(element) {\n  return getTargets(element).concat(getSources(element));\n}\n\nfunction getSources(shape) {\n  return shape.incoming.map(function (connection) {\n    return connection.source;\n  });\n}\n\nfunction getTargets(shape) {\n  return shape.outgoing.map(function (connection) {\n    return connection.target;\n  });\n}\n\nfunction noneFilter() {\n  return true;\n}","map":{"version":3,"names":["asTRBL","getOrientation","getMid","find","reduce","PLACEMENT_DETECTION_PAD","DEFAULT_DISTANCE","DEFAULT_MAX_DISTANCE","findFreePosition","source","element","position","getNextPosition","connectedAtPosition","getConnectedAtPosition","generateGetNextPosition","nextPositionDirection","previousPosition","nextPosition","x","y","forEach","axis","nextPositionDirectionForAxis","dimension","margin","minDistance","Math","min","max","bounds","width","height","closure","getAutoPlaceClosure","target","orientation","getConnectedDistance","hints","getDefaultWeight","connection","defaultDistance","direction","filter","getWeight","maxDistance","reference","noneFilter","getDistance","a","b","top","bottom","left","right","sourcesDistances","incoming","map","weight","distance","id","targetsDistances","outgoing","distances","concat","accumulator","currentValue","distancesGrouped","String","allConnected","getConnected","host","attachers","shapes","attacher","getTargets","getSources","shape"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/features/auto-place/AutoPlaceUtil.js"],"sourcesContent":["import {\n  asTRBL,\n  getOrientation,\n  getMid\n} from '../../layout/LayoutUtil';\n\nimport {\n  find,\n  reduce\n} from 'min-dash';\n\n// padding to detect element placement\nvar PLACEMENT_DETECTION_PAD = 10;\n\nexport var DEFAULT_DISTANCE = 50;\n\nvar DEFAULT_MAX_DISTANCE = 250;\n\n\n/**\n * Get free position starting from given position.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n * @param {Point} position\n * @param {Function} getNextPosition\n *\n * @return {Point}\n */\nexport function findFreePosition(source, element, position, getNextPosition) {\n  var connectedAtPosition;\n\n  while ((connectedAtPosition = getConnectedAtPosition(source, position, element))) {\n    position = getNextPosition(element, position, connectedAtPosition);\n  }\n\n  return position;\n}\n\n/**\n * Returns function that returns next position.\n *\n * @param {Object} nextPositionDirection\n * @param {Object} [nextPositionDirection.x]\n * @param {Object} [nextPositionDirection.y]\n *\n * @returns {Function}\n */\nexport function generateGetNextPosition(nextPositionDirection) {\n  return function(element, previousPosition, connectedAtPosition) {\n    var nextPosition = {\n      x: previousPosition.x,\n      y: previousPosition.y\n    };\n\n    [ 'x', 'y' ].forEach(function(axis) {\n\n      var nextPositionDirectionForAxis = nextPositionDirection[ axis ];\n\n      if (!nextPositionDirectionForAxis) {\n        return;\n      }\n\n      var dimension = axis === 'x' ? 'width' : 'height';\n\n      var margin = nextPositionDirectionForAxis.margin,\n          minDistance = nextPositionDirectionForAxis.minDistance;\n\n      if (margin < 0) {\n        nextPosition[ axis ] = Math.min(\n          connectedAtPosition[ axis ] + margin - element[ dimension ] / 2,\n          previousPosition[ axis ] - minDistance + margin\n        );\n      } else {\n        nextPosition[ axis ] = Math.max(\n          connectedAtPosition[ axis ] + connectedAtPosition[ dimension ] + margin + element[ dimension ] / 2,\n          previousPosition[ axis ] + minDistance + margin\n        );\n      }\n    });\n\n    return nextPosition;\n  };\n}\n\n/**\n * Return target at given position, if defined.\n *\n * This takes connected elements from host and attachers\n * into account, too.\n */\nexport function getConnectedAtPosition(source, position, element) {\n\n  var bounds = {\n    x: position.x - (element.width / 2),\n    y: position.y - (element.height / 2),\n    width: element.width,\n    height: element.height\n  };\n\n  var closure = getAutoPlaceClosure(source, element);\n\n  return find(closure, function(target) {\n\n    if (target === element) {\n      return false;\n    }\n\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n\n    return orientation === 'intersect';\n  });\n}\n\n/**\n* Compute optimal distance between source and target based on existing connections to and from source.\n* Assumes left-to-right and top-to-down modeling.\n*\n* @param {djs.model.Shape} source\n* @param {Object} [hints]\n* @param {number} [hints.defaultDistance]\n* @param {string} [hints.direction]\n* @param {Function} [hints.filter]\n* @param {Function} [hints.getWeight]\n* @param {number} [hints.maxDistance]\n* @param {string} [hints.reference]\n*\n* @return {number}\n*/\nexport function getConnectedDistance(source, hints) {\n  if (!hints) {\n    hints = {};\n  }\n\n  // targets > sources by default\n  function getDefaultWeight(connection) {\n    return connection.source === source ? 1 : -1;\n  }\n\n  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE,\n      direction = hints.direction || 'e',\n      filter = hints.filter,\n      getWeight = hints.getWeight || getDefaultWeight,\n      maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE,\n      reference = hints.reference || 'start';\n\n  if (!filter) {\n    filter = noneFilter;\n  }\n\n  function getDistance(a, b) {\n    if (direction === 'n') {\n      if (reference === 'start') {\n        return asTRBL(a).top - asTRBL(b).bottom;\n      } else if (reference === 'center') {\n        return asTRBL(a).top - getMid(b).y;\n      } else {\n        return asTRBL(a).top - asTRBL(b).top;\n      }\n    } else if (direction === 'w') {\n      if (reference === 'start') {\n        return asTRBL(a).left - asTRBL(b).right;\n      } else if (reference === 'center') {\n        return asTRBL(a).left - getMid(b).x;\n      } else {\n        return asTRBL(a).left - asTRBL(b).left;\n      }\n    } else if (direction === 's') {\n      if (reference === 'start') {\n        return asTRBL(b).top - asTRBL(a).bottom;\n      } else if (reference === 'center') {\n        return getMid(b).y - asTRBL(a).bottom;\n      } else {\n        return asTRBL(b).bottom - asTRBL(a).bottom;\n      }\n    } else {\n      if (reference === 'start') {\n        return asTRBL(b).left - asTRBL(a).right;\n      } else if (reference === 'center') {\n        return getMid(b).x - asTRBL(a).right;\n      } else {\n        return asTRBL(b).right - asTRBL(a).right;\n      }\n    }\n  }\n\n  var sourcesDistances = source.incoming\n    .filter(filter)\n    .map(function(connection) {\n      var weight = getWeight(connection);\n\n      var distance = weight < 0\n        ? getDistance(connection.source, source)\n        : getDistance(source, connection.source);\n\n      return {\n        id: connection.source.id,\n        distance: distance,\n        weight: weight\n      };\n    });\n\n  var targetsDistances = source.outgoing\n    .filter(filter)\n    .map(function(connection) {\n      var weight = getWeight(connection);\n\n      var distance = weight > 0\n        ? getDistance(source, connection.target)\n        : getDistance(connection.target, source);\n\n      return {\n        id: connection.target.id,\n        distance: distance,\n        weight: weight\n      };\n    });\n\n  var distances = sourcesDistances.concat(targetsDistances).reduce(function(accumulator, currentValue) {\n    accumulator[ currentValue.id + '__weight_' + currentValue.weight ] = currentValue;\n\n    return accumulator;\n  }, {});\n\n  var distancesGrouped = reduce(distances, function(accumulator, currentValue) {\n    var distance = currentValue.distance,\n        weight = currentValue.weight;\n\n    if (distance < 0 || distance > maxDistance) {\n      return accumulator;\n    }\n\n    if (!accumulator[ String(distance) ]) {\n      accumulator[ String(distance) ] = 0;\n    }\n\n    accumulator[ String(distance) ] += 1 * weight;\n\n    if (!accumulator.distance || accumulator[ accumulator.distance ] < accumulator[ String(distance) ]) {\n      accumulator.distance = distance;\n    }\n\n    return accumulator;\n  }, {});\n\n  return distancesGrouped.distance || defaultDistance;\n}\n\n/**\n * Returns all connected elements around the given source.\n *\n * This includes:\n *\n *   - connected elements\n *   - host connected elements\n *   - attachers connected elements\n *\n * @param  {djs.model.Shape} source\n *\n * @return {Array<djs.model.Shape>}\n */\nfunction getAutoPlaceClosure(source) {\n\n  var allConnected = getConnected(source);\n\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n\n  return allConnected;\n}\n\nfunction getConnected(element) {\n  return getTargets(element).concat(getSources(element));\n}\n\nfunction getSources(shape) {\n  return shape.incoming.map(function(connection) {\n    return connection.source;\n  });\n}\n\nfunction getTargets(shape) {\n  return shape.outgoing.map(function(connection) {\n    return connection.target;\n  });\n}\n\nfunction noneFilter() {\n  return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}