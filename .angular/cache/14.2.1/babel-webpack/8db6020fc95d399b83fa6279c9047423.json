{"ast":null,"code":"import { find, forEach, isArray, isDefined, isObject, matchPattern, reduce, has, sortBy } from 'min-dash';\nvar DISALLOWED_PROPERTIES = ['artifacts', 'dataInputAssociations', 'dataOutputAssociations', 'default', 'flowElements', 'lanes', 'incoming', 'outgoing', 'categoryValue'];\n/**\n * @typedef {Function} <moddleCopy.canCopyProperties> listener\n *\n * @param {Object} context\n * @param {Array<string>} context.propertyNames\n * @param {ModdleElement} context.sourceElement\n * @param {ModdleElement} context.targetElement\n *\n * @returns {Array<string>|boolean} - Return properties to be copied or false to disallow\n * copying.\n */\n\n/**\n * @typedef {Function} <moddleCopy.canCopyProperty> listener\n *\n * @param {Object} context\n * @param {ModdleElement} context.parent\n * @param {*} context.property\n * @param {string} context.propertyName\n *\n * @returns {*|boolean} - Return copied property or false to disallow\n * copying.\n */\n\n/**\n * @typedef {Function} <moddleCopy.canSetCopiedProperty> listener\n *\n * @param {Object} context\n * @param {ModdleElement} context.parent\n * @param {*} context.property\n * @param {string} context.propertyName\n *\n * @returns {boolean} - Return false to disallow\n * setting copied property.\n */\n\n/**\n * Utility for copying model properties from source element to target element.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n * @param {BpmnModdle} moddle\n */\n\nexport default function ModdleCopy(eventBus, bpmnFactory, moddle) {\n  this._bpmnFactory = bpmnFactory;\n  this._eventBus = eventBus;\n  this._moddle = moddle; // copy extension elements last\n\n  eventBus.on('moddleCopy.canCopyProperties', function (context) {\n    var propertyNames = context.propertyNames;\n\n    if (!propertyNames || !propertyNames.length) {\n      return;\n    }\n\n    return sortBy(propertyNames, function (propertyName) {\n      return propertyName === 'extensionElements';\n    });\n  }); // default check whether property can be copied\n\n  eventBus.on('moddleCopy.canCopyProperty', function (context) {\n    var parent = context.parent,\n        parentDescriptor = isObject(parent) && parent.$descriptor,\n        propertyName = context.propertyName;\n\n    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {\n      // disallow copying property\n      return false;\n    }\n\n    if (propertyName && parentDescriptor && !find(parentDescriptor.properties, matchPattern({\n      name: propertyName\n    }))) {\n      // disallow copying property\n      return false;\n    }\n  }); // do NOT allow to copy empty extension elements\n\n  eventBus.on('moddleCopy.canSetCopiedProperty', function (context) {\n    var property = context.property;\n\n    if (is(property, 'bpmn:ExtensionElements') && (!property.values || !property.values.length)) {\n      // disallow setting copied property\n      return false;\n    }\n  });\n}\nModdleCopy.$inject = ['eventBus', 'bpmnFactory', 'moddle'];\n/**\n * Copy model properties of source element to target element.\n *\n * @param {ModdleElement} sourceElement\n * @param {ModdleElement} targetElement\n * @param {Array<string>} [propertyNames]\n * @param {boolean} clone\n *\n * @param {ModdleElement}\n */\n\nModdleCopy.prototype.copyElement = function (sourceElement, targetElement, propertyNames, clone) {\n  var self = this;\n\n  if (propertyNames && !isArray(propertyNames)) {\n    propertyNames = [propertyNames];\n  }\n\n  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);\n\n  var canCopyProperties = this._eventBus.fire('moddleCopy.canCopyProperties', {\n    propertyNames: propertyNames,\n    sourceElement: sourceElement,\n    targetElement: targetElement,\n    clone: clone\n  });\n\n  if (canCopyProperties === false) {\n    return targetElement;\n  }\n\n  if (isArray(canCopyProperties)) {\n    propertyNames = canCopyProperties;\n  } // copy properties\n\n\n  forEach(propertyNames, function (propertyName) {\n    var sourceProperty;\n\n    if (has(sourceElement, propertyName)) {\n      sourceProperty = sourceElement.get(propertyName);\n    }\n\n    var copiedProperty = self.copyProperty(sourceProperty, targetElement, propertyName, clone);\n\n    if (!isDefined(copiedProperty)) {\n      return;\n    }\n\n    var canSetProperty = self._eventBus.fire('moddleCopy.canSetCopiedProperty', {\n      parent: targetElement,\n      property: copiedProperty,\n      propertyName: propertyName\n    });\n\n    if (canSetProperty === false) {\n      return;\n    } // TODO(nikku): unclaim old IDs if ID property is copied over\n    // this._moddle.getPropertyDescriptor(parent, propertyName)\n\n\n    targetElement.set(propertyName, copiedProperty);\n  });\n  return targetElement;\n};\n/**\n * Copy model property.\n *\n * @param {*} property\n * @param {ModdleElement} parent\n * @param {string} propertyName\n * @param {boolean} clone\n *\n * @returns {*}\n */\n\n\nModdleCopy.prototype.copyProperty = function (property, parent, propertyName, clone) {\n  var self = this; // allow others to copy property\n\n  var copiedProperty = this._eventBus.fire('moddleCopy.canCopyProperty', {\n    parent: parent,\n    property: property,\n    propertyName: propertyName,\n    clone: clone\n  }); // return if copying is NOT allowed\n\n\n  if (copiedProperty === false) {\n    return;\n  }\n\n  if (copiedProperty) {\n    if (isObject(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {\n      copiedProperty.$parent = parent;\n    }\n\n    return copiedProperty;\n  }\n\n  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName); // do NOT copy references\n\n\n  if (propertyDescriptor.isReference) {\n    return;\n  } // copy id\n\n\n  if (propertyDescriptor.isId) {\n    return property && this._copyId(property, parent, clone);\n  } // copy arrays\n\n\n  if (isArray(property)) {\n    return reduce(property, function (childProperties, childProperty) {\n      // recursion\n      copiedProperty = self.copyProperty(childProperty, parent, propertyName, clone); // copying might NOT be allowed\n\n      if (copiedProperty) {\n        return childProperties.concat(copiedProperty);\n      }\n\n      return childProperties;\n    }, []);\n  } // copy model elements\n\n\n  if (isObject(property) && property.$type) {\n    if (this._moddle.getElementDescriptor(property).isGeneric) {\n      return;\n    }\n\n    copiedProperty = self._bpmnFactory.create(property.$type);\n    copiedProperty.$parent = parent; // recursion\n\n    copiedProperty = self.copyElement(property, copiedProperty, null, clone);\n    return copiedProperty;\n  } // copy primitive properties\n\n\n  return property;\n};\n\nModdleCopy.prototype._copyId = function (id, element, clone) {\n  if (clone) {\n    return id;\n  } // disallow if already taken\n\n\n  if (this._moddle.ids.assigned(id)) {\n    return;\n  } else {\n    this._moddle.ids.claim(id, element);\n\n    return id;\n  }\n}; // helpers //////////\n\n\nexport function getPropertyNames(descriptor, keepDefaultProperties) {\n  return reduce(descriptor.properties, function (properties, property) {\n    if (keepDefaultProperties && property.default) {\n      return properties;\n    }\n\n    return properties.concat(property.name);\n  }, []);\n}\n\nfunction is(element, type) {\n  return element && typeof element.$instanceOf === 'function' && element.$instanceOf(type);\n}","map":{"version":3,"names":["find","forEach","isArray","isDefined","isObject","matchPattern","reduce","has","sortBy","DISALLOWED_PROPERTIES","ModdleCopy","eventBus","bpmnFactory","moddle","_bpmnFactory","_eventBus","_moddle","on","context","propertyNames","length","propertyName","parent","parentDescriptor","$descriptor","indexOf","properties","name","property","is","values","$inject","prototype","copyElement","sourceElement","targetElement","clone","self","getPropertyNames","canCopyProperties","fire","sourceProperty","get","copiedProperty","copyProperty","canSetProperty","set","$type","$parent","propertyDescriptor","getPropertyDescriptor","isReference","isId","_copyId","childProperties","childProperty","concat","getElementDescriptor","isGeneric","create","id","element","ids","assigned","claim","descriptor","keepDefaultProperties","default","type","$instanceOf"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/bpmn-js/lib/features/copy-paste/ModdleCopy.js"],"sourcesContent":["import {\n  find,\n  forEach,\n  isArray,\n  isDefined,\n  isObject,\n  matchPattern,\n  reduce,\n  has,\n  sortBy\n} from 'min-dash';\n\nvar DISALLOWED_PROPERTIES = [\n  'artifacts',\n  'dataInputAssociations',\n  'dataOutputAssociations',\n  'default',\n  'flowElements',\n  'lanes',\n  'incoming',\n  'outgoing',\n  'categoryValue'\n];\n\n/**\n * @typedef {Function} <moddleCopy.canCopyProperties> listener\n *\n * @param {Object} context\n * @param {Array<string>} context.propertyNames\n * @param {ModdleElement} context.sourceElement\n * @param {ModdleElement} context.targetElement\n *\n * @returns {Array<string>|boolean} - Return properties to be copied or false to disallow\n * copying.\n */\n\n/**\n * @typedef {Function} <moddleCopy.canCopyProperty> listener\n *\n * @param {Object} context\n * @param {ModdleElement} context.parent\n * @param {*} context.property\n * @param {string} context.propertyName\n *\n * @returns {*|boolean} - Return copied property or false to disallow\n * copying.\n */\n\n/**\n * @typedef {Function} <moddleCopy.canSetCopiedProperty> listener\n *\n * @param {Object} context\n * @param {ModdleElement} context.parent\n * @param {*} context.property\n * @param {string} context.propertyName\n *\n * @returns {boolean} - Return false to disallow\n * setting copied property.\n */\n\n/**\n * Utility for copying model properties from source element to target element.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n * @param {BpmnModdle} moddle\n */\nexport default function ModdleCopy(eventBus, bpmnFactory, moddle) {\n  this._bpmnFactory = bpmnFactory;\n  this._eventBus = eventBus;\n  this._moddle = moddle;\n\n  // copy extension elements last\n  eventBus.on('moddleCopy.canCopyProperties', function(context) {\n    var propertyNames = context.propertyNames;\n\n    if (!propertyNames || !propertyNames.length) {\n      return;\n    }\n\n    return sortBy(propertyNames, function(propertyName) {\n      return propertyName === 'extensionElements';\n    });\n  });\n\n  // default check whether property can be copied\n  eventBus.on('moddleCopy.canCopyProperty', function(context) {\n    var parent = context.parent,\n        parentDescriptor = isObject(parent) && parent.$descriptor,\n        propertyName = context.propertyName;\n\n    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {\n\n      // disallow copying property\n      return false;\n    }\n\n    if (propertyName &&\n      parentDescriptor &&\n      !find(parentDescriptor.properties, matchPattern({ name: propertyName }))) {\n\n      // disallow copying property\n      return false;\n    }\n  });\n\n  // do NOT allow to copy empty extension elements\n  eventBus.on('moddleCopy.canSetCopiedProperty', function(context) {\n    var property = context.property;\n\n    if (is(property, 'bpmn:ExtensionElements') && (!property.values || !property.values.length)) {\n\n      // disallow setting copied property\n      return false;\n    }\n  });\n}\n\nModdleCopy.$inject = [\n  'eventBus',\n  'bpmnFactory',\n  'moddle'\n];\n\n/**\n * Copy model properties of source element to target element.\n *\n * @param {ModdleElement} sourceElement\n * @param {ModdleElement} targetElement\n * @param {Array<string>} [propertyNames]\n * @param {boolean} clone\n *\n * @param {ModdleElement}\n */\nModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames, clone) {\n  var self = this;\n\n  if (propertyNames && !isArray(propertyNames)) {\n    propertyNames = [ propertyNames ];\n  }\n\n  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);\n\n  var canCopyProperties = this._eventBus.fire('moddleCopy.canCopyProperties', {\n    propertyNames: propertyNames,\n    sourceElement: sourceElement,\n    targetElement: targetElement,\n    clone: clone\n  });\n\n  if (canCopyProperties === false) {\n    return targetElement;\n  }\n\n  if (isArray(canCopyProperties)) {\n    propertyNames = canCopyProperties;\n  }\n\n  // copy properties\n  forEach(propertyNames, function(propertyName) {\n    var sourceProperty;\n\n    if (has(sourceElement, propertyName)) {\n      sourceProperty = sourceElement.get(propertyName);\n    }\n\n    var copiedProperty = self.copyProperty(sourceProperty, targetElement, propertyName, clone);\n\n    if (!isDefined(copiedProperty)) {\n      return;\n    }\n\n    var canSetProperty = self._eventBus.fire('moddleCopy.canSetCopiedProperty', {\n      parent: targetElement,\n      property: copiedProperty,\n      propertyName: propertyName\n    });\n\n    if (canSetProperty === false) {\n      return;\n    }\n\n    // TODO(nikku): unclaim old IDs if ID property is copied over\n    // this._moddle.getPropertyDescriptor(parent, propertyName)\n    targetElement.set(propertyName, copiedProperty);\n  });\n\n  return targetElement;\n};\n\n/**\n * Copy model property.\n *\n * @param {*} property\n * @param {ModdleElement} parent\n * @param {string} propertyName\n * @param {boolean} clone\n *\n * @returns {*}\n */\nModdleCopy.prototype.copyProperty = function(property, parent, propertyName, clone) {\n  var self = this;\n\n  // allow others to copy property\n  var copiedProperty = this._eventBus.fire('moddleCopy.canCopyProperty', {\n    parent: parent,\n    property: property,\n    propertyName: propertyName,\n    clone: clone\n  });\n\n  // return if copying is NOT allowed\n  if (copiedProperty === false) {\n    return;\n  }\n\n  if (copiedProperty) {\n    if (isObject(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {\n      copiedProperty.$parent = parent;\n    }\n\n    return copiedProperty;\n  }\n\n  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);\n\n  // do NOT copy references\n  if (propertyDescriptor.isReference) {\n    return;\n  }\n\n  // copy id\n  if (propertyDescriptor.isId) {\n    return property && this._copyId(property, parent, clone);\n  }\n\n  // copy arrays\n  if (isArray(property)) {\n    return reduce(property, function(childProperties, childProperty) {\n\n      // recursion\n      copiedProperty = self.copyProperty(childProperty, parent, propertyName, clone);\n\n      // copying might NOT be allowed\n      if (copiedProperty) {\n        return childProperties.concat(copiedProperty);\n      }\n\n      return childProperties;\n    }, []);\n  }\n\n  // copy model elements\n  if (isObject(property) && property.$type) {\n    if (this._moddle.getElementDescriptor(property).isGeneric) {\n      return;\n    }\n\n    copiedProperty = self._bpmnFactory.create(property.$type);\n\n    copiedProperty.$parent = parent;\n\n    // recursion\n    copiedProperty = self.copyElement(property, copiedProperty, null, clone);\n\n    return copiedProperty;\n  }\n\n  // copy primitive properties\n  return property;\n};\n\nModdleCopy.prototype._copyId = function(id, element, clone) {\n\n  if (clone) {\n    return id;\n  }\n\n  // disallow if already taken\n  if (this._moddle.ids.assigned(id)) {\n    return;\n  } else {\n\n    this._moddle.ids.claim(id, element);\n    return id;\n  }\n};\n\n// helpers //////////\n\nexport function getPropertyNames(descriptor, keepDefaultProperties) {\n  return reduce(descriptor.properties, function(properties, property) {\n\n    if (keepDefaultProperties && property.default) {\n      return properties;\n    }\n\n    return properties.concat(property.name);\n  }, []);\n}\n\nfunction is(element, type) {\n  return element && (typeof element.$instanceOf === 'function') && element.$instanceOf(type);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}