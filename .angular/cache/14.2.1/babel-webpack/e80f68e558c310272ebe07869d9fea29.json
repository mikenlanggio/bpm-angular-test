{"ast":null,"code":"import { uniqueBy, isArray } from 'min-dash';\n/**\n * A service that offers un- and redoable execution of commands.\n *\n * The command stack is responsible for executing modeling actions\n * in a un- and redoable manner. To do this it delegates the actual\n * command execution to {@link CommandHandler}s.\n *\n * Command handlers provide {@link CommandHandler#execute(ctx)} and\n * {@link CommandHandler#revert(ctx)} methods to un- and redo a command\n * identified by a command context.\n *\n *\n * ## Life-Cycle events\n *\n * In the process the command stack fires a number of life-cycle events\n * that other components to participate in the command execution.\n *\n *    * preExecute\n *    * preExecuted\n *    * execute\n *    * executed\n *    * postExecute\n *    * postExecuted\n *    * revert\n *    * reverted\n *\n * A special event is used for validating, whether a command can be\n * performed prior to its execution.\n *\n *    * canExecute\n *\n * Each of the events is fired as `commandStack.{eventName}` and\n * `commandStack.{commandName}.{eventName}`, respectively. This gives\n * components fine grained control on where to hook into.\n *\n * The event object fired transports `command`, the name of the\n * command and `context`, the command context.\n *\n *\n * ## Creating Command Handlers\n *\n * Command handlers should provide the {@link CommandHandler#execute(ctx)}\n * and {@link CommandHandler#revert(ctx)} methods to implement\n * redoing and undoing of a command.\n *\n * A command handler _must_ ensure undo is performed properly in order\n * not to break the undo chain. It must also return the shapes that\n * got changed during the `execute` and `revert` operations.\n *\n * Command handlers may execute other modeling operations (and thus\n * commands) in their `preExecute` and `postExecute` phases. The command\n * stack will properly group all commands together into a logical unit\n * that may be re- and undone atomically.\n *\n * Command handlers must not execute other commands from within their\n * core implementation (`execute`, `revert`).\n *\n *\n * ## Change Tracking\n *\n * During the execution of the CommandStack it will keep track of all\n * elements that have been touched during the command's execution.\n *\n * At the end of the CommandStack execution it will notify interested\n * components via an 'elements.changed' event with all the dirty\n * elements.\n *\n * The event can be picked up by components that are interested in the fact\n * that elements have been changed. One use case for this is updating\n * their graphical representation after moving / resizing or deletion.\n *\n * @see CommandHandler\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\n\nexport default function CommandStack(eventBus, injector) {\n  /**\n   * A map of all registered command handlers.\n   *\n   * @type {Object}\n   */\n  this._handlerMap = {};\n  /**\n   * A stack containing all re/undoable actions on the diagram\n   *\n   * @type {Array<Object>}\n   */\n\n  this._stack = [];\n  /**\n   * The current index on the stack\n   *\n   * @type {number}\n   */\n\n  this._stackIdx = -1;\n  /**\n   * Current active commandStack execution\n   *\n   * @type {Object}\n   * @property {Object[]} actions\n   * @property {Object[]} dirty\n   * @property { 'undo' | 'redo' | 'clear' | 'execute' | null } trigger the cause of the current excecution\n   */\n\n  this._currentExecution = {\n    actions: [],\n    dirty: [],\n    trigger: null\n  };\n  this._injector = injector;\n  this._eventBus = eventBus;\n  this._uid = 1;\n  eventBus.on(['diagram.destroy', 'diagram.clear'], function () {\n    this.clear(false);\n  }, this);\n}\nCommandStack.$inject = ['eventBus', 'injector'];\n/**\n * Execute a command\n *\n * @param {string} command the command to execute\n * @param {Object} context the environment to execute the command in\n */\n\nCommandStack.prototype.execute = function (command, context) {\n  if (!command) {\n    throw new Error('command required');\n  }\n\n  this._currentExecution.trigger = 'execute';\n  var action = {\n    command: command,\n    context: context\n  };\n\n  this._pushAction(action);\n\n  this._internalExecute(action);\n\n  this._popAction(action);\n};\n/**\n * Ask whether a given command can be executed.\n *\n * Implementors may hook into the mechanism on two ways:\n *\n *   * in event listeners:\n *\n *     Users may prevent the execution via an event listener.\n *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.\n *\n *   * in command handlers:\n *\n *     If the method {@link CommandHandler#canExecute} is implemented in a handler\n *     it will be called to figure out whether the execution is allowed.\n *\n * @param  {string} command the command to execute\n * @param  {Object} context the environment to execute the command in\n *\n * @return {boolean} true if the command can be executed\n */\n\n\nCommandStack.prototype.canExecute = function (command, context) {\n  var action = {\n    command: command,\n    context: context\n  };\n\n  var handler = this._getHandler(command);\n\n  var result = this._fire(command, 'canExecute', action); // handler#canExecute will only be called if no listener\n  // decided on a result already\n\n\n  if (result === undefined) {\n    if (!handler) {\n      return false;\n    }\n\n    if (handler.canExecute) {\n      result = handler.canExecute(context);\n    }\n  }\n\n  return result;\n};\n/**\n * Clear the command stack, erasing all undo / redo history\n */\n\n\nCommandStack.prototype.clear = function (emit) {\n  this._stack.length = 0;\n  this._stackIdx = -1;\n\n  if (emit !== false) {\n    this._fire('changed', {\n      trigger: 'clear'\n    });\n  }\n};\n/**\n * Undo last command(s)\n */\n\n\nCommandStack.prototype.undo = function () {\n  var action = this._getUndoAction(),\n      next;\n\n  if (action) {\n    this._currentExecution.trigger = 'undo';\n\n    this._pushAction(action);\n\n    while (action) {\n      this._internalUndo(action);\n\n      next = this._getUndoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n/**\n * Redo last command(s)\n */\n\n\nCommandStack.prototype.redo = function () {\n  var action = this._getRedoAction(),\n      next;\n\n  if (action) {\n    this._currentExecution.trigger = 'redo';\n\n    this._pushAction(action);\n\n    while (action) {\n      this._internalExecute(action, true);\n\n      next = this._getRedoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n/**\n * Register a handler instance with the command stack\n *\n * @param {string} command\n * @param {CommandHandler} handler\n */\n\n\nCommandStack.prototype.register = function (command, handler) {\n  this._setHandler(command, handler);\n};\n/**\n * Register a handler type with the command stack\n * by instantiating it and injecting its dependencies.\n *\n * @param {string} command\n * @param {Function} a constructor for a {@link CommandHandler}\n */\n\n\nCommandStack.prototype.registerHandler = function (command, handlerCls) {\n  if (!command || !handlerCls) {\n    throw new Error('command and handlerCls must be defined');\n  }\n\n  var handler = this._injector.instantiate(handlerCls);\n\n  this.register(command, handler);\n};\n\nCommandStack.prototype.canUndo = function () {\n  return !!this._getUndoAction();\n};\n\nCommandStack.prototype.canRedo = function () {\n  return !!this._getRedoAction();\n}; // stack access  //////////////////////\n\n\nCommandStack.prototype._getRedoAction = function () {\n  return this._stack[this._stackIdx + 1];\n};\n\nCommandStack.prototype._getUndoAction = function () {\n  return this._stack[this._stackIdx];\n}; // internal functionality //////////////////////\n\n\nCommandStack.prototype._internalUndo = function (action) {\n  var self = this;\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command); // guard against illegal nested command stack invocations\n\n\n  this._atomicDo(function () {\n    self._fire(command, 'revert', action);\n\n    if (handler.revert) {\n      self._markDirty(handler.revert(context));\n    }\n\n    self._revertedAction(action);\n\n    self._fire(command, 'reverted', action);\n  });\n};\n\nCommandStack.prototype._fire = function (command, qualifier, event) {\n  if (arguments.length < 3) {\n    event = qualifier;\n    qualifier = null;\n  }\n\n  var names = qualifier ? [command + '.' + qualifier, qualifier] : [command],\n      i,\n      name,\n      result;\n  event = this._eventBus.createEvent(event);\n\n  for (i = 0; name = names[i]; i++) {\n    result = this._eventBus.fire('commandStack.' + name, event);\n\n    if (event.cancelBubble) {\n      break;\n    }\n  }\n\n  return result;\n};\n\nCommandStack.prototype._createId = function () {\n  return this._uid++;\n};\n\nCommandStack.prototype._atomicDo = function (fn) {\n  var execution = this._currentExecution;\n  execution.atomic = true;\n\n  try {\n    fn();\n  } finally {\n    execution.atomic = false;\n  }\n};\n\nCommandStack.prototype._internalExecute = function (action, redo) {\n  var self = this;\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command);\n\n  if (!handler) {\n    throw new Error('no command handler registered for <' + command + '>');\n  }\n\n  this._pushAction(action);\n\n  if (!redo) {\n    this._fire(command, 'preExecute', action);\n\n    if (handler.preExecute) {\n      handler.preExecute(context);\n    }\n\n    this._fire(command, 'preExecuted', action);\n  } // guard against illegal nested command stack invocations\n\n\n  this._atomicDo(function () {\n    self._fire(command, 'execute', action);\n\n    if (handler.execute) {\n      // actual execute + mark return results as dirty\n      self._markDirty(handler.execute(context));\n    } // log to stack\n\n\n    self._executedAction(action, redo);\n\n    self._fire(command, 'executed', action);\n  });\n\n  if (!redo) {\n    this._fire(command, 'postExecute', action);\n\n    if (handler.postExecute) {\n      handler.postExecute(context);\n    }\n\n    this._fire(command, 'postExecuted', action);\n  }\n\n  this._popAction(action);\n};\n\nCommandStack.prototype._pushAction = function (action) {\n  var execution = this._currentExecution,\n      actions = execution.actions;\n  var baseAction = actions[0];\n\n  if (execution.atomic) {\n    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');\n  }\n\n  if (!action.id) {\n    action.id = baseAction && baseAction.id || this._createId();\n  }\n\n  actions.push(action);\n};\n\nCommandStack.prototype._popAction = function () {\n  var execution = this._currentExecution,\n      trigger = execution.trigger,\n      actions = execution.actions,\n      dirty = execution.dirty;\n  actions.pop();\n\n  if (!actions.length) {\n    this._eventBus.fire('elements.changed', {\n      elements: uniqueBy('id', dirty.reverse())\n    });\n\n    dirty.length = 0;\n\n    this._fire('changed', {\n      trigger: trigger\n    });\n\n    execution.trigger = null;\n  }\n};\n\nCommandStack.prototype._markDirty = function (elements) {\n  var execution = this._currentExecution;\n\n  if (!elements) {\n    return;\n  }\n\n  elements = isArray(elements) ? elements : [elements];\n  execution.dirty = execution.dirty.concat(elements);\n};\n\nCommandStack.prototype._executedAction = function (action, redo) {\n  var stackIdx = ++this._stackIdx;\n\n  if (!redo) {\n    this._stack.splice(stackIdx, this._stack.length, action);\n  }\n};\n\nCommandStack.prototype._revertedAction = function (action) {\n  this._stackIdx--;\n};\n\nCommandStack.prototype._getHandler = function (command) {\n  return this._handlerMap[command];\n};\n\nCommandStack.prototype._setHandler = function (command, handler) {\n  if (!command || !handler) {\n    throw new Error('command and handler required');\n  }\n\n  if (this._handlerMap[command]) {\n    throw new Error('overriding handler for command <' + command + '>');\n  }\n\n  this._handlerMap[command] = handler;\n};","map":{"version":3,"names":["uniqueBy","isArray","CommandStack","eventBus","injector","_handlerMap","_stack","_stackIdx","_currentExecution","actions","dirty","trigger","_injector","_eventBus","_uid","on","clear","$inject","prototype","execute","command","context","Error","action","_pushAction","_internalExecute","_popAction","canExecute","handler","_getHandler","result","_fire","undefined","emit","length","undo","_getUndoAction","next","_internalUndo","id","redo","_getRedoAction","register","_setHandler","registerHandler","handlerCls","instantiate","canUndo","canRedo","self","_atomicDo","revert","_markDirty","_revertedAction","qualifier","event","arguments","names","i","name","createEvent","fire","cancelBubble","_createId","fn","execution","atomic","preExecute","_executedAction","postExecute","baseAction","push","pop","elements","reverse","concat","stackIdx","splice"],"sources":["E:/Old_PC/Study/Angular/test-bpm/node_modules/diagram-js/lib/command/CommandStack.js"],"sourcesContent":["import {\n  uniqueBy,\n  isArray\n} from 'min-dash';\n\n\n/**\n * A service that offers un- and redoable execution of commands.\n *\n * The command stack is responsible for executing modeling actions\n * in a un- and redoable manner. To do this it delegates the actual\n * command execution to {@link CommandHandler}s.\n *\n * Command handlers provide {@link CommandHandler#execute(ctx)} and\n * {@link CommandHandler#revert(ctx)} methods to un- and redo a command\n * identified by a command context.\n *\n *\n * ## Life-Cycle events\n *\n * In the process the command stack fires a number of life-cycle events\n * that other components to participate in the command execution.\n *\n *    * preExecute\n *    * preExecuted\n *    * execute\n *    * executed\n *    * postExecute\n *    * postExecuted\n *    * revert\n *    * reverted\n *\n * A special event is used for validating, whether a command can be\n * performed prior to its execution.\n *\n *    * canExecute\n *\n * Each of the events is fired as `commandStack.{eventName}` and\n * `commandStack.{commandName}.{eventName}`, respectively. This gives\n * components fine grained control on where to hook into.\n *\n * The event object fired transports `command`, the name of the\n * command and `context`, the command context.\n *\n *\n * ## Creating Command Handlers\n *\n * Command handlers should provide the {@link CommandHandler#execute(ctx)}\n * and {@link CommandHandler#revert(ctx)} methods to implement\n * redoing and undoing of a command.\n *\n * A command handler _must_ ensure undo is performed properly in order\n * not to break the undo chain. It must also return the shapes that\n * got changed during the `execute` and `revert` operations.\n *\n * Command handlers may execute other modeling operations (and thus\n * commands) in their `preExecute` and `postExecute` phases. The command\n * stack will properly group all commands together into a logical unit\n * that may be re- and undone atomically.\n *\n * Command handlers must not execute other commands from within their\n * core implementation (`execute`, `revert`).\n *\n *\n * ## Change Tracking\n *\n * During the execution of the CommandStack it will keep track of all\n * elements that have been touched during the command's execution.\n *\n * At the end of the CommandStack execution it will notify interested\n * components via an 'elements.changed' event with all the dirty\n * elements.\n *\n * The event can be picked up by components that are interested in the fact\n * that elements have been changed. One use case for this is updating\n * their graphical representation after moving / resizing or deletion.\n *\n * @see CommandHandler\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function CommandStack(eventBus, injector) {\n\n  /**\n   * A map of all registered command handlers.\n   *\n   * @type {Object}\n   */\n  this._handlerMap = {};\n\n  /**\n   * A stack containing all re/undoable actions on the diagram\n   *\n   * @type {Array<Object>}\n   */\n  this._stack = [];\n\n  /**\n   * The current index on the stack\n   *\n   * @type {number}\n   */\n  this._stackIdx = -1;\n\n  /**\n   * Current active commandStack execution\n   *\n   * @type {Object}\n   * @property {Object[]} actions\n   * @property {Object[]} dirty\n   * @property { 'undo' | 'redo' | 'clear' | 'execute' | null } trigger the cause of the current excecution\n   */\n  this._currentExecution = {\n    actions: [],\n    dirty: [],\n    trigger: null\n  };\n\n\n  this._injector = injector;\n  this._eventBus = eventBus;\n\n  this._uid = 1;\n\n  eventBus.on([\n    'diagram.destroy',\n    'diagram.clear'\n  ], function() {\n    this.clear(false);\n  }, this);\n}\n\nCommandStack.$inject = [ 'eventBus', 'injector' ];\n\n\n/**\n * Execute a command\n *\n * @param {string} command the command to execute\n * @param {Object} context the environment to execute the command in\n */\nCommandStack.prototype.execute = function(command, context) {\n  if (!command) {\n    throw new Error('command required');\n  }\n\n  this._currentExecution.trigger = 'execute';\n\n  var action = { command: command, context: context };\n\n  this._pushAction(action);\n  this._internalExecute(action);\n  this._popAction(action);\n};\n\n\n/**\n * Ask whether a given command can be executed.\n *\n * Implementors may hook into the mechanism on two ways:\n *\n *   * in event listeners:\n *\n *     Users may prevent the execution via an event listener.\n *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.\n *\n *   * in command handlers:\n *\n *     If the method {@link CommandHandler#canExecute} is implemented in a handler\n *     it will be called to figure out whether the execution is allowed.\n *\n * @param  {string} command the command to execute\n * @param  {Object} context the environment to execute the command in\n *\n * @return {boolean} true if the command can be executed\n */\nCommandStack.prototype.canExecute = function(command, context) {\n\n  var action = { command: command, context: context };\n\n  var handler = this._getHandler(command);\n\n  var result = this._fire(command, 'canExecute', action);\n\n  // handler#canExecute will only be called if no listener\n  // decided on a result already\n  if (result === undefined) {\n    if (!handler) {\n      return false;\n    }\n\n    if (handler.canExecute) {\n      result = handler.canExecute(context);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Clear the command stack, erasing all undo / redo history\n */\nCommandStack.prototype.clear = function(emit) {\n  this._stack.length = 0;\n  this._stackIdx = -1;\n\n  if (emit !== false) {\n    this._fire('changed', { trigger: 'clear' });\n  }\n};\n\n\n/**\n * Undo last command(s)\n */\nCommandStack.prototype.undo = function() {\n  var action = this._getUndoAction(),\n      next;\n\n  if (action) {\n    this._currentExecution.trigger = 'undo';\n\n    this._pushAction(action);\n\n    while (action) {\n      this._internalUndo(action);\n      next = this._getUndoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Redo last command(s)\n */\nCommandStack.prototype.redo = function() {\n  var action = this._getRedoAction(),\n      next;\n\n  if (action) {\n    this._currentExecution.trigger = 'redo';\n\n    this._pushAction(action);\n\n    while (action) {\n      this._internalExecute(action, true);\n      next = this._getRedoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Register a handler instance with the command stack\n *\n * @param {string} command\n * @param {CommandHandler} handler\n */\nCommandStack.prototype.register = function(command, handler) {\n  this._setHandler(command, handler);\n};\n\n\n/**\n * Register a handler type with the command stack\n * by instantiating it and injecting its dependencies.\n *\n * @param {string} command\n * @param {Function} a constructor for a {@link CommandHandler}\n */\nCommandStack.prototype.registerHandler = function(command, handlerCls) {\n\n  if (!command || !handlerCls) {\n    throw new Error('command and handlerCls must be defined');\n  }\n\n  var handler = this._injector.instantiate(handlerCls);\n  this.register(command, handler);\n};\n\nCommandStack.prototype.canUndo = function() {\n  return !!this._getUndoAction();\n};\n\nCommandStack.prototype.canRedo = function() {\n  return !!this._getRedoAction();\n};\n\n// stack access  //////////////////////\n\nCommandStack.prototype._getRedoAction = function() {\n  return this._stack[this._stackIdx + 1];\n};\n\n\nCommandStack.prototype._getUndoAction = function() {\n  return this._stack[this._stackIdx];\n};\n\n\n// internal functionality //////////////////////\n\nCommandStack.prototype._internalUndo = function(action) {\n  var self = this;\n\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command);\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(function() {\n    self._fire(command, 'revert', action);\n\n    if (handler.revert) {\n      self._markDirty(handler.revert(context));\n    }\n\n    self._revertedAction(action);\n\n    self._fire(command, 'reverted', action);\n  });\n};\n\n\nCommandStack.prototype._fire = function(command, qualifier, event) {\n  if (arguments.length < 3) {\n    event = qualifier;\n    qualifier = null;\n  }\n\n  var names = qualifier ? [ command + '.' + qualifier, qualifier ] : [ command ],\n      i, name, result;\n\n  event = this._eventBus.createEvent(event);\n\n  for (i = 0; (name = names[i]); i++) {\n    result = this._eventBus.fire('commandStack.' + name, event);\n\n    if (event.cancelBubble) {\n      break;\n    }\n  }\n\n  return result;\n};\n\nCommandStack.prototype._createId = function() {\n  return this._uid++;\n};\n\nCommandStack.prototype._atomicDo = function(fn) {\n\n  var execution = this._currentExecution;\n\n  execution.atomic = true;\n\n  try {\n    fn();\n  } finally {\n    execution.atomic = false;\n  }\n};\n\nCommandStack.prototype._internalExecute = function(action, redo) {\n  var self = this;\n\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command);\n\n  if (!handler) {\n    throw new Error('no command handler registered for <' + command + '>');\n  }\n\n  this._pushAction(action);\n\n  if (!redo) {\n    this._fire(command, 'preExecute', action);\n\n    if (handler.preExecute) {\n      handler.preExecute(context);\n    }\n\n    this._fire(command, 'preExecuted', action);\n  }\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(function() {\n\n    self._fire(command, 'execute', action);\n\n    if (handler.execute) {\n\n      // actual execute + mark return results as dirty\n      self._markDirty(handler.execute(context));\n    }\n\n    // log to stack\n    self._executedAction(action, redo);\n\n    self._fire(command, 'executed', action);\n  });\n\n  if (!redo) {\n    this._fire(command, 'postExecute', action);\n\n    if (handler.postExecute) {\n      handler.postExecute(context);\n    }\n\n    this._fire(command, 'postExecuted', action);\n  }\n\n  this._popAction(action);\n};\n\n\nCommandStack.prototype._pushAction = function(action) {\n\n  var execution = this._currentExecution,\n      actions = execution.actions;\n\n  var baseAction = actions[0];\n\n  if (execution.atomic) {\n    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');\n  }\n\n  if (!action.id) {\n    action.id = (baseAction && baseAction.id) || this._createId();\n  }\n\n  actions.push(action);\n};\n\n\nCommandStack.prototype._popAction = function() {\n  var execution = this._currentExecution,\n      trigger = execution.trigger,\n      actions = execution.actions,\n      dirty = execution.dirty;\n\n  actions.pop();\n\n  if (!actions.length) {\n    this._eventBus.fire('elements.changed', { elements: uniqueBy('id', dirty.reverse()) });\n\n    dirty.length = 0;\n\n    this._fire('changed', { trigger: trigger });\n\n    execution.trigger = null;\n  }\n};\n\n\nCommandStack.prototype._markDirty = function(elements) {\n  var execution = this._currentExecution;\n\n  if (!elements) {\n    return;\n  }\n\n  elements = isArray(elements) ? elements : [ elements ];\n\n  execution.dirty = execution.dirty.concat(elements);\n};\n\n\nCommandStack.prototype._executedAction = function(action, redo) {\n  var stackIdx = ++this._stackIdx;\n\n  if (!redo) {\n    this._stack.splice(stackIdx, this._stack.length, action);\n  }\n};\n\n\nCommandStack.prototype._revertedAction = function(action) {\n  this._stackIdx--;\n};\n\n\nCommandStack.prototype._getHandler = function(command) {\n  return this._handlerMap[command];\n};\n\nCommandStack.prototype._setHandler = function(command, handler) {\n  if (!command || !handler) {\n    throw new Error('command and handler required');\n  }\n\n  if (this._handlerMap[command]) {\n    throw new Error('overriding handler for command <' + command + '>');\n  }\n\n  this._handlerMap[command] = handler;\n};\n"],"mappings":"AAAA,SACEA,QADF,EAEEC,OAFF,QAGO,UAHP;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,YAAT,CAAsBC,QAAtB,EAAgCC,QAAhC,EAA0C;EAEvD;AACF;AACA;AACA;AACA;EACE,KAAKC,WAAL,GAAmB,EAAnB;EAEA;AACF;AACA;AACA;AACA;;EACE,KAAKC,MAAL,GAAc,EAAd;EAEA;AACF;AACA;AACA;AACA;;EACE,KAAKC,SAAL,GAAiB,CAAC,CAAlB;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,KAAKC,iBAAL,GAAyB;IACvBC,OAAO,EAAE,EADc;IAEvBC,KAAK,EAAE,EAFgB;IAGvBC,OAAO,EAAE;EAHc,CAAzB;EAOA,KAAKC,SAAL,GAAiBR,QAAjB;EACA,KAAKS,SAAL,GAAiBV,QAAjB;EAEA,KAAKW,IAAL,GAAY,CAAZ;EAEAX,QAAQ,CAACY,EAAT,CAAY,CACV,iBADU,EAEV,eAFU,CAAZ,EAGG,YAAW;IACZ,KAAKC,KAAL,CAAW,KAAX;EACD,CALD,EAKG,IALH;AAMD;AAEDd,YAAY,CAACe,OAAb,GAAuB,CAAE,UAAF,EAAc,UAAd,CAAvB;AAGA;AACA;AACA;AACA;AACA;AACA;;AACAf,YAAY,CAACgB,SAAb,CAAuBC,OAAvB,GAAiC,UAASC,OAAT,EAAkBC,OAAlB,EAA2B;EAC1D,IAAI,CAACD,OAAL,EAAc;IACZ,MAAM,IAAIE,KAAJ,CAAU,kBAAV,CAAN;EACD;;EA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"},"metadata":{},"sourceType":"module"}